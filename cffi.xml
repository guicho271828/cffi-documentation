<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
  <!ENTITY tex "TeX">
  <!ENTITY latex "LaTeX">
]>
<book id="cffi.xml" lang="en">
<title>CFFI User Manual</title>

<!-- @documentencoding utf-8 -->

<!-- Style notes: -->
<!-- -->
<!-- * The reference section names and "See Also" list are roman, not -->
<!--   @code.  This is to follow the format of CLHS. -->
<!-- -->
<!-- * How it looks in HTML is the priority. -->

<!-- ============================= Macros ============================= -->
<!-- The following macros are used throughout this manual. -->










<!-- Info "requires" that x-refs end in a period or comma, or ) in the -->
<!-- case of @pxref.  So the following implements that requirement for -->
<!-- the "See also" subheadings that permeate this manual, but only in -->
<!-- Info mode. -->


<!-- Typeset comments in roman font for the TeX output. -->


<!-- ============================= Macros ============================= -->


<!-- Show types, functions, and concepts in the same index. -->

<bookinfo><legalnotice><para>Copyright &#169; 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; 

Copyright &#169; 2005-2015 Lu&#237;s Oliveira
  &lt;loliveira at common-lisp.net&gt; 

Copyright &#169; 2005-2006 Dan Knapp &lt;danka at accela.net&gt; 

Copyright &#169; 2005-2006 Emily Backes &lt;lucca at accela.net&gt; 

Copyright &#169; 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;
</para>
<blockquote><para>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&#8220;Software&#8221;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</para>
<para>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</para>
<para>THE SOFTWARE IS PROVIDED &#8220;AS IS&#8221;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</para></blockquote></legalnotice></bookinfo><!-- %**end of header -->


<!-- @subtitle Version X.X -->
<!-- @author James Bielman -->

<para>Copyright &#169; 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; 

Copyright &#169; 2005-2015 Lu&#237;s Oliveira
  &lt;loliveira at common-lisp.net&gt; 

Copyright &#169; 2005-2006 Dan Knapp &lt;danka at accela.net&gt; 

Copyright &#169; 2005-2006 Emily Backes &lt;lucca at accela.net&gt; 

Copyright &#169; 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;
</para>
<blockquote><para>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&#8220;Software&#8221;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</para>
<para>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</para>
<para>THE SOFTWARE IS PROVIDED &#8220;AS IS&#8221;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</para></blockquote>

<chapter label="" id="Top">
<title>cffi</title>
<para>Copyright &#169; 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; 

Copyright &#169; 2005-2015 Lu&#237;s Oliveira
  &lt;loliveira at common-lisp.net&gt; 

Copyright &#169; 2005-2006 Dan Knapp &lt;danka at accela.net&gt; 

Copyright &#169; 2005-2006 Emily Backes &lt;lucca at accela.net&gt; 

Copyright &#169; 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;
</para>
<blockquote><para>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&#8220;Software&#8221;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</para>
<para>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</para>
<para>THE SOFTWARE IS PROVIDED &#8220;AS IS&#8221;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</para></blockquote>




<!-- =================================================================== -->
<!-- CHAPTER: Introduction -->

</chapter>
<chapter label="1" id="Introduction">
<title>Introduction</title>

<para><acronym>CFFI</acronym> is the Common Foreign Function Interface for <acronym>ANSI</acronym>
Common Lisp systems.  By <firstterm>foreign function</firstterm> we mean a function
written in another programming language and having different data and
calling conventions than Common Lisp, namely, C.  <acronym>CFFI</acronym> allows you
to call foreign functions and access foreign variables, all without
leaving the Lisp image.
</para>
<para>We consider this manual ever a work in progress.  If you have
difficulty with anything <acronym>CFFI</acronym>-specific presented in the manual,
please contact <ulink url="mailto:cffi-devel@common-lisp.net">the developers</ulink> with
details.
</para>

<bridgehead renderas="sect1">Motivation</bridgehead>

<para>See <link linkend="Tutorial_002dComparison">What makes Lisp different</link>, for
an argument in favor of <acronym>FFI</acronym> in general.
</para>
<para><acronym>CFFI</acronym>&#8217;s primary role in any image is to mediate between Lisp
developers and the widely varying <acronym>FFI</acronym>s present in the
various Lisp implementations it supports.  With <acronym>CFFI</acronym>, you can
define foreign function interfaces while still maintaining portability
between implementations.  It is not the first Common Lisp package with
this objective; however, it is meant to be a more malleable framework
than similar packages.
</para>

<bridgehead renderas="sect1">Design Philosophy</bridgehead>

<itemizedlist><listitem><para>Pointers do not carry around type information. Instead, type
information is supplied when pointers are dereferenced.
</para>
</listitem><listitem><para>A type safe pointer interface can be developed on top of an
untyped one.  It is difficult to do the opposite.
</para>
</listitem><listitem><para>Functions are better than macros.  When a macro could be used
for performance, use a compiler-macro instead.
</para></listitem></itemizedlist>

<!-- =================================================================== -->
<!-- CHAPTER: Installation -->

</chapter>
<chapter label="2" id="Installation">
<title>Installation</title>

<para><acronym>CFFI</acronym> can be obtained through one of the following means available
through its <ulink url="http://common-lisp.net/project/cffi/">website</ulink>:
</para>
<itemizedlist><listitem><para><ulink url="http://common-lisp.net/project/cffi/releases/?M=D">official release
tarballs</ulink>
</para>
</listitem><listitem><para><ulink url="http://common-lisp.net/gitweb?p=projects/cffi/cffi.git">git
repository</ulink>
</para>
<!-- snapshots have been disabled as of -->
<!-- @item -->
<!-- @uref{http://common-lisp.net/project/cffi/tarballs/?M=D,,nightly-generated -->
<!-- snapshots} -->

</listitem></itemizedlist>
<para>In addition, you will need to obtain and install the following
dependencies:
</para>
<itemizedlist><listitem><para><ulink url="http://common-lisp.net/project/babel/">Babel</ulink>, a charset
encoding/decoding library.
</para>
</listitem><listitem><para><ulink url="http://common-lisp.net/project/alexandria/">Alexandria</ulink>, a
collection of portable public-domain utilities.
</para>
</listitem><listitem><para><ulink url="http://www.cliki.net/trivial-features">trivial-features</ulink>, a
portability layer that ensures consistent <literal>*features*</literal> across
multiple Common Lisp implementations.
</para>
</listitem></itemizedlist>
<para>Furthermore, if you wish to run the testsuite,
<ulink url="http://www.cliki.net/rt">RT</ulink> is required.
</para>
<para>You may find mechanisms such as
<ulink url="https://www.quicklisp.org/beta/">Quicklisp</ulink> (recommended)
or <ulink url="http://common-lisp.net/project/clbuild/">clbuild</ulink> (for advanced
uses) helpful in getting and managing <acronym>CFFI</acronym> and its
dependencies.
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Implementation Support -->

</chapter>
<chapter label="3" id="Implementation-Support">
<title>Implementation Support</title>

<para><acronym>CFFI</acronym> supports various free and commercial Lisp implementations:
<acronym>ABCL</acronym>, Allegro CL, Clasp, CLISP, Clozure CL,
<acronym>CMUCL</acronym>, Corman CL, <acronym>ECL</acronym>, <acronym>GCL</acronym>, LispWorks,
<acronym>MCL</acronym>, <acronym>SBCL</acronym> and the Scieneer CL.
</para>
<para>In general, you should work with the latest versions of each
implementation since those will usually be tested against recent
versions of CFFI more often and might include necessary features or
bug fixes. Reasonable patches for compatibility with earlier versions
are welcome nevertheless.
</para>
<sect1 label="3.1">
<title>Limitations</title>

<para>Some features are not supported in all implementations.
<!-- TODO: describe these features here. -->
<!--       flat-namespace too -->
</para>
<bridgehead renderas="sect2">Allegro CL</bridgehead>

<itemizedlist><listitem><para>Does not support the <literal>:long-long</literal> type natively.
</para></listitem><listitem><para>Unicode support is limited to the Basic Multilingual Plane (16-bit
code points).
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">Clasp</bridgehead>

<itemizedlist><listitem><para>Only supports a flat namespace.
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">CMUCL</bridgehead>

<itemizedlist><listitem><para>No Unicode support. (8-bit code points)
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">Corman CL</bridgehead>

<itemizedlist><listitem><para>Does not support <literal>foreign-funcall</literal>.
</para></listitem></itemizedlist>
<bridgehead renderas="sect2"><acronym>ECL</acronym></bridgehead>

<itemizedlist><listitem><para>On platforms where ECL&#8217;s dynamic FFI is not supported (ie. when
<literal>:dffi</literal> is not present in <literal>*features*</literal>),
<literal>cffi:load-foreign-library</literal> does not work and you must use ECL&#8217;s
own <literal>ffi:load-foreign-library</literal> with a constant string argument.
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">Lispworks</bridgehead>

<itemizedlist><listitem><para>Does not completely support the <literal>:long-long</literal> type natively in
32-bit platforms.
</para></listitem><listitem><para>Unicode support is limited to the Basic Multilingual Plane (16-bit
code points).
</para></listitem></itemizedlist>
<bridgehead renderas="sect2"><acronym>SBCL</acronym></bridgehead>

<itemizedlist><listitem><para>Not all platforms support callbacks.
</para>
</listitem></itemizedlist>

<!-- =================================================================== -->
<!-- CHAPTER: An Introduction to Foreign Interfaces and CFFI -->

<!-- This macro is merely a marker that I don't think I'll use after -->
<!-- all. -->

<!-- because I don't want to type this over and over -->
<!-- TeX puts spurious newlines in when you use the above macro -->
<!-- in @examples &c.  So it is expanded below in some places. -->


</sect1>
</chapter>
<chapter label="4" id="Tutorial">
<title>An Introduction to Foreign Interfaces and <acronym>CFFI</acronym></title>

<!-- Above, I don't use the cffi macro because it breaks TeX. -->

<indexterm role="cp"><primary>tutorial, <acronym>CFFI</acronym></primary></indexterm>
<para>Users of many popular languages bearing semantic similarity to Lisp,
such as Perl and Python, are accustomed to having access to popular C
libraries, such as <acronym>GTK</acronym>, by way of &#8220;bindings&#8221;.  In Lisp, we
do something similar, but take a fundamentally different approach.
This tutorial first explains this difference, then explains how you
can use <acronym>CFFI</acronym>, a powerful system for calling out to C and C++ and
access C data from many Common Lisp implementations.
</para>
<indexterm role="cp"><primary>foreign functions and data</primary></indexterm>
<para>The concept can be generalized to other languages; at the time of
writing, only <acronym>CFFI</acronym>&#8217;s C support is fairly complete. Therefore, we
will interchangeably refer to <firstterm>foreign functions</firstterm> and <firstterm>foreign
data</firstterm>, and &#8220;C functions&#8221; and &#8220;C data&#8221;.  At no time will the word
&#8220;foreign&#8221; carry its usual, non-programming meaning.
</para>
<para>This tutorial expects you to have a working understanding of both
Common Lisp and C, including the Common Lisp macro system.
</para>


<sect1 label="4.1" id="Tutorial_002dComparison">
<title>What makes Lisp different</title>

<para>The following sums up how bindings to foreign libraries are usually
implemented in other languages, then in Common Lisp:
</para>
<variablelist><varlistentry><term>Perl, Python, Java, other one-implementation languages
</term><listitem><indexterm role="cp"><primary><acronym>SWIG</acronym></primary></indexterm>
<indexterm role="cp"><primary>Perl</primary></indexterm>
<indexterm role="cp"><primary>Python</primary></indexterm>
<para>Bindings are implemented as shared objects written in C.  In some
cases, the C code is generated by a tool, such as <acronym>SWIG</acronym>, but
the result is the same: a new C library that manually translates
between the language implementation&#8217;s objects, such as <literal>PyObject</literal>
in Python, and whatever C object is called for, often using C
functions provided by the implementation.  It also translates between
the calling conventions of the language and C.
</para>
</listitem></varlistentry><varlistentry><term>Common Lisp
</term><listitem><indexterm role="cp"><primary><acronym>SLIME</acronym></primary></indexterm>
<para>Bindings are written in Lisp.  They can be created at-will by Lisp
programs.  Lisp programmers can write new bindings and add them to the
image, using a listener such as <acronym>SLIME</acronym>, as easily as with
regular Lisp definitions.  The only foreign library to load is the one
being wrapped&#8212;the one with the pure C interface; no C or other
non-Lisp compilation is required.
</para></listitem></varlistentry></variablelist>
<indexterm role="cp"><primary>advantages of <acronym>FFI</acronym></primary></indexterm>
<indexterm role="cp"><primary>benefits of <acronym>FFI</acronym></primary></indexterm>
<para>We believe the advantages of the Common Lisp approach far outweigh any
disadvantages.  Incremental development with a listener can be as
productive for C binding development as it is with other Lisp
development.  Keeping it &#8220;in the [Lisp] family&#8221;, as it were, makes
it much easier for you and other Lisp programmers to load and use the
bindings.  Common Lisp implementations such as <acronym>CMUCL</acronym>, freed
from having to provide a C interface to their own objects, are thus
freed to be implemented in another language (as <acronym>CMUCL</acronym> is)
while still allowing programmers to call foreign functions.
</para>
<indexterm role="cp"><primary>minimal bindings</primary></indexterm>
<para>Perhaps the greatest advantage is that using an <acronym>FFI</acronym> doesn&#8217;t
obligate you to become a professional binding developer.  Writers of
bindings for other languages usually end up maintaining or failing to
maintain complete bindings to the foreign library.  Using an
<acronym>FFI</acronym>, however, means if you only need one or two functions,
you can write bindings for only those functions, and be assured that
you can just as easily add to the bindings if need be.
</para>
<indexterm role="cp"><primary>C abstractions</primary></indexterm>
<indexterm role="cp"><primary>abstractions in C</primary></indexterm>
<para>The removal of the C compiler, or C interpretation of any kind,
creates the main disadvantage: some of C&#8217;s &#8220;abstractions&#8221; are not
available, violating information encapsulation.  For example,
<literal>struct</literal>s that must be passed on the stack, or used as return
values, without corresponding functional abstractions to create and
manage the <literal>struct</literal>s, must be declared explicitly in Lisp.  This
is fine for structs whose contents are &#8220;public&#8221;, but is not so
pleasant when a struct is supposed to be &#8220;opaque&#8221; by convention,
even though it is not so defined.<footnote><para>Admittedly, this is an
advanced issue, and we encourage you to leave this text until you are
more familiar with how <acronym>CFFI</acronym> works.</para></footnote>
</para>
<para>Without an abstraction to create the struct, Lisp needs to be able to
lay out the struct in memory, so must know its internal details.
</para>
<indexterm role="cp"><primary>workaround for C</primary></indexterm>
<para>In these cases, you can create a minimal C library to provide the
missing abstractions, without destroying all the advantages of the
Common Lisp approach discussed above.  In the case of <literal>struct</literal>s,
you can write simple, pure C functions that tell you how many bytes a
struct requires or allocate new structs, read and write fields of the
struct, or whatever operations are supposed to be
public.<footnote><para>This does not apply to structs whose contents are
intended to be part of the public library interface.  In those cases,
a pure Lisp struct definition is always preferred.  In fact, many
prefer to stay in Lisp and break the encapsulation anyway, placing the
burden of correct library interface definition on the library.</para></footnote>
<link linkend="The-Groveller">The Groveller</link> automates this and other processes.
</para>
<para>Another disadvantage appears when you would rather use the foreign
language than Lisp.  However, someone who prefers C to Lisp is not a
likely candidate for developing a Lisp interface to a C library.
</para>

</sect1>
<sect1 label="4.2" id="Tutorial_002dGetting-a-URL">
<title>Getting a <acronym>URL</acronym></title>

<indexterm role="cp"><primary>c<acronym>URL</acronym></primary></indexterm>
<para>The widely available <literal>libcurl</literal> is a library for downloading files
over protocols like <acronym>HTTP</acronym>.  We will use <literal>libcurl</literal> with
<acronym>CFFI</acronym> to download a web page.
</para>
<para>Please note that there are many other ways to download files from the
web, not least the CL-CURL project to provide bindings to
<literal>libcurl</literal> via a similar <acronym>FFI</acronym>.<footnote><para>Specifically,
<acronym>UFFI</acronym>, an older <acronym>FFI</acronym> that takes a somewhat different
approach compared to <acronym>CFFI</acronym>.  I believe that these days (December
2005) <acronym>CFFI</acronym> is more portable and actively developed, though not as
mature yet.  Consensus in the free UNIX Common Lisp community
seems to be that <acronym>CFFI</acronym> is preferred for new development, though
<acronym>UFFI</acronym> will likely go on for quite some time as many projects
already use it.  <acronym>CFFI</acronym> includes the <literal>UFFI-COMPAT</literal> package for
complete compatibility with <acronym>UFFI</acronym>.</para></footnote>
</para>
<para><ulink url="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html">libcurl-tutorial(3)</ulink>
is a tutorial for <literal>libcurl</literal> programming in C.  We will follow
that to develop a binding to download a file.  We will also use
<filename>curl.h</filename>, <filename>easy.h</filename>, and the <command>man</command> pages for the
<literal>libcurl</literal> function, all available in the &#8216;<literal>curl-dev</literal>&#8217; package
or equivalent for your system, or in the c<acronym>URL</acronym> source code
package.  If you have the development package, the headers should be
installed in <filename>/usr/include/curl/</filename>, and the <command>man</command> pages
may be accessed through your favorite <command>man</command> facility.
</para>

</sect1>
<sect1 label="4.3" id="Tutorial_002dLoading">
<title>Loading foreign libraries</title>

<indexterm role="cp"><primary>loading <acronym>CFFI</acronym></primary></indexterm>
<indexterm role="cp"><primary>requiring <acronym>CFFI</acronym></primary></indexterm>
<para>First of all, we will create a package to work in.  You can save these
forms in a file, or just send them to the listener as they are.  If
creating bindings for an <acronym>ASDF</acronym> package of yours, you will
want to add <literal>:cffi</literal> to the <literal>:depends-on</literal> list in your
<filename>.asd</filename> file.  Otherwise, just use the <literal>asdf:load-system</literal> function to
load <acronym>CFFI</acronym>.
</para>
<!-- Initialization -->
<programlisting>(asdf:load-system :cffi)

;;; Nothing special about the &quot;CFFI-USER&quot; package.  We're just
;;; using it as a substitute for your own CL package.
(defpackage :cffi-user
  (:use :common-lisp :cffi))

(in-package :cffi-user)

(define-foreign-library libcurl
  (:darwin (:or &quot;libcurl.3.dylib&quot; &quot;libcurl.dylib&quot;))
  (:unix (:or &quot;libcurl.so.3&quot; &quot;libcurl.so&quot;))
  (t (:default &quot;libcurl&quot;)))

(use-foreign-library libcurl)
</programlisting>
<indexterm role="cp"><primary>foreign library load</primary></indexterm>
<indexterm role="cp"><primary>library, foreign</primary></indexterm>
<para>Using <literal>define-foreign-library</literal> and <literal>use-foreign-library</literal>, we
have loaded <literal>libcurl</literal> into Lisp, much as the linker does when you
start a C program, or <literal>common-lisp:load</literal> does with a Lisp source
file or <acronym>FASL</acronym> file.  We special-cased for UNIX machines
to always load a particular version, the one this tutorial was tested
with; for those who don&#8217;t care, the <literal>define-foreign-library</literal>
clause <literal>(t (:default &quot;libcurl&quot;))</literal> should be satisfactory, and
will adapt to various operating systems.
</para>

</sect1>
<sect1 label="4.4" id="Tutorial_002dInitializing">
<title>Initializing <literal>libcurl</literal></title>

<indexterm role="cp"><primary>function definition</primary></indexterm>
<para>After the introductory matter, the tutorial goes on to present the
first function you should use.
</para>
<screen>CURLcode curl_global_init(long flags);
</screen>
<para>Let&#8217;s pick this apart into appropriate Lisp code:
</para>
<!-- First CURLcode -->
<programlisting>;;; A CURLcode is the universal error code.  curl/curl.h says
;;; no return code will ever be removed, and new ones will be
;;; added to the end.
(defctype curl-code :int)

;;; Initialize libcurl with FLAGS.
(defcfun &quot;curl_global_init&quot; curl-code
  (flags :long))
</programlisting>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>By default, CFFI assumes the UNIX viewpoint that there is one
C symbol namespace, containing all symbols in all loaded objects.
This is not so on Windows and Darwin, but we emulate UNIX&#8217;s behaviour
there.  <link linkend="defcfun">defcfun</link> for more details.</emphasis>
</para></blockquote>
<para>Note the parallels with the original C declaration.  We&#8217;ve defined
<literal>curl-code</literal> as a wrapping type for <literal>:int</literal>; right now, it
only marks it as special, but later we will do something more
interesting with it.  The point is that we don&#8217;t have to do it yet.
</para>
<indexterm role="cp"><primary>calling foreign functions</primary></indexterm>
<para>Looking at <filename>curl.h</filename>, <literal>CURL_GLOBAL_NOTHING</literal>, a possible value
for <literal>flags</literal> above, is defined as &#8216;<literal>0</literal>&#8217;.  So we can now call
the function:
</para>
<screen>CFFI-USER&gt; (curl-global-init 0)
&#8658; 0
</screen>
<indexterm role="cp"><primary>looks like it worked</primary></indexterm>
<para>Looking at <filename>curl.h</filename> again, <literal>0</literal> means <literal>CURLE_OK</literal>, so it
looks like the call succeeded.  Note that <acronym>CFFI</acronym> converted the
function name to a Lisp-friendly name.  You can specify your own name
if you want; use <literal>(&quot;curl_global_init&quot; <replaceable>your-name-here</replaceable>)</literal> as
the <replaceable>name</replaceable> argument to <literal>defcfun</literal>.
</para>
<para>The tutorial goes on to have us allocate a handle.  For good measure,
we should also include the deallocator.  Let&#8217;s look at these
functions:
</para>
<screen>CURL *curl_easy_init( );
void curl_easy_cleanup(CURL *handle);
</screen>
<para>Advanced users may want to define special pointer types; we will
explore this possibility later.  For now, just treat every pointer as
the same:
</para>
<!-- curl_easy handles -->
<programlisting>(defcfun &quot;curl_easy_init&quot; :pointer)

(defcfun &quot;curl_easy_cleanup&quot; :void
  (easy-handle :pointer))
</programlisting>
<para>Now we can continue with the tutorial:
</para>
<screen>CFFI-USER&gt; (defparameter *easy-handle* (curl-easy-init))
&#8658; *EASY-HANDLE*
CFFI-USER&gt; *easy-handle*
&#8658; #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
</screen>
<indexterm role="cp"><primary>pointers in Lisp</primary></indexterm>
<para>Note the print representation of a pointer.  It changes depending on
what Lisp you are using, but that doesn&#8217;t make any difference to
<acronym>CFFI</acronym>.
</para>

</sect1>
<sect1 label="4.5" id="Tutorial_002deasy_005fsetopt">
<title>Setting download options</title>

<para>The <literal>libcurl</literal> tutorial says we&#8217;ll want to set many options before
performing any download actions.  This is done through
<literal>curl_easy_setopt</literal>:
</para>
<!-- That is literally ..., not an ellipsis. -->
<screen>CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
</screen>
<indexterm role="cp"><primary>varargs</primary></indexterm>
<indexterm role="cp"><primary>foreign arguments</primary></indexterm>
<para>We&#8217;ve introduced a new twist: variable arguments.  There is no obvious
translation to the <literal>defcfun</literal> form, particularly as there are four
possible argument types.  Because of the way C works, we could define
four wrappers around <literal>curl_easy_setopt</literal>, one for each type; in
this case, however, we&#8217;ll use the general-purpose macro
<literal>foreign-funcall</literal> to call this function.
</para>
<indexterm role="cp"><primary>enumeration, C</primary></indexterm>
<para>To make things easier on ourselves, we&#8217;ll create an enumeration of the
kinds of options we want to set.  The <literal>enum CURLoption</literal> isn&#8217;t the
most straightforward, but reading the <literal>CINIT</literal> C macro definition
should be enlightening.
</para>
<!-- CURLoption enumeration -->
<programlisting>(defmacro define-curl-options (name type-offsets &amp;rest enum-args)
  &quot;As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:

    (NAME TYPE NUMBER)

Where the arguments are as they are with the CINIT macro defined
in curl.h, except NAME is a keyword.

TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
defined by the CURLOPTTYPE_LONG et al constants in curl.h.&quot;
  (flet ((enumerated-value (type offset)
           (+ (getf type-offsets type) offset)))
    `(progn
       (defcenum ,name
         ,@(loop for (name type number) in enum-args
              collect (list name (enumerated-value type number))))
       ',name)))                ;for REPL users' sanity

(define-curl-options curl-option
    (long 0 objectpoint 10000 functionpoint 20000 off-t 30000)
  (:noprogress long 43)
  (:nosignal long 99)
  (:errorbuffer objectpoint 10)
  (:url objectpoint 2))
</programlisting>
<para>With some well-placed Emacs <literal>query-replace-regexp</literal>s, you could
probably similarly define the entire <literal>CURLoption</literal> enumeration.  I
have selected to transcribe a few that we will use in this tutorial.
</para>
<para>If you&#8217;re having trouble following the macrology, just macroexpand the
<literal>curl-option</literal> definition, or see the following macroexpansion,
conveniently downcased and reformatted:
</para>
<!-- DEFINE-CURL-OPTIONS macroexpansion -->
<programlisting>(progn
  (defcenum curl-option
    (:noprogress 43)
    (:nosignal 99)
    (:errorbuffer 10010)
    (:url 10002))
  'curl-option)
</programlisting>
<para>That seems more than reasonable.  You may notice that we only use the
<replaceable>type</replaceable> to compute the real enumeration offset; we will also need
the type information later.
</para>
<para>First, however, let&#8217;s make sure a simple call to the foreign function
works:
</para>
<screen>CFFI-USER&gt; (foreign-funcall &quot;curl_easy_setopt&quot;
               :pointer *easy-handle*
               curl-option :nosignal :long 1 curl-code)
&#8658; 0
</screen>
<para><literal>foreign-funcall</literal>, despite its surface simplicity, can be used to
call any C function.  Its first argument is a string, naming the
function to be called.  Next, for each argument, we pass the name of
the C type, which is the same as in <literal>defcfun</literal>, followed by a Lisp
object representing the data to be passed as the argument.  The final
argument is the return type, for which we use the <literal>curl-code</literal>
type defined earlier.
</para>
<para><literal>defcfun</literal> just puts a convenient fa&#231;ade on
<literal>foreign-funcall</literal>.<footnote><para>This isn&#8217;t entirely true; some Lisps
don&#8217;t support <literal>foreign-funcall</literal>, so <literal>defcfun</literal> is implemented
without it.  <literal>defcfun</literal> may also perform optimizations that
<literal>foreign-funcall</literal> cannot.</para></footnote>  Our earlier call to
<literal>curl-global-init</literal> could have been written as follows:
</para>
<screen>CFFI-USER&gt; (foreign-funcall &quot;curl_global_init&quot; :long 0
                            curl-code)
&#8658; 0
</screen>
<para>Before we continue, we will take a look at what <acronym>CFFI</acronym> can and can&#8217;t
do, and why this is so.
</para>

</sect1>
<sect1 label="4.6" id="Tutorial_002dAbstraction">
<title>Breaking the abstraction</title>

<indexterm role="cp"><primary>breaking the abstraction</primary></indexterm>
<indexterm role="cp"><primary>abstraction breaking</primary></indexterm>
<para>In <link linkend="Tutorial_002dComparison">What makes Lisp different</link>, we mentioned
that writing an <acronym>FFI</acronym> sometimes requires depending on
information not provided as part of the interface.  The easy option
<literal>CURLOPT_WRITEDATA</literal>, which we will not provide as part of the
Lisp interface, illustrates this issue.
</para>
<para>Strictly speaking, the <literal>curl-option</literal> enumeration is not
necessary; we could have used <literal>:int 99</literal> instead of
<literal>curl-option :nosignal</literal> in our call to <literal>curl_easy_setopt</literal>
above.  We defined it anyway, in part to hide the fact that we are
breaking the abstraction that the C <literal>enum</literal> provides.  If the
c<acronym>URL</acronym> developers decide to change those numbers later, we
must change the Lisp enumeration, because enumeration values are not
provided in the compiled C library, <literal>libcurl.so.3</literal>.
</para>
<para><acronym>CFFI</acronym> works because the most useful things in C libraries &#8212;
non-static functions and non-static variables &#8212; are included
accessibly in <literal>libcurl.so.3</literal>.  A C compiler that violated this
would be considered a worthless compiler.
</para>
<para>The other thing <literal>define-curl-options</literal> does is give the &#8220;type&#8221;
of the third argument passed to <literal>curl_easy_setopt</literal>.  Using this
information, we can tell that the <literal>:nosignal</literal> option should
accept a long integer argument.  We can implicitly assume <literal>t</literal>
&#8801; 1 and <literal>nil</literal> &#8801; 0, as it is in C, which takes care
of the fact that <literal>CURLOPT_NOSIGNAL</literal> is really asking for a
boolean.
</para>
<para>The &#8220;type&#8221; of <literal>CURLOPT_WRITEDATA</literal> is <literal>objectpoint</literal>.
However, it is really looking for a <literal>FILE*</literal>.
<literal>CURLOPT_ERRORBUFFER</literal> is looking for a <literal>char*</literal>, so there is
no obvious <acronym>CFFI</acronym> type but <literal>:pointer</literal>.
</para>
<para>The first thing to note is that nowhere in the C interface includes
this information; it can only be found in the manual.  We could
disjoin these clearly different types ourselves, by splitting
<literal>objectpoint</literal> into <literal>filepoint</literal> and <literal>charpoint</literal>, but we
are still breaking the abstraction, because we have to augment the
entire enumeration form with this additional
information.<footnote><para>Another possibility is to allow the caller to
specify the desired C type of the third argument.  This is essentially
what happens in a call to the function written in C.</para></footnote>
</para>
<indexterm role="cp"><primary>streams and C</primary></indexterm>
<indexterm role="cp"><primary>FILE* and streams</primary></indexterm>
<para>The second is that the <literal>CURLOPT_WRITEDATA</literal> argument is completely
incompatible with the desired Lisp data, a
stream.<footnote><para>See section &#8220;Other Kinds of Streams&#8221; in <citetitle>GNU C Library
Reference</citetitle>, for a <acronym>GNU</acronym>-only way to extend the <literal>FILE*</literal>
type.  You could use this to convert Lisp streams to the needed C
data.  This would be quite involved and far outside the scope of this
tutorial.</para></footnote>  It is probably acceptable if we are controlling every file
we might want to use as this argument, in which case we can just call
the foreign function <literal>fopen</literal>.  Regardless, though, we can&#8217;t write
to arbitrary streams, which is exactly what we want to do for this
application.
</para>
<para>Finally, note that the <literal>curl_easy_setopt</literal> interface itself is a
hack, intended to work around some of the drawbacks of C.  The
definition of <literal>Curl_setopt</literal>, while long, is far less cluttered
than the equivalent disjoint-function set would be; in addition,
setting a new option in an old <literal>libcurl</literal> can generate a run-time
error rather than breaking the compile.  Lisp can just as concisely
generate functions as compare values, and the &#8220;undefined function&#8221;
error is just as useful as any explicit error we could define here
might be.
</para>

</sect1>
<sect1 label="4.7" id="Tutorial_002dLisp-easy_005fsetopt">
<title>Option functions in Lisp</title>

<para>We could use <literal>foreign-funcall</literal> directly every time we wanted to
call <literal>curl_easy_setopt</literal>.  However, we can encapsulate some of the
necessary information with the following.
</para>
<programlisting>;;; We will use this type later in a more creative way.  For
;;; now, just consider it a marker that this isn't just any
;;; pointer.
(defctype easy-handle :pointer)

(defmacro curl-easy-setopt (easy-handle enumerated-name
                            value-type new-value)
  &quot;Call `curl_easy_setopt' on EASY-HANDLE, using ENUMERATED-NAME
as the OPTION.  VALUE-TYPE is the CFFI foreign type of the third
argument, and NEW-VALUE is the Lisp data to be translated to the
third argument.  VALUE-TYPE is not evaluated.&quot;
  `(foreign-funcall &quot;curl_easy_setopt&quot; easy-handle ,easy-handle
                    curl-option ,enumerated-name
                    ,value-type ,new-value curl-code))
</programlisting>
<para>Now we define a function for each kind of argument that encodes the
correct <literal>value-type</literal> in the above.  This can be done reasonably
in the <literal>define-curl-options</literal> macroexpansion; after all, that is
where the different options are listed!
</para>
<indexterm role="cp"><primary>Lispy C functions</primary></indexterm>
<para>We could make <literal>cl:defun</literal> forms in the expansion that simply call
<literal>curl-easy-setopt</literal>; however, it is probably easier and clearer to
use <literal>defcfun</literal>.  <literal>define-curl-options</literal> was becoming unwieldy,
so I defined some helpers in this new definition.
</para>
<programlisting>(defun curry-curl-option-setter (function-name option-keyword)
  &quot;Wrap the function named by FUNCTION-NAME with a version that
curries the second argument as OPTION-KEYWORD.

This function is intended for use in DEFINE-CURL-OPTION-SETTER.&quot;
  (setf (symbol-function function-name)
          (let ((c-function (symbol-function function-name)))
            (lambda (easy-handle new-value)
              (funcall c-function easy-handle option-keyword
                       new-value)))))

(defmacro define-curl-option-setter (name option-type
                                     option-value foreign-type)
  &quot;Define (with DEFCFUN) a function NAME that calls
curl_easy_setopt.  OPTION-TYPE and OPTION-VALUE are the CFFI
foreign type and value to be passed as the second argument to
easy_setopt, and FOREIGN-TYPE is the CFFI foreign type to be used
for the resultant function's third argument.

This macro is intended for use in DEFINE-CURL-OPTIONS.&quot;
  `(progn
     (defcfun (&quot;curl_easy_setopt&quot; ,name) curl-code
       (easy-handle easy-handle)
       (option ,option-type)
       (new-value ,foreign-type))
     (curry-curl-option-setter ',name ',option-value)))

(defmacro define-curl-options (type-name type-offsets &amp;rest enum-args)
  &quot;As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:

    (NAME TYPE NUMBER)

Where the arguments are as they are with the CINIT macro defined
in curl.h, except NAME is a keyword.

TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
defined by the CURLOPTTYPE_LONG et al constants in curl.h.

Also, define functions for each option named
set-`TYPE-NAME'-`OPTION-NAME', where OPTION-NAME is the NAME from
the above destructuring.&quot;
  (flet ((enumerated-value (type offset)
           (+ (getf type-offsets type) offset))
         ;; map PROCEDURE, destructuring each of ENUM-ARGS
         (map-enum-args (procedure)
           (mapcar (lambda (arg) (apply procedure arg)) enum-args))
         ;; build a name like SET-CURL-OPTION-NOSIGNAL
         (make-setter-name (option-name)
           (intern (concatenate
                    'string &quot;SET-&quot; (symbol-name type-name)
                    &quot;-&quot; (symbol-name option-name)))))
    `(progn
       (defcenum ,type-name
         ,@(map-enum-args
            (lambda (name type number)
              (list name (enumerated-value type number)))))
       ,@(map-enum-args
          (lambda (name type number)
            (declare (ignore number))
            `(define-curl-option-setter ,(make-setter-name name)
               ,type-name ,name ,(ecase type
                                   (long :long)
                                   (objectpoint :pointer)
                                   (functionpoint :pointer)
                                   (off-t :long)))))
       ',type-name)))
</programlisting>
<para>Macroexpanding our <literal>define-curl-options</literal> form once more, we
see something different:
</para>
<programlisting>(progn
  (defcenum curl-option
    (:noprogress 43)
    (:nosignal 99)
    (:errorbuffer 10010)
    (:url 10002))
  (define-curl-option-setter set-curl-option-noprogress
    curl-option :noprogress :long)
  (define-curl-option-setter set-curl-option-nosignal
    curl-option :nosignal :long)
  (define-curl-option-setter set-curl-option-errorbuffer
    curl-option :errorbuffer :pointer)
  (define-curl-option-setter set-curl-option-url
    curl-option :url :pointer)
  'curl-option)
</programlisting>
<para>Macroexpanding one of the new <literal>define-curl-option-setter</literal>
forms yields the following:
</para>
<programlisting>(progn
  (defcfun (&quot;curl_easy_setopt&quot; set-curl-option-nosignal) curl-code
    (easy-handle easy-handle)
    (option curl-option)
    (new-value :long))
  (curry-curl-option-setter 'set-curl-option-nosignal ':nosignal))
</programlisting>
<para>Finally, let&#8217;s try this out:
</para>
<screen>CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
&#8658; 0
</screen>
<para>Looks like it works just as well.  This interface is now reasonably
high-level to wash out some of the ugliness of the thinnest possible
<literal>curl_easy_setopt</literal> <acronym>FFI</acronym>, without obscuring the remaining
C bookkeeping details we will explore.
</para>

</sect1>
<sect1 label="4.8" id="Tutorial_002dMemory">
<title>Memory management</title>

<para>According to the documentation for <literal>curl_easy_setopt</literal>, the type
of the third argument when <replaceable>option</replaceable> is <literal>CURLOPT_ERRORBUFFER</literal>
is <literal>char*</literal>.  Above, we&#8217;ve defined
<literal>set-curl-option-errorbuffer</literal> to accept a <literal>:pointer</literal> as the
new option value.  However, there is a <acronym>CFFI</acronym> type <literal>:string</literal>,
which translates Lisp strings to C strings when passed as arguments to
foreign function calls.  Why not, then, use <literal>:string</literal> as the
<acronym>CFFI</acronym> type of the third argument?  There are two reasons, both
related to the necessity of breaking abstraction described in
<link linkend="Tutorial_002dAbstraction">Breaking the abstraction</link>.
</para>
<para>The first reason also applies to <literal>CURLOPT_URL</literal>, which we will use
to illustrate the point.  Assuming we have changed the type of the
third argument underlying <literal>set-curl-option-url</literal> to
<literal>:string</literal>, look at these two equivalent forms.
</para>
<programlisting>(set-curl-option-url *easy-handle* &quot;http://www.cliki.net/CFFI&quot;)

&#8801; (with-foreign-string (url &quot;http://www.cliki.net/CFFI&quot;)
     (foreign-funcall &quot;curl_easy_setopt&quot; easy-handle *easy-handle*
                      curl-option :url :pointer url curl-code))
</programlisting>
<para>The latter, in fact, is mostly equivalent to what a foreign function
call&#8217;s macroexpansion actually does.  As you can see, the Lisp string
<literal>&quot;http://www.cliki.net/CFFI&quot;</literal> is copied into a <literal>char</literal> array and
null-terminated; the pointer to beginning of this array, now a C
string, is passed as a <acronym>CFFI</acronym> <literal>:pointer</literal> to the foreign
function.
</para>
<indexterm role="cp"><primary>dynamic extent</primary></indexterm>
<indexterm role="cp"><primary>foreign values with dynamic extent</primary></indexterm>
<para>Unfortunately, the C abstraction has failed us, and we must break it.
While <literal>:string</literal> works well for many <literal>char*</literal> arguments, it
does not for cases like this.  As the <literal>curl_easy_setopt</literal>
documentation explains, &#8220;The string must remain present until curl no
longer needs it, as it doesn&#8217;t copy the string.&#8221;  The C string
created by <literal>with-foreign-string</literal>, however, only has dynamic
extent: it is &#8220;deallocated&#8221; when the body (above containing the
<literal>foreign-funcall</literal> form) exits.
</para>
<indexterm role="cp"><primary>premature deallocation</primary></indexterm>
<para>If we are supposed to keep the C string around, but it goes away, what
happens when some <literal>libcurl</literal> function tries to access the
<acronym>URL</acronym> string?  We have reentered the dreaded world of C
&#8220;undefined behavior&#8221;.  In some Lisps, it will probably get a chunk
of the Lisp/C stack.  You may segfault.  You may get some random piece
of other data from the heap.  Maybe, in a world where &#8220;dynamic
extent&#8221; is defined to be &#8220;infinite extent&#8221;, everything will turn
out fine.  Regardless, results are likely to be almost universally
unpleasant.<footnote><para>&#8220;<emphasis>But I thought Lisp was supposed to protect
me from all that buggy C crap!</emphasis>&#8221;  Before asking a question like that,
remember that you are a stranger in a foreign land, whose residents
have a completely different set of values.</para></footnote>
</para>
<para>Returning to the current <literal>set-curl-option-url</literal> interface, here is
what we must do:
</para>
<programlisting>(let (easy-handle)
  (unwind-protect
    (with-foreign-string (url &quot;http://www.cliki.net/CFFI&quot;)
      (setf easy-handle (curl-easy-init))
      (set-curl-option-url easy-handle url)
      #|do more with the easy-handle, like actually get the URL|#)
    (when easy-handle
      (curl-easy-cleanup easy-handle))))
</programlisting>
<!-- old comment to luis: I go on to say that this isn't obviously -->
<!-- extensible to new option settings that require C strings to stick -->
<!-- around, as it would involve re-evaluating the unwind-protect form -->
<!-- with more dynamic memory allocation.  So I plan to show how to -->
<!-- write something similar to ObjC's NSAutoreleasePool, to be managed -->
<!-- with a simple unwind-protect form. -->

<para>That is fine for the single string defined here, but for every string
option we want to pass, we have to surround the body of
<literal>with-foreign-string</literal> with another <literal>with-foreign-string</literal>
wrapper, or else do some extremely error-prone pointer manipulation
and size calculation in advance.  We could alleviate some of the pain
with a recursively expanding macro, but this would not remove the need
to modify the block every time we want to add an option, anathema as
it is to a modular interface.
</para>
<para>Before modifying the code to account for this case, consider the other
reason we can&#8217;t simply use <literal>:string</literal> as the foreign type.  In C,
a <literal>char *</literal> is a <literal>char *</literal>, not necessarily a string.  The
option <literal>CURLOPT_ERRORBUFFER</literal> accepts a <literal>char *</literal>, but does
not expect anything about the data there.  However, it does expect
that some <literal>libcurl</literal> function we call later can write a C string
of up to 255 characters there.  We, the callers of the function, are
expected to read the C string at a later time, exactly the opposite of
what <literal>:string</literal> implies.
</para>
<para>With the semantics for an input string in mind &#8212; namely, that the
string should be kept around until we <literal>curl_easy_cleanup</literal> the
easy handle &#8212; we are ready to extend the Lisp interface:
</para>
<programlisting>(defvar *easy-handle-cstrings* (make-hash-table)
  &quot;Hashtable of easy handles to lists of C strings that may be
safely freed after the handle is freed.&quot;)

(defun make-easy-handle ()
  &quot;Answer a new CURL easy interface handle, to which the lifetime
of C strings may be tied.  See `add-curl-handle-cstring'.&quot;
  (let ((easy-handle (curl-easy-init)))
    (setf (gethash easy-handle *easy-handle-cstrings*) '())
    easy-handle))

(defun free-easy-handle (handle)
  &quot;Free CURL easy interface HANDLE and any C strings created to
be its options.&quot;
  (curl-easy-cleanup handle)
  (mapc #'foreign-string-free
        (gethash handle *easy-handle-cstrings*))
  (remhash handle *easy-handle-cstrings*))

(defun add-curl-handle-cstring (handle cstring)
  &quot;Add CSTRING to be freed when HANDLE is, answering CSTRING.&quot;
  (car (push cstring (gethash handle *easy-handle-cstrings*))))
</programlisting>
<para>Here we have redefined the interface to create and free handles, to
associate a list of allocated C strings with each handle while it
exists.  The strategy of using different function names to wrap around
simple foreign functions is more common than the solution implemented
earlier with <literal>curry-curl-option-setter</literal>, which was to modify the
function name&#8217;s function slot.<footnote><para>There are advantages and
disadvantages to each approach; I chose to <literal>(setf
symbol-function)</literal> earlier because it entailed generating fewer magic
function names.</para></footnote>
</para>
<para>Incidentally, the next step is to redefine
<literal>curry-curl-option-setter</literal> to allocate C strings for the
appropriate length of time, given a Lisp string as the
<literal>new-value</literal> argument:
</para>
<programlisting>(defun curry-curl-option-setter (function-name option-keyword)
  &quot;Wrap the function named by FUNCTION-NAME with a version that
curries the second argument as OPTION-KEYWORD.

This function is intended for use in DEFINE-CURL-OPTION-SETTER.&quot;
  (setf (symbol-function function-name)
          (let ((c-function (symbol-function function-name)))
            (lambda (easy-handle new-value)
              (funcall c-function easy-handle option-keyword
                       (if (stringp new-value)
                         (add-curl-handle-cstring
                          easy-handle
                          (foreign-string-alloc new-value))
                         new-value))))))
</programlisting>
<para>A quick analysis of the code shows that you need only reevaluate the
<literal>curl-option</literal> enumeration definition to take advantage of these
new semantics.  Now, for good measure, let&#8217;s reallocate the handle
with the new functions we just defined, and set its <acronym>URL</acronym>:
</para>
<screen>CFFI-USER&gt; (curl-easy-cleanup *easy-handle*)
&#8658; NIL
CFFI-USER&gt; (setf *easy-handle* (make-easy-handle))
&#8658; #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
&#8658; 0
CFFI-USER&gt; (set-curl-option-url *easy-handle*
                                &quot;http://www.cliki.net/CFFI&quot;)
&#8658; 0
</screen>
<indexterm role="cp"><primary>strings</primary></indexterm>
<para>For fun, let&#8217;s inspect the Lisp value of the C string that was created
to hold <literal>&quot;http://www.cliki.net/CFFI&quot;</literal>.  By virtue of the implementation of
<literal>add-curl-handle-cstring</literal>, it should be accessible through the
hash table defined:
</para>
<screen>CFFI-USER&gt; (foreign-string-to-lisp
            (car (gethash *easy-handle* *easy-handle-cstrings*)))
&#8658; &quot;http://www.cliki.net/CFFI&quot;
</screen>
<para>Looks like that worked, and <literal>libcurl</literal> now knows what
<acronym>URL</acronym> we want to retrieve.
</para>
<para>Finally, we turn back to the <literal>:errorbuffer</literal> option mentioned at
the beginning of this section.  Whereas the abstraction added to
support string inputs works fine for cases like <literal>CURLOPT_URL</literal>, it
hides the detail of keeping the C string; for <literal>:errorbuffer</literal>,
however, we need that C string.
</para>
<para>In a moment, we&#8217;ll define something slightly cleaner, but for now,
remember that you can always hack around anything.  We&#8217;re modifying
handle creation, so make sure you free the old handle before
redefining <literal>free-easy-handle</literal>.
</para>
<programlisting>(defvar *easy-handle-errorbuffers* (make-hash-table)
  &quot;Hashtable of easy handles to C strings serving as error
writeback buffers.&quot;)

;;; An extra byte is very little to pay for peace of mind.
(defparameter *curl-error-size* 257
  &quot;Minimum char[] size used by cURL to report errors.&quot;)

(defun make-easy-handle ()
  &quot;Answer a new CURL easy interface handle, to which the lifetime
of C strings may be tied.  See `add-curl-handle-cstring'.&quot;
  (let ((easy-handle (curl-easy-init)))
    (setf (gethash easy-handle *easy-handle-cstrings*) '())
    (setf (gethash easy-handle *easy-handle-errorbuffers*)
            (foreign-alloc :char :count *curl-error-size*
                           :initial-element 0))
    easy-handle))

(defun free-easy-handle (handle)
  &quot;Free CURL easy interface HANDLE and any C strings created to
be its options.&quot;
  (curl-easy-cleanup handle)
  (foreign-free (gethash handle *easy-handle-errorbuffers*))
  (remhash handle *easy-handle-errorbuffers*)
  (mapc #'foreign-string-free
        (gethash handle *easy-handle-cstrings*))
  (remhash handle *easy-handle-cstrings*))

(defun get-easy-handle-error (handle)
  &quot;Answer a string containing HANDLE's current error message.&quot;
  (foreign-string-to-lisp
   (gethash handle *easy-handle-errorbuffers*)))
</programlisting>
<para>Be sure to once again set the options we&#8217;ve set thus far.  You may
wish to define yet another wrapper function to do this.
</para>

</sect1>
<sect1 label="4.9" id="Tutorial_002dCallbacks">
<title>Calling Lisp from C</title>

<para>If you have been reading
<ulink url="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html"><literal>curl_easy_setopt(3)</literal></ulink>, you should have noticed that some options
accept a function pointer.  In particular, we need one function
pointer to set as <literal>CURLOPT_WRITEFUNCTION</literal>, to be called by
<literal>libcurl</literal> rather than the reverse, in order to receive data as it
is downloaded.
</para>
<para>A binding writer without the aid of <acronym>FFI</acronym> usually approaches
this problem by writing a C function that accepts C data, converts to
the language&#8217;s internal objects, and calls the callback provided by
the user, again in a reverse of usual practices.
</para>
<para>The <acronym>CFFI</acronym> approach to callbacks precisely mirrors its differences
with the non-<acronym>FFI</acronym> approach on the &#8220;calling C from Lisp&#8221;
side, which we have dealt with exclusively up to now.  That is, you
define a callback function in Lisp using <literal>defcallback</literal>, and
<acronym>CFFI</acronym> effectively creates a C function to be passed as a function
pointer.
</para>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>This is much trickier than calling C functions from Lisp, as
it literally involves somehow generating a new C function that is as
good as any created by the compiler.  Therefore, not all Lisps support
them.  See <link linkend="Implementation-Support">Implementation Support</link>, for information about <acronym>CFFI</acronym>
support issues in this and other areas.  You may want to consider
changing to a Lisp that supports callbacks in order to continue with
this tutorial.</emphasis>
</para></blockquote>
<indexterm role="cp"><primary>callback definition</primary></indexterm>
<indexterm role="cp"><primary>defining callbacks</primary></indexterm>
<para>Defining a callback is very similar to defining a callout; the main
difference is that we must provide some Lisp forms to be evaluated as
part of the callback.  Here is the signature for the function the
<literal>:writefunction</literal> option takes:
</para>
<screen>size_t
<replaceable>function</replaceable>(void *ptr, size_t size, size_t nmemb, void *stream);
</screen>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>size_t is almost always an unsigned int.  You can get this
and many other types using feature tests for your system by using
cffi-grovel.</emphasis>
</para></blockquote>
<para>The above signature trivially translates into a <acronym>CFFI</acronym>
<literal>defcallback</literal> form, as follows.
</para>
<programlisting>;;; Alias in case size_t changes.
(defctype size :unsigned-int)

;;; To be set as the CURLOPT_WRITEFUNCTION of every easy handle.
(defcallback easy-write size ((ptr :pointer) (size size)
                              (nmemb size) (stream :pointer))
  (let ((data-size (* size nmemb)))
    (handler-case
      ;; We use the dynamically-bound *easy-write-procedure* to
      ;; call a closure with useful lexical context.
      (progn (funcall (symbol-value '*easy-write-procedure*)
                      (foreign-string-to-lisp ptr :count data-size))
             data-size)         ;indicates success
      ;; The WRITEFUNCTION should return something other than the
      ;; #bytes available to signal an error.
      (error () (if (zerop data-size) 1 0)))))
</programlisting>
<para>First, note the correlation of the first few forms, used to declare
the C function&#8217;s signature, with the signature in C syntax.  We
provide a Lisp name for the function, its return type, and a name and
type for each argument.
</para>
<para>In the body, we call the dynamically-bound
<literal>*easy-write-procedure*</literal> with a &#8220;finished&#8221; translation, of
pulling together the raw data and size into a Lisp string, rather than
deal with the data directly.  As part of calling
<literal>curl_easy_perform</literal> later, we&#8217;ll bind that variable to a closure
with more useful lexical bindings than the top-level
<literal>defcallback</literal> form.
</para>
<para>Finally, we make a halfhearted effort to prevent non-local exits from
unwinding the C stack, covering the most likely case with an
<literal>error</literal> handler, which is usually triggered
unexpectedly.<footnote><para>Unfortunately, we can&#8217;t protect against
<emphasis>all</emphasis> non-local exits, such as <literal>return</literal>s and <literal>throw</literal>s,
because <literal>unwind-protect</literal> cannot be used to &#8220;short-circuit&#8221; a
non-local exit in Common Lisp, due to proposal <literal>minimal</literal> in
<ulink url="http://www.lisp.org/HyperSpec/Issues/iss152-writeup.html"><acronym>ANSI</acronym> issue EXIT-EXTENT</ulink>.  Furthermore, binding an
<literal>error</literal> handler prevents higher-up code from invoking restarts
that may be provided under the callback&#8217;s dynamic context.  Such is
the way of compromise.</para></footnote>  The reason is that most C code is written to
understand its own idiosyncratic error condition, implemented above in
the case of <literal>curl_easy_perform</literal>, and more &#8220;undefined behavior&#8221;
can result if we just wipe C stack frames without allowing them to
execute whatever cleanup actions as they like.
</para>
<para>Using the <literal>CURLoption</literal> enumeration in <filename>curl.h</filename> once more, we
can describe the new option by modifying and reevaluating
<literal>define-curl-options</literal>.
</para>
<programlisting>(define-curl-options curl-option
    (long 0 objectpoint 10000 functionpoint 20000 off-t 30000)
  (:noprogress long 43)
  (:nosignal long 99)
  (:errorbuffer objectpoint 10)
  (:url objectpoint 2)
  (:writefunction functionpoint 11)) ;new item here
</programlisting>
<para>Finally, we can use the defined callback and the new
<literal>set-curl-option-writefunction</literal> to finish configuring the easy
handle, using the <literal>callback</literal> macro to retrieve a <acronym>CFFI</acronym>
<literal>:pointer</literal>, which works like a function pointer in C code.
</para>
<screen>CFFI-USER&gt; (set-curl-option-writefunction
            *easy-handle* (callback easy-write))
&#8658; 0
</screen>

</sect1>
<sect1 label="4.10" id="Tutorial_002dCompletion">
<title>A complete <acronym>FFI</acronym>?</title>

<!-- TeX goes insane on @uref{@clikicffi{}} -->

<para>With all options finally set and a medium-level interface developed,
we can finish the definition and retrieve
<ulink url="http://www.cliki.net/CFFI">http://www.cliki.net/CFFI</ulink>, as is done in the tutorial.
</para>
<programlisting>(defcfun &quot;curl_easy_perform&quot; curl-code
  (handle easy-handle))
</programlisting>
<screen>CFFI-USER&gt; (with-output-to-string (contents)
             (let ((*easy-write-procedure*
                     (lambda (string)
                       (write-string string contents))))
               (declare (special *easy-write-procedure*))
               (curl-easy-perform *easy-handle*)))
&#8658; &quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01//EN\&quot;
...
Now fear, comprehensively&lt;/P&gt;
&quot;
</screen>
<para>Of course, that itself is slightly unwieldy, so you may want to define
a function around it that simply retrieves a <acronym>URL</acronym>.  I will
leave synthesis of all the relevant <acronym>REPL</acronym> forms presented
thus far into a single function as an exercise for the reader.
</para>
<para>The remaining sections of this tutorial explore some advanced features
of <acronym>CFFI</acronym>; the definition of new types will receive special
attention.  Some of these features are essential for particular
foreign function calls; some are very helpful when trying to develop a
Lispy interface to C.
</para>

</sect1>
<sect1 label="4.11" id="Tutorial_002dTypes">
<title>Defining new types</title>

<para>We&#8217;ve occasionally used the <literal>defctype</literal> macro in previous sections
as a kind of documentation, much what you&#8217;d use <literal>typedef</literal> for in
C.  We also tried one special kind of type definition, the
<literal>defcenum</literal> type.  See <link linkend="defcstruct">defcstruct</link>, for a definition macro that
may come in handy if you need to use C <literal>struct</literal>s as data.
</para>
<indexterm role="cp"><primary>type definition</primary></indexterm>
<indexterm role="cp"><primary>data in Lisp and C</primary></indexterm>
<indexterm role="cp"><primary>translating types</primary></indexterm>
<para>However, all of these are mostly sugar for the powerful underlying
foreign type interface called <firstterm>type translators</firstterm>.  You can easily
define new translators for any simple named foreign type.  Since we&#8217;ve
defined the new type <literal>curl-code</literal> to use as the return type for
various <literal>libcurl</literal> functions, we can use that to directly convert
c<acronym>URL</acronym> errors to Lisp errors.
</para>
<para><literal>defctype</literal>&#8217;s purpose is to define simple <literal>typedef</literal>-like
aliases.  In order to use <firstterm>type translators</firstterm> we must use the
<literal>define-foreign-type</literal> macro.  So let&#8217;s redefine <literal>curl-code</literal>
using it.
</para>
<programlisting>(define-foreign-type curl-code-type ()
  ()
  (:actual-type :int)
  (:simple-parser curl-code))
</programlisting>
<para><literal>define-foreign-type</literal> is a thin wrapper around <literal>defclass</literal>.
For now, all you need to know in the context of this example is that
it does what <literal>(defctype curl-code :int)</literal> would do and,
additionally, defines a new class <literal>curl-code-type</literal> which we will
take advantage of shortly.
</para>
<para>The <literal>CURLcode</literal> enumeration seems to follow the typical error code
convention of &#8216;<literal>0</literal>&#8217; meaning all is well, and each non-zero integer
indicating a different kind of error.  We can apply that trivially to
differentiate between normal exits and error exits.
</para>
<programlisting>(define-condition curl-code-error (error)
  (($code :initarg :curl-code :reader curl-error-code))
  (:report (lambda (c stream)
             (format stream &quot;libcurl function returned error ~A&quot;
                            (curl-error-code c))))
  (:documentation &quot;Signalled when a libcurl function answers
a code other than CURLE_OK.&quot;))

(defmethod translate-from-foreign (value (type curl-code-type))
  &quot;Raise a CURL-CODE-ERROR if VALUE, a curl-code, is non-zero.&quot;
  (if (zerop value)
      :curle-ok
      (error 'curl-code-error :curl-code value)))
</programlisting>
<para>The heart of this translator is new method
<literal>translate-from-foreign</literal>.  By specializing the <replaceable>type</replaceable>
parameter on <literal>curl-code-type</literal>, we immediately modify the behavior
of every function that returns a <literal>curl-code</literal> to pass the result
through this new method.
</para>
<para>To see the translator in action, try invoking a function that returns
a <literal>curl-code</literal>.  You need to reevaluate the respective
<literal>defcfun</literal> form so that it picks up the new <literal>curl-code</literal>
definition.
</para>
<screen>CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
&#8658; :CURLE-OK
</screen>
<para>As the result was &#8216;<literal>0</literal>&#8217;, the new method returned <literal>:curle-ok</literal>,
just as specified.<footnote><para>It might be better to return
<literal>(values)</literal> than <literal>:curle-ok</literal> in real code, but this is good
for illustration.</para></footnote>  I will leave disjoining the separate
<literal>CURLcode</literal>s into condition types and improving the <literal>:report</literal>
function as an exercise for you.
</para>
<para>The creation of <literal>*easy-handle-cstrings*</literal> and
<literal>*easy-handle-errorbuffers*</literal> as properties of <literal>easy-handle</literal>s
is a kluge.  What we really want is a Lisp structure that stores these
properties along with the C pointer.  Unfortunately,
<literal>easy-handle</literal> is currently just a fancy name for the foreign type
<literal>:pointer</literal>; the actual pointer object varies from Common Lisp
implementation to implementation, needing only to satisfy
<literal>pointerp</literal> and be returned from <literal>make-pointer</literal> and friends.
</para>
<para>One solution that would allow us to define a new Lisp structure to
represent <literal>easy-handle</literal>s would be to write a wrapper around every
function that currently takes an <literal>easy-handle</literal>; the wrapper would
extract the pointer and pass it to the foreign function.  However, we
can use type translators to more elegantly integrate this
&#8220;translation&#8221; into the foreign function calling framework, using
<literal>translate-to-foreign</literal>.
</para>
<programlisting>(defclass easy-handle ()
  ((pointer :initform (curl-easy-init)
            :documentation &quot;Foreign pointer from curl_easy_init&quot;)
   (error-buffer
    :initform (foreign-alloc :char :count *curl-error-size*
                             :initial-element 0)
    :documentation &quot;C string describing last error&quot;)
   (c-strings :initform '()
              :documentation &quot;C strings set as options&quot;))
  (:documentation &quot;I am a parameterization you may pass to
curl-easy-perform to perform a cURL network protocol request.&quot;))

(defmethod initialize-instance :after ((self easy-handle) &amp;key)
  (set-curl-option-errorbuffer self (slot-value self 'error-buffer)))

(defun add-curl-handle-cstring (handle cstring)
  &quot;Add CSTRING to be freed when HANDLE is, answering CSTRING.&quot;
  (car (push cstring (slot-value handle 'c-strings))))

(defun get-easy-handle-error (handle)
  &quot;Answer a string containing HANDLE's current error message.&quot;
  (foreign-string-to-lisp
   (slot-value handle 'error-buffer)))

(defun free-easy-handle (handle)
  &quot;Free CURL easy interface HANDLE and any C strings created to
be its options.&quot;
  (with-slots (pointer error-buffer c-strings) handle
    (curl-easy-cleanup pointer)
    (foreign-free error-buffer)
    (mapc #'foreign-string-free c-strings)))

(define-foreign-type easy-handle-type ()
  ()
  (:actual-type :pointer)
  (:simple-parser easy-handle))

(defmethod translate-to-foreign (handle (type easy-handle-type))
  &quot;Extract the pointer from an easy-HANDLE.&quot;
  (slot-value handle 'pointer))
</programlisting>
<para>While we changed some of the Lisp functions defined earlier to use
<acronym>CLOS</acronym> slots rather than hash tables, the foreign functions
work just as well as they did before.
</para>
<indexterm role="cp"><primary>limitations of type translators</primary></indexterm>
<para>The greatest strength, and the greatest limitation, of the type
translator comes from its generalized interface.  As stated
previously, we could define all foreign function calls in terms of the
primitive foreign types provided by <acronym>CFFI</acronym>.  The type translator
interface allows us to cleanly specify the relationship between Lisp
and C data, independent of where it appears in a function call.  This
independence comes at a price; for example, it cannot be used to
modify translation semantics based on other arguments to a function
call.  In these cases, you should rely on other features of Lisp,
rather than the powerful, yet domain-specific, type translator
interface.
</para>

</sect1>
<sect1 label="4.12" id="Tutorial_002dConclusion">
<title>What&#8217;s next?</title>

<para><acronym>CFFI</acronym> provides a rich and powerful foundation for communicating with
foreign libraries; as we have seen, it is up to you to make that
experience a pleasantly Lispy one.  This tutorial does not cover all
the features of <acronym>CFFI</acronym>; please see the rest of the manual for
details.  In particular, if something seems obviously missing, it is
likely that either code or a good reason for lack of code is already
present.
</para>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>There are some other things in <acronym>CFFI</acronym> that might deserve
tutorial sections, such as free-translated-object, or structs.  Let us
know which ones you care about.</emphasis>
</para></blockquote>

<!-- =================================================================== -->
<!-- CHAPTER: Wrapper generators -->

</sect1>
</chapter>
<chapter label="5" id="Wrapper-generators">
<title>Wrapper generators</title>

<para><acronym>CFFI</acronym>&#8217;s interface is designed for human programmers, being aimed at
aesthetic as well as technical sophistication.  However, there are a
few programs aimed at translating C and C++ header files, or
approximations thereof, into <acronym>CFFI</acronym> forms constituting a foreign
interface to the symbols in those files.
</para>
<para>These wrapper generators are known to support output of <acronym>CFFI</acronym> forms.
</para>
<variablelist><varlistentry><term><ulink url="http://www.cliki.net/Verrazano">Verrazano</ulink>
</term><listitem><para>Designed specifically for Common Lisp.  Uses <acronym>GCC</acronym>&#8217;s parser
output in <acronym>XML</acronym> format to discover functions, variables, and
other header file data.  This means you need <acronym>GCC</acronym> to generate
forms; on the other hand, the parser employed is mostly compliant with
<acronym>ANSI</acronym> C.
</para>
</listitem></varlistentry><varlistentry><term><ulink url="http://www.cliki.net/SWIG">SWIG</ulink>
</term><listitem><para>A foreign interface generator originally designed to generate Python
bindings, it has been ported to many other systems, including <acronym>CFFI</acronym>
in version 1.3.28.  Includes its own C declaration munger, not
intended to be fully-compliant with <acronym>ANSI</acronym> C.
</para></listitem></varlistentry></variablelist>
<para>First, this manual does not describe use of these other programs; they
have documentation of their own.  If you have problems using a
generated interface, please look at the output <acronym>CFFI</acronym> forms and
verify that they are a correct <acronym>CFFI</acronym> interface to the library in
question; if they are correct, contact <acronym>CFFI</acronym> developers with
details, keeping in mind that they communicate in terms of those forms
rather than any particular wrapper generator.  Otherwise, contact the
maintainers of the wrapper generator you are using, provided you can
reasonably expect more accuracy from the generator.
</para>
<para>When is more accuracy an unreasonable expectation?  As described in
the tutorial (see <link linkend="Tutorial_002dAbstraction">Breaking the
abstraction</link>), the information in C declarations is insufficient to
completely describe every interface.  In fact, it is quite common to
run into an interface that cannot be handled automatically, and
generators should be excused from generating a complete interface in
these cases.
</para>
<para>As further described in the tutorial, the thinnest Lisp interface to a
C function is not always the most pleasant one.  In many cases, you
will want to manually write a Lispier interface to the C functions
that interest you.
</para>
<para>Wrapper generators should be treated as time-savers, not complete
automation of the full foreign interface writing job.  Reports of the
amount of work done by generators vary from 30% to 90%.  The
incremental development style enabled by <acronym>CFFI</acronym> generally reduces
this proportion below that for languages like Python.
</para>
<!-- Where I got the above 30-90% figures: -->
<!-- 30%: lemonodor's post about SWIG -->
<!-- 90%: Balooga on #lisp.  He said 99%, but that's probably an -->
<!--      exaggeration (leave it to me to pass judgement :) -->
<!-- -stephen -->


<!-- =================================================================== -->
<!-- CHAPTER: Foreign Types -->

</chapter>
<chapter label="6" id="Foreign-Types">
<title>Foreign Types</title>

<para>Foreign types describe how data is translated back and forth between C
and Lisp. <acronym>CFFI</acronym> provides various built-in types and allows the user to
define new types.
</para>

<sect1 label="6.1" id="Built_002dIn-Types">
<title>Built-In Types</title>

<synopsis><indexterm role="tp"><primary>:char</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:char</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:unsigned-char</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:unsigned-char</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:short</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:short</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:unsigned-short</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:unsigned-short</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:int</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:int</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:unsigned-int</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:unsigned-int</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:long</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:long</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:unsigned-long</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:unsigned-long</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:long-long</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:long-long</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:unsigned-long-long</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:unsigned-long-long</structname></synopsis>

<para>These types correspond to the native C integer types according to the
<acronym>ABI</acronym> of the Lisp implementation&#8217;s host system.
</para>
<para><literal>:long-long</literal> and <literal>:unsigned-long-long</literal> are not supported
natively on all implementations. However, they are emulated by
<literal>mem-ref</literal> and <literal>mem-set</literal>.
</para>
<para>When those types are <emphasis role="bold">not</emphasis> available, the symbol
<literal>cffi-sys::no-long-long</literal> is pushed into <literal>*features*</literal>.
</para>
<synopsis><indexterm role="tp"><primary>:uchar</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:uchar</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:ushort</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:ushort</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:uint</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:uint</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:ulong</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:ulong</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:llong</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:llong</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:ullong</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:ullong</structname></synopsis>

<para>For convenience, the above types are provided as shortcuts for
<literal>unsigned-char</literal>, <literal>unsigned-short</literal>, <literal>unsigned-int</literal>,
<literal>unsigned-long</literal>, <literal>long-long</literal> and <literal>unsigned-long-long</literal>,
respectively.
</para>
<synopsis><indexterm role="tp"><primary>:int8</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:int8</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:uint8</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:uint8</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:int16</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:int16</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:uint16</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:uint16</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:int32</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:int32</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:uint32</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:uint32</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:int64</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:int64</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:uint64</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:uint64</structname></synopsis>

<para>Foreign integer types of specific sizes, corresponding to the C types
defined in <literal>stdint.h</literal>.
</para>
<!-- @ForeignType{:size} -->
<!-- @ForeignType{:ssize} -->
<!-- @ForeignType{:ptrdiff} -->
<!-- @ForeignType{:time} -->

<!-- Foreign integer types corresponding to the standard C types (without -->
<!-- the @code{_t} suffix). -->

<!-- @impnote{These are not implemented yet. -luis} -->

<!-- @impnote{I'm sure there are more of these that could be useful, let's -->
<!-- add any types that can't be defined portably to this list as -->
<!-- necessary. -james} -->

<synopsis><indexterm role="tp"><primary>:float</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:float</structname></synopsis>
<synopsis><indexterm role="tp"><primary>:double</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:double</structname></synopsis>

<para>On all systems, the <literal>:float</literal> and <literal>:double</literal> types represent a
C <literal>float</literal> and <literal>double</literal>, respectively. On most but not all
systems, <literal>:float</literal> and <literal>:double</literal> represent a Lisp
<literal>single-float</literal> and <literal>double-float</literal>, respectively. It is not
so useful to consider the relationship between Lisp types and C types
as isomorphic, as simply to recognize the relationship, and relative
precision, among each respective category.
</para>
<synopsis><indexterm role="tp"><primary>:long-double</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:long-double</structname></synopsis>

<para>This type is only supported on SCL.
</para>
<synopsis><indexterm role="tp"><primary>:pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:pointer</structname> <type>&amp;optional</type> <replaceable>type</replaceable></synopsis>

<para>A foreign pointer to an object of any type, corresponding to
<literal>void *</literal>.  You can optionally specify type of pointer
(e.g. <literal>(:pointer :char)</literal>).  Although <acronym>CFFI</acronym> won&#8217;t do anything
with that information yet, it is useful for documentation purposes.
</para>
<synopsis><indexterm role="tp"><primary>:void</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:void</structname></synopsis>

<para>No type at all. Only valid as the return type of a function.
</para>
</sect1>
<sect1 label="6.2" id="Other-Types">
<title>Other Types</title>

<para><acronym>CFFI</acronym> also provides a few useful types that aren&#8217;t built-in C
types.
</para>
<synopsis><indexterm role="tp"><primary>:string</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:string</structname></synopsis>

<para>The <literal>:string</literal> type performs automatic conversion between Lisp and
C strings. Note that, in the case of functions the converted C string
will have dynamic extent (i.e. it will be automatically freed after
the foreign function returns).
</para>
<para>In addition to Lisp strings, this type will accept foreign pointers
and pass them unmodified.
</para>
<para>A method for <link linkend="free_002dtranslated_002dobject">free-translated-object</link> is specialized for this
type. So, for example, foreign strings allocated by this type and
passed to a foreign function will be freed after the function
returns.
</para>
<programlisting>CFFI&gt; (foreign-funcall &quot;getenv&quot; :string &quot;SHELL&quot; :string)
&#8658; &quot;/bin/bash&quot;

CFFI&gt; (with-foreign-string (str &quot;abcdef&quot;)
        (foreign-funcall &quot;strlen&quot; :string str :int))
&#8658; 6
</programlisting>
<synopsis><indexterm role="tp"><primary>:string+ptr</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:string+ptr</structname></synopsis>

<para>Like <literal>:string</literal> but returns a list with two values when convert
from C to Lisp: a Lisp string and the C string&#8217;s foreign pointer.
</para>
<programlisting>CFFI&gt; (foreign-funcall &quot;getenv&quot; :string &quot;SHELL&quot; :string+ptr)
&#8658; (&quot;/bin/bash&quot; #.(SB-SYS:INT-SAP #XBFFFFC6F))
</programlisting>
<synopsis><indexterm role="tp"><primary>:boolean</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:boolean</structname> <type>&amp;optional</type> (<type>base-type</type> <replaceable>:int</replaceable>)</synopsis>

<para>The <literal>:boolean</literal> type converts between a Lisp boolean and a C
boolean. It canonicalizes to <replaceable>base-type</replaceable> which is <literal>:int</literal> by
default.
</para>
<programlisting>(convert-to-foreign nil :boolean) &#8658; 0
(convert-to-foreign t :boolean) &#8658; 1
(convert-from-foreign 0 :boolean) &#8658; nil
(convert-from-foreign 1 :boolean) &#8658; t
</programlisting>
<synopsis><indexterm role="tp"><primary>:bool</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:bool</structname></synopsis>

<para>The <literal>:bool</literal> type represents the C99 <literal>_Bool</literal> or C++
<literal>bool</literal>. Its size is usually 1 byte except on OSX where it&#8217;s an
<literal>int</literal>.
</para>
<synopsis><indexterm role="tp"><primary>:wrapper</primary></indexterm><phrase role="category"><emphasis role="bold">Foreign Type</emphasis>:</phrase> <structname>:wrapper</structname> <type>base-type</type> <replaceable>&amp;key</replaceable> <type>to-c</type> <replaceable>from-c</replaceable></synopsis>

<para>The <literal>:wrapper</literal> type stores two symbols passed to the <replaceable>to-c</replaceable>
and <replaceable>from-c</replaceable> arguments. When a value is being translated to or
from C, this type <literal>funcall</literal>s the respective symbol.
</para>
<para><literal>:wrapper</literal> types will be typedefs for <replaceable>base-type</replaceable> and will
inherit its translators, if any.
</para>
<para>Here&#8217;s an example of how the <literal>:boolean</literal> type could be defined in
terms of <literal>:wrapper</literal>.
</para>
<programlisting>(defun bool-c-to-lisp (value)
  (not (zerop value)))

(defun bool-lisp-to-c (value)
  (if value 1 0))

(defctype my-bool (:wrapper :int :from-c bool-c-to-lisp
                                 :to-c bool-lisp-to-c))

(convert-to-foreign nil 'my-bool) &#8658; 0
(convert-from-foreign 1 'my-bool) &#8658; t
</programlisting>
</sect1>
<sect1 label="6.3" id="Defining-Foreign-Types">
<title>Defining Foreign Types</title>

<para>You can define simple C-like <literal>typedef</literal>s through the
<literal>defctype</literal> macro. Defining a typedef is as simple as giving
<literal>defctype</literal> a new name and the name of the type to be wrapped.
</para>
<programlisting>;;; Define MY-INT as an alias for the built-in type :INT.
(defctype my-int :int)
</programlisting>
<para>With this type definition, one can, for instance, declare arguments to
foreign functions as having the type <literal>my-int</literal>, and they will be
passed as integers.
</para>
<bridgehead renderas="sect2">More complex types</bridgehead>

<para><acronym>CFFI</acronym> offers another way to define types through
<literal>define-foreign-type</literal>, a thin wrapper macro around
<literal>defclass</literal>. As an example, let&#8217;s go through the steps needed to
define a <literal>(my-string &amp;key encoding)</literal> type. First, we need to
define our type class:
</para>
<programlisting>(define-foreign-type my-string-type ()
  ((encoding :reader string-type-encoding :initarg :encoding))
  (:actual-type :pointer))
</programlisting>
<para>The <literal>:actual-type</literal> class option tells CFFI that this type will
ultimately be passed to and received from foreign code as a
<literal>:pointer</literal>. Now you need to tell CFFI how to parse a type
specification such as <literal>(my-string :encoding :utf8)</literal> into an
instance of <literal>my-string-type</literal>.  We do that with
<literal>define-parse-method</literal>:
</para>
<programlisting>(define-parse-method my-string (&amp;key (encoding :utf-8))
  (make-instance 'my-string-type :encoding encoding))
</programlisting>
<para>The next section describes how make this type actually translate
between C and Lisp strings.
</para>
</sect1>
<sect1 label="6.4" id="Foreign-Type-Translators">
<title>Foreign Type Translators</title>

<para>Type translators are used to automatically convert Lisp values to or
from foreign values.  For example, using type translators, one can
take the <literal>my-string</literal> type defined in the previous section and
specify that it should:
</para>
<itemizedlist><listitem><para>convert C strings to Lisp strings;
</para></listitem><listitem><para>convert Lisp strings to newly allocated C strings;
</para></listitem><listitem><para>free said C strings when they are no longer needed.
</para></listitem></itemizedlist>
<para>In order to tell <acronym>CFFI</acronym> how to automatically convert Lisp values to
foreign values, define a specialized method for the
<literal>translate-to-foreign</literal> generic function:
</para>
<programlisting>;;; Define a method that converts Lisp strings to C strings.
(defmethod translate-to-foreign (string (type my-string-type))
  (foreign-string-alloc string :encoding (string-type-encoding type)))
</programlisting>
<para>From now on, whenever an object is passed as a <literal>my-string</literal> to a
foreign function, this method will be invoked to convert the Lisp
value. To perform the inverse operation, which is needed for functions
that return a <literal>my-string</literal>, specialize the
<literal>translate-from-foreign</literal> generic function in the same manner:
</para>
<programlisting>;;; Define a method that converts C strings to Lisp strings.
(defmethod translate-from-foreign (pointer (type my-string-type))
  (foreign-string-to-lisp pointer :encoding (string-type-encoding type)))
</programlisting>
<para>When a <literal>translate-to-foreign</literal> method requires allocation of
foreign memory, you must also define a <literal>free-translated-object</literal>
method to free the memory once the foreign object is no longer needed,
otherwise you&#8217;ll be faced with memory leaks.  This generic function is
called automatically by <acronym>CFFI</acronym> when passing objects to foreign
functions. Let&#8217;s do that:
</para>
<programlisting>;;; Free strings allocated by translate-to-foreign.
(defmethod free-translated-object (pointer (type my-string-type) param)
  (declare (ignore param))
  (foreign-string-free pointer))
</programlisting>
<para>In this specific example, we don&#8217;t need the <replaceable>param</replaceable> argument, so
we ignore it. See <link linkend="free_002dtranslated_002dobject">free-translated-object</link>, for an explanation of
its purpose and how you can use it.
</para>
<para>A type translator does not necessarily need to convert the value.  For
example, one could define a typedef for <literal>:pointer</literal> that ensures,
in the <literal>translate-to-foreign</literal> method, that the value is not a
null pointer, signalling an error if a null pointer is passed.  This
would prevent some pointer errors when calling foreign functions that
cannot handle null pointers.
</para>
<para><emphasis role="bold">Please note:</emphasis> these methods are meant as extensible hooks
only, and you should not call them directly.  Use
<literal>convert-to-foreign</literal>, <literal>convert-from-foreign</literal> and
<literal>free-converted-object</literal> instead.
</para>
<para>See <link linkend="Tutorial_002dTypes">Defining new types</link>, for another example of
type translators.
</para>
</sect1>
<sect1 label="6.5" id="Optimizing-Type-Translators">
<title>Optimizing Type Translators</title>

<indexterm role="cp"><primary>type translators, optimizing</primary></indexterm>
<indexterm role="cp"><primary>compiler macros for type translation</primary></indexterm>
<indexterm role="cp"><primary>defining type-translation compiler macros</primary></indexterm>
<para>Being based on generic functions, the type translation mechanism
described above can add a bit of overhead.  This is usually not
significant, but we nevertheless provide a way of getting rid of the
overhead for the cases where it matters.
</para>
<para>A good way to understand this issue is to look at the code generated
by <literal>defcfun</literal>. Consider the following example using the previously
defined <literal>my-string</literal> type:
</para>
<programlisting>CFFI&gt; (macroexpand-1 '(defcfun foo my-string (x my-string)))
;; (simplified, downcased, etc...)
(defun foo (x)
  (multiple-value-bind (#:G2019 #:PARAM3149)
      (translate-to-foreign x #&lt;MY-STRING-TYPE {11ED5A79}&gt;)
    (unwind-protect
        (translate-from-foreign
         (foreign-funcall &quot;foo&quot; :pointer #:G2019 :pointer)
         #&lt;MY-STRING-TYPE {11ED5659}&gt;)
      (free-translated-object #:G2019 #&lt;MY-STRING-TYPE {11ED51A79}&gt;
                              #:PARAM3149))))
</programlisting>
<para>In order to get rid of those generic function calls, <acronym>CFFI</acronym> has
another set of extensible generic functions that provide functionality
similar to <acronym>CL</acronym>&#8217;s compiler macros:
<literal>expand-to-foreign-dyn</literal>, <literal>expand-to-foreign</literal> and
<literal>expand-from-foreign</literal>. Here&#8217;s how one could define a
<literal>my-boolean</literal> with them:
</para>
<programlisting>(define-foreign-type my-boolean-type ()
  ()
  (:actual-type :int)
  (:simple-parser my-boolean))

(defmethod expand-to-foreign (value (type my-boolean-type))
  `(if ,value 1 0))

(defmethod expand-from-foreign (value (type my-boolean-type))
  `(not (zerop ,value)))
</programlisting>
<para>And here&#8217;s what the macroexpansion of a function using this type would
look like:
</para>
<programlisting>CFFI&gt; (macroexpand-1 '(defcfun bar my-boolean (x my-boolean)))
;; (simplified, downcased, etc...)
(defun bar (x)
  (let ((#:g3182 (if x 1 0)))
    (not (zerop (foreign-funcall &quot;bar&quot; :int #:g3182 :int)))))
</programlisting>
<para>No generic function overhead.
</para>
<para>Let&#8217;s go back to our <literal>my-string</literal> type.  The expansion interface
has no equivalent of <literal>free-translated-object</literal>; you must instead
define a method on <literal>expand-to-foreign-dyn</literal>, the third generic
function in this interface.  This is especially useful when you can
allocate something much more efficiently if you know the object has
dynamic extent, as is the case with function calls that don&#8217;t save the
relevant allocated arguments.
</para>
<para>This exactly what we need for the <literal>my-string</literal> type:
</para>
<programlisting>(defmethod expand-from-foreign (form (type my-string-type))
  `(foreign-string-to-lisp ,form))

(defmethod expand-to-foreign-dyn (value var body (type my-string-type))
  (let ((encoding (string-type-encoding type)))
    `(with-foreign-string (,var ,value :encoding ',encoding)
       ,@body)))
</programlisting>
<para>So let&#8217;s look at the macro expansion:
</para>
<programlisting>CFFI&gt; (macroexpand-1 '(defcfun foo my-string (x my-string)))
;; (simplified, downcased, etc...)
(defun foo (x)
  (with-foreign-string (#:G2021 X :encoding ':utf-8)
    (foreign-string-to-lisp
     (foreign-funcall &quot;foo&quot; :pointer #:g2021 :pointer))))
</programlisting>
<para>Again, no generic function overhead.
</para>
<bridgehead renderas="sect2">Other details</bridgehead>

<para>To short-circuit expansion and use the <literal>translate-*</literal> functions
instead, simply call the next method.  Return its result in cases
where your method cannot generate an appropriate replacement for it.
This analogous to the <literal>&amp;whole form</literal> mechanism compiler macros
provide.
</para>
<para>The <literal>expand-*</literal> methods have precedence over their
<literal>translate-*</literal> counterparts and are guaranteed to be used in
<literal>defcfun</literal>, <literal>foreign-funcall</literal>, <literal>defcvar</literal> and
<literal>defcallback</literal>.  If you define a method on each of the
<literal>expand-*</literal> generic functions, you are guaranteed to have full
control over the expressions generated for type translation in these
macros.
</para>
<para>They may or may not be used in other <acronym>CFFI</acronym> operators that need to
translate between Lisp and C data; you may only assume that
<literal>expand-*</literal> methods will probably only be called during Lisp
compilation.
</para>
<para><literal>expand-to-foreign-dyn</literal> has precedence over
<literal>expand-to-foreign</literal> and is only used in <literal>defcfun</literal> and
<literal>foreign-funcall</literal>, only making sense in those contexts.
</para>
<para><emphasis role="bold">Important note:</emphasis> this set of generic functions is called at
macroexpansion time.  Methods are defined when loaded or evaluated,
not compiled.  You are responsible for ensuring that your
<literal>expand-*</literal> methods are defined when the <literal>foreign-funcall</literal> or
other forms that use them are compiled.  One way to do this is to put
the method definitions earlier in the file and inside an appropriate
<literal>eval-when</literal> form; another way is to always load a separate Lisp
or <acronym>FASL</acronym> file containing your <literal>expand-*</literal> definitions
before compiling files with forms that ought to use them.  Otherwise,
they will not be found and the runtime translators will be used
instead.
</para>
</sect1>
<sect1 label="6.6" id="Foreign-Structure-Types">
<title>Foreign Structure Types</title>

<para>For more involved C types than simple aliases to built-in types, such
as you can make with <literal>defctype</literal>, <acronym>CFFI</acronym> allows declaration of
structures and unions with <literal>defcstruct</literal> and <literal>defcunion</literal>.
</para>
<para>For example, consider this fictional C structure declaration holding
some personal information:
</para>
<screen>struct person {
  int number;
  char* reason;
};
</screen>
<para>The equivalent <literal>defcstruct</literal> form follows:
</para>
<programlisting>(defcstruct person
  (number :int)
  (reason :string))
</programlisting>
<!-- LMH structure translation -->
<para>By default, <link linkend="convert_002dfrom_002dforeign">convert-from-foreign</link> (and also <link linkend="mem_002dref">mem-ref</link>) will
make a plist with slot names as keys, and <link linkend="convert_002dto_002dforeign">convert-to-foreign</link> will
translate such a plist to a foreign structure.  A user wishing to define
other translations should use the <literal>:class</literal> argument to
<link linkend="defcstruct">defcstruct</link>, and then define methods for
<link linkend="translate_002dfrom_002dforeign">translate-from-foreign</link> and
<link linkend="translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</link> that specialize on this class,
possibly calling <literal>call-next-method</literal> to translate from and to the
plists rather than provide a direct interface to the foreign object.
The macro <literal>translation-forms-for-class</literal> will generate the forms
necessary to translate a Lisp class into a foreign structure and vice
versa.
<!-- Write separate function doc section for translation-forms-for-class? -->
<!-- Examples, perhaps taken from the tests? -->
</para>
<para>Please note that this interface is only for those that must know about
the values contained in a relevant struct.  If the library you are
interfacing returns an opaque pointer that needs only be passed to
other C library functions, by all means just use <literal>:pointer</literal> or a
type-safe definition munged together with <literal>defctype</literal> and type
translation.  To pass or return a structure by value to a function, load
the cffi-libffi system and specify the structure as <literal>(:struct
<replaceable>structure-name</replaceable>)</literal>.  To pass or return the pointer, you can use
either <literal>:pointer</literal> or <literal>(:pointer (:struct
<replaceable>structure-name</replaceable>))</literal>.
</para>
<bridgehead renderas="sect2">Optimizing translate-into-foreign-memory</bridgehead>

<para>Just like how <link linkend="translate_002dfrom_002dforeign">translate-from-foreign</link> had
<literal>expand-from-foreign</literal> to optimize away the generic function call
and <link linkend="translate_002dto_002dforeign">translate-to-foreign</link> had the same in
<literal>expand-to-foreign</literal>, <link linkend="translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</link> has
<literal>expand-into-foreign-memory</literal>.
</para>
<para>Let&#8217;s use our <literal>person</literal> struct in an example. However, we are
going to spice it up by using a lisp struct rather than a plist to
represent the person in lisp.
</para>
<para>First we redefine <literal>person</literal> very slightly.
</para>
<programlisting>(defcstruct (person :class c-person)
  (number :int)
  (reason :string))
</programlisting>
<para>By adding <literal>:class</literal> we can specialize the <literal>translate-*</literal>
methods on the type <literal>c-person</literal>.
</para>
<para>Next we define a lisp struct to use instead of the plists.
</para>
<programlisting>(defstruct lisp-person
  (number 0 :type integer)
  (reason &quot;&quot; :type string))
</programlisting>
<para>And now let&#8217;s define the type translators we know already:
</para>
<programlisting>(defmethod translate-from-foreign (ptr (type c-person))
  (with-foreign-slots ((number reason) ptr (:struct person))
    (make-lisp-person :number number :reason reason)))

(defmethod expand-from-foreign (ptr (type c-person))
  `(with-foreign-slots ((number reason) ,ptr (:struct person))
     (make-lisp-person :number number :reason reason)))

(defmethod translate-into-foreign-memory (value (type c-person) ptr)
  (with-foreign-slots ((number reason) ptr (:struct person))
    (setf number (lisp-person-number value)
          reason (lisp-person-reason value))))
</programlisting>
<para>At this point everything works, we can convert to and from our
<literal>lisp-person</literal> and foreign <literal>person</literal>. If we macroexpand
</para>
<programlisting>(setf (mem-aref ptr '(:struct person)) x)
</programlisting>
<para>we get something like:
</para>
<programlisting>(let ((#:store879 x))
  (translate-into-foreign-memory #:store879 #&lt;c-person person&gt;
                                 (inc-pointer ptr 0))
  #:store879)
</programlisting>
<para>Which is good, but now we can do better and get rid of that generic
function call to <literal>translate-into-foreign-memory</literal>.
</para>
<programlisting>(defmethod expand-into-foreign-memory (value (type c-person) ptr)
  `(with-foreign-slots ((number reason) ,ptr (:struct person))
     (setf number (lisp-person-number ,value)
           reason (lisp-person-reason ,value))))
</programlisting>
<para>Now we can expand again so see the changes:
</para>
<programlisting>;; this:
(setf (mem-aref ptr '(:struct person)) x)

;; expands to this
;; (simplified, downcased, etc..)
(let ((#:store887 x))
  (with-foreign-slots ((number reason) (inc-pointer ptr 0) (:struct person))
    (setf number (lisp-person-number #:store887)
          reason (lisp-person-reason #:store887))) #:store887)
</programlisting>
<para>And there we are, no generic function overhead.
</para>
<bridgehead renderas="sect2">Compatibility note</bridgehead>

<para>Previous versions of CFFI accepted the
&#8220;bare&#8221; <replaceable>structure-name</replaceable> as a type specification, which was
interpreted as a pointer to the structure.  This is deprecated and
produces a style warning.  Using this deprecated form means that
<link linkend="mem_002daref">mem-aref</link> retains its prior meaning and returns a pointer.  Using
the <literal>(:struct <replaceable>structure-name</replaceable>)</literal> form for the type,
<link linkend="mem_002daref">mem-aref</link> provides a Lisp object translated from the
structure (by default a plist).  Thus the semantics are consistent with all
types in returning the object as represented in Lisp, and not a pointer,
with the exception of the &#8220;bare&#8221; structure compatibility retained.
In order to obtain the pointer, you should use the function <link linkend="mem_002daptr">mem-aptr</link>.
</para>
<para>See <link linkend="defcstruct">defcstruct</link> for more details.
</para>
</sect1>
<sect1 label="6.7" id="Allocating-Foreign-Objects">
<title>Allocating Foreign Objects</title>

<!-- I moved this because I moved with-foreign-object to the Pointers -->
<!-- chapter, where foreign-alloc is. -->

<para>See <link linkend="Allocating-Foreign-Memory">Allocating Foreign Memory</link>.
</para>

<!-- =================================================================== -->
<!-- CONVERT-FROM-FOREIGN -->

<anchor id="convert_002dfrom_002dforeign"/>
<bridgehead renderas="sect1">convert-from-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>convert-from-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>convert-from-foreign</function> <replaceable>foreign-value</replaceable> <replaceable>type</replaceable> <replaceable>&#8658;</replaceable> <replaceable>value</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-value</replaceable>
</term><listitem><para>The primitive C value as returned from a primitive foreign function or
from <literal>convert-to-foreign</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A <acronym>CFFI</acronym> type specifier.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>The Lisp value translated from <replaceable>foreign-value</replaceable>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<para>This is an external interface to the type translation facility.  In
the implementation, all foreign functions are ultimately defined as
type translation wrappers around primitive foreign function
invocations.
</para>
<para>This function is available mostly for inspection of the type
translation process, and possibly optimization of special cases of
your foreign function calls.
</para>
<para>Its behavior is better described under <literal>translate-from-foreign</literal>&#8217;s
documentation.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI-USER&gt; (convert-to-foreign &quot;a boat&quot; :string)
&#8658; #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
&#8658; T
CFFI-USER&gt; (convert-from-foreign * :string)
&#8658; &quot;a boat&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="convert_002dto_002dforeign">convert-to-foreign</link> 

<link linkend="free_002dconverted_002dobject">free-converted-object</link> 

<link linkend="translate_002dfrom_002dforeign">translate-from-foreign</link>
</para>

<!-- =================================================================== -->
<!-- CONVERT-TO-FOREIGN -->

<anchor id="convert_002dto_002dforeign"/>
<bridgehead renderas="sect1">convert-to-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>convert-to-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>convert-to-foreign</function> <replaceable>value</replaceable> <replaceable>type</replaceable> <replaceable>&#8658;</replaceable> <replaceable>foreign-value</replaceable>, <replaceable>alloc-params</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>The Lisp object to be translated to a foreign object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A <acronym>CFFI</acronym> type specifier.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>foreign-value</replaceable>
</term><listitem><para>The primitive C value, ready to be passed to a primitive foreign
function.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>alloc-params</replaceable>
</term><listitem><para>Something of a translation state; you must pass it to
<literal>free-converted-object</literal> along with the foreign value for that to
work.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<para>This is an external interface to the type translation facility.  In
the implementation, all foreign functions are ultimately defined as
type translation wrappers around primitive foreign function
invocations.
</para>
<para>This function is available mostly for inspection of the type
translation process, and possibly optimization of special cases of
your foreign function calls.
</para>
<para>Its behavior is better described under <literal>translate-to-foreign</literal>&#8217;s
documentation.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI-USER&gt; (convert-to-foreign t :boolean)
&#8658; 1
&#8658; NIL
CFFI-USER&gt; (convert-to-foreign &quot;hello, world&quot; :string)
&#8658; #&lt;FOREIGN-ADDRESS #x097C5F80&gt;
&#8658; T
CFFI-USER&gt; (code-char (mem-aref * :char 5))
&#8658; #\,
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="convert_002dfrom_002dforeign">convert-from-foreign</link> 

<link linkend="free_002dconverted_002dobject">free-converted-object</link> 

<link linkend="translate_002dto_002dforeign">translate-to-foreign</link>
</para>

<!-- =================================================================== -->
<!-- DEFBITFIELD -->

<anchor id="defbitfield"/>
<bridgehead renderas="sect1">defbitfield</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defbitfield</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defbitfield</function> <replaceable>name-and-options</replaceable> <replaceable>&amp;body</replaceable> <replaceable>masks</replaceable></synopsis>

<para>masks ::= [docstring] { (symbol value) }* 

name-and-options ::= name | (name &amp;optional (base-type :int)) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>The name of the new bitfield type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>docstring</replaceable>
</term><listitem><para>A documentation string, ignored.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>base-type</replaceable>
</term><listitem><para>A symbol denoting a foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>symbol</replaceable>
</term><listitem><para>A Lisp symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>An integer representing a bitmask.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>defbitfield</literal> macro is used to define foreign types that map
lists of symbols to integer values.
</para>
<para>If <replaceable>value</replaceable> is omitted, it will be computed as follows: find the
greatest <replaceable>value</replaceable> previously used, including those so computed,
with only a single 1-bit in its binary representation (that is, powers
of two), and left-shift it by one.  This rule guarantees that a
computed <replaceable>value</replaceable> cannot clash with previous values, but may clash
with future explicitly specified values.
</para>
<para>Symbol lists will be automatically converted to values and vice versa
when being passed as arguments to or returned from foreign functions,
respectively. The same applies to any other situations where an object
of a bitfield type is expected.
</para>
<para>Types defined with <literal>defbitfield</literal> canonicalize to <replaceable>base-type</replaceable>
which is <literal>:int</literal> by default.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defbitfield open-flags
  (:rdonly #x0000)
  :wronly               ;#x0001
  :rdwr                 ;&#8230;
  :nonblock
  :append
  (:creat  #x0200))
  ;; etc&#8230;

CFFI&gt; (foreign-bitfield-symbols 'open-flags #b1101)
&#8658; (:WRONLY :NONBLOCK :APPEND)

CFFI&gt; (foreign-bitfield-value 'open-flags '(:rdwr :creat))
&#8658; 514   ; #x0202

(defcfun (&quot;open&quot; unix-open) :int
  (path :string)
  (flags open-flags)
  (mode :uint16)) ; unportable

CFFI&gt; (unix-open &quot;/tmp/foo&quot; '(:wronly :creat) #o644)
&#8658; #&lt;an fd&gt;

;;; Consider also the following lispier wrapper around open()
(defun lispier-open (path mode &amp;rest flags)
  (unix-open path flags mode))
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dbitfield_002dvalue">foreign-bitfield-value</link> 

<link linkend="foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</link>
</para>

<!-- =================================================================== -->
<!-- DEFCSTRUCT -->

<anchor id="defcstruct"/>
<bridgehead renderas="sect1">defcstruct</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defcstruct</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defcstruct</function> <replaceable>name-and-options</replaceable> <replaceable>&amp;body</replaceable> <replaceable>doc-and-slots</replaceable> <replaceable>&#8658;</replaceable> <replaceable>name</replaceable></synopsis>

<para>name-and-options ::= structure-name | (structure-name &amp;key size) 

doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count offset) }*
</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>structure-name</replaceable>
</term><listitem><para>The name of new structure type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>docstring</replaceable>
</term><listitem><para>A documentation string, ignored.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-name</replaceable>
</term><listitem><para>A symbol naming the slot.  It must be unique among slot names in this
structure.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>size</replaceable>
</term><listitem><para>Use this option to override the size (in bytes) of the struct.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-type</replaceable>
</term><listitem><para>The type specifier for the slot.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>count</replaceable>
</term><listitem><para>Used to declare an array of size <replaceable>count</replaceable> inside the
structure.  Defaults to <literal>1</literal> as such an array and a single element
are semantically equivalent.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>offset</replaceable>
</term><listitem><para>Overrides the slot&#8217;s offset. The next slot&#8217;s offset is calculated
based on this one.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>This defines a new <acronym>CFFI</acronym> aggregate type akin to C <literal>struct</literal>s.
In other words, it specifies that foreign objects of the type
<replaceable>structure-name</replaceable> are groups of different pieces of data, or
&#8220;slots&#8221;, of the <replaceable>slot-type</replaceable>s, distinguished from each other by
the <replaceable>slot-name</replaceable>s.  Each structure is located in memory at a
position, and the slots are allocated sequentially beginning at that
point in memory (with some padding allowances as defined by the C
<acronym>ABI</acronym>, unless otherwise requested by specifying an
<replaceable>offset</replaceable> from the beginning of the structure (offset 0).
</para>
<para>In other words, it is isomorphic to the C <literal>struct</literal>, giving
several extra features.
</para>
<para>There are two kinds of slots, for the two kinds of <acronym>CFFI</acronym> types:
</para>
<variablelist><varlistentry><term><firstterm>Simple</firstterm>
</term><listitem><para>Contain a single instance of a type that canonicalizes to a built-in
type, such as <literal>:long</literal> or <literal>:pointer</literal>.  Used for simple
<acronym>CFFI</acronym> types.
</para>
</listitem></varlistentry><varlistentry><term><firstterm>Aggregate</firstterm>
</term><listitem><para>Contain an embedded structure or union, or an array of objects.  Used
for aggregate <acronym>CFFI</acronym> types.
</para></listitem></varlistentry></variablelist>
<para>The use of <acronym>CLOS</acronym> terminology for the structure-related
features is intentional; structure definitions are very much like
classes with (far) fewer features.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct point
  &quot;Point structure.&quot;
  (x :int)
  (y :int))

CFFI&gt; (with-foreign-object (ptr 'point)
        ;; Initialize the slots
        (setf (foreign-slot-value ptr 'point 'x) 42
              (foreign-slot-value ptr 'point 'y) 42)
        ;; Return a list with the coordinates
        (with-foreign-slots ((x y) ptr point)
          (list x y)))
&#8658; (42 42)
</programlisting>
<programlisting>;; Using the :size and :offset options to define a partial structure.
;; (this is useful when you are interested in only a few slots
;; of a big foreign structure)

(defcstruct (foo :size 32)
  &quot;Some struct with 32 bytes.&quot;
                        ; &lt;16 bytes we don't care about&gt;
  (x :int :offset 16)   ; an int at offset 16
  (y :int)              ; another int at offset 16+sizeof(int)
                        ; &lt;a couple more bytes we don't care about&gt;
  (z :char :offset 24)) ; a char at offset 24
                        ; &lt;7 more bytes ignored (since size is 32)&gt;

CFFI&gt; (foreign-type-size 'foo)
&#8658; 32
</programlisting>
<programlisting>;;; Using :count to define arrays inside of a struct.
(defcstruct video_tuner
  (name :char :count 32))
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dslot_002dpointer">foreign-slot-pointer</link> 

<link linkend="foreign_002dslot_002dvalue">foreign-slot-value</link> 

<link linkend="with_002dforeign_002dslots">with-foreign-slots</link>
</para>

<!-- =================================================================== -->
<!-- DEFCUNION -->

<anchor id="defcunion"/>
<bridgehead renderas="sect1">defcunion</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defcunion</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defcunion</function> <replaceable>name</replaceable> <replaceable>&amp;body</replaceable> <replaceable>doc-and-slots</replaceable> <replaceable>&#8658;</replaceable> <replaceable>name</replaceable></synopsis>

<para>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count) }*
</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>The name of new union type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>docstring</replaceable>
</term><listitem><para>A documentation string, ignored.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-name</replaceable>
</term><listitem><para>A symbol naming the slot.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-type</replaceable>
</term><listitem><para>The type specifier for the slot.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>count</replaceable>
</term><listitem><para>Used to declare an array of size <replaceable>count</replaceable> inside the
structure.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>A union is a structure in which all slots have an offset of zero.  It
is isomorphic to the C <literal>union</literal>.  Therefore, you should use the
usual foreign structure operations for accessing a union&#8217;s slots.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcunion uint32-bytes
  (int-value :unsigned-int)
  (bytes :unsigned-char :count 4))
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dslot_002dpointer">foreign-slot-pointer</link> 

<link linkend="foreign_002dslot_002dvalue">foreign-slot-value</link>
</para>

<!-- =================================================================== -->
<!-- DEFCTYPE -->

<anchor id="defctype"/>
<bridgehead renderas="sect1">defctype</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defctype</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defctype</function> <replaceable>name</replaceable> <replaceable>base-type</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>documentation</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>The name of the new foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>base-type</replaceable>
</term><listitem><para>A symbol or a list defining the new type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>documentation</replaceable>
</term><listitem><para>A documentation string, currently ignored.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>defctype</literal> macro provides a mechanism similar to C&#8217;s
<literal>typedef</literal> to define new types. The new type inherits
<replaceable>base-type</replaceable>&#8217;s translators, if any. There is no way to define
translations for types defined with <literal>defctype</literal>.  For that,
you should use <link linkend="define_002dforeign_002dtype">define-foreign-type</link>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defctype my-string :string
  &quot;My own string type.&quot;)

(defctype long-bools (:boolean :long)
  &quot;Booleans that map to C longs.&quot;)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="define_002dforeign_002dtype">define-foreign-type</link>
</para>

<!-- =================================================================== -->
<!-- DEFCENUM -->

<anchor id="defcenum"/>
<bridgehead renderas="sect1">defcenum</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defcenum</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defcenum</function> <replaceable>name-and-options</replaceable> <replaceable>&amp;body</replaceable> <replaceable>enum-list</replaceable></synopsis>

<para>enum-list ::= [docstring] { keyword | (keyword value) }* 

name-and-options ::= name | (name &amp;optional (base-type :int) &amp;key allow-undeclared-values) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>The name of the new enum type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>docstring</replaceable>
</term><listitem><para>A documentation string, ignored.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>base-type</replaceable>
</term><listitem><para>A symbol denoting a foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>allow-undeclared-values</replaceable>
</term><listitem><para>Whether to pass through integer values that were not explicitly declared
in the enum when translating from foreign memory.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>keyword</replaceable>
</term><listitem><para>A keyword symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>An index value for a keyword.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>defcenum</literal> macro is used to define foreign types that map
keyword symbols to integer values, similar to the C <literal>enum</literal> type.
</para>
<para>If <replaceable>value</replaceable> is omitted its value will either be 0, if it&#8217;s the
first entry, or it it will continue the progression from the last
specified value.
</para>
<para>Keywords will be automatically converted to values and vice-versa when
being passed as arguments to or returned from foreign functions,
respectively. The same applies to any other situations where an object
of an <literal>enum</literal> type is expected.
</para>
<para>If a value should be translated to lisp that is not declared in the
enum, an error will be signalled. You can elide this error and instead
make it pass the original enum value by specifying
<replaceable>allow-undeclared-values</replaceable>. This can be useful for very large
enumerations of which we only care about a subset of values, or for
enumerations that should allow for client or vendor extensions that we
cannot know about.
</para>
<para>Types defined with <literal>defcenum</literal> canonicalize to <replaceable>base-type</replaceable>
which is <literal>:int</literal> by default.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcenum boolean
  :no
  :yes)

CFFI&gt; (foreign-enum-value 'boolean :no)
&#8658; 0
</programlisting>
<programlisting>(defcenum numbers
  (:one 1)
  :two
  (:four 4))

CFFI&gt; (foreign-enum-keyword 'numbers 2)
&#8658; :TWO
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002denum_002dvalue">foreign-enum-value</link> 

<link linkend="foreign_002denum_002dkeyword">foreign-enum-keyword</link>
</para>

<!-- =================================================================== -->
<!-- DEFINE-FOREIGN-TYPE -->

<anchor id="define_002dforeign_002dtype"/>
<bridgehead renderas="sect1">define-foreign-type</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>define-foreign-type</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>define-foreign-type</function> <replaceable>class-name</replaceable> <replaceable>supers</replaceable> <replaceable>slots</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>options</replaceable> <replaceable>&#8658;</replaceable> <replaceable>class-name</replaceable></synopsis>

<para>options ::= (<literal>:actual-type</literal> <replaceable>type</replaceable>) | &#160;    (<literal>:simple-parser</literal> <replaceable>symbol</replaceable>) | &#160;    <emphasis>regular defclass option</emphasis>
</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>class-name</replaceable>
</term><listitem><para>A symbol naming the new foreign type class.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>supers</replaceable>
</term><listitem><para>A list of symbols naming the super classes.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slots</replaceable>
</term><listitem><para>A list of slot definitions, passed to <literal>defclass</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<!-- TODO rewrite -->

<para>The macro <literal>define-foreign-type</literal> defines a new class
<replaceable>class-name</replaceable>. It is a thin wrapper around <literal>defclass</literal>. Among
other things, it ensures that <replaceable>class-name</replaceable> becomes a subclass of
<replaceable>foreign-type</replaceable>, what you need to know about that is that there&#8217;s
an initarg <literal>:actual-type</literal> which serves the same purpose as
<literal>defctype</literal>&#8217;s <replaceable>base-type</replaceable> argument.
</para>
<!-- TODO mention the type translators here -->
<!-- FIX FIX -->

<bridgehead renderas="sect2">Examples</bridgehead>
<para>Taken from <acronym>CFFI</acronym>&#8217;s <literal>:boolean</literal> type definition:
</para>
<programlisting>(define-foreign-type :boolean (&amp;optional (base-type :int))
  &quot;Boolean type. Maps to an :int by default. Only accepts integer types.&quot;
  (ecase base-type
    ((:char
      :unsigned-char
      :int
      :unsigned-int
      :long
      :unsigned-long) base-type)))

CFFI&gt; (canonicalize-foreign-type :boolean)
&#8658; :INT
CFFI&gt; (canonicalize-foreign-type '(:boolean :long))
&#8658; :LONG
CFFI&gt; (canonicalize-foreign-type '(:boolean :float))
;; error&#8594; signalled by ECASE.
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defctype">defctype</link> 

<link linkend="define_002dparse_002dmethod">define-parse-method</link>
</para>

<!-- =================================================================== -->
<!-- DEFINE-PARSE-METHOD -->

<anchor id="define_002dparse_002dmethod"/>
<bridgehead renderas="sect1">define-parse-method</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>define-parse-method</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>define-parse-method</function> <replaceable>name</replaceable> <replaceable>lambda-list</replaceable> <replaceable>&amp;body</replaceable> <replaceable>body</replaceable> <replaceable>&#8658;</replaceable> <replaceable>name</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type-name</replaceable>
</term><listitem><para>A symbol naming the new foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>lambda-list</replaceable>
</term><listitem><para>A lambda list which is the argument list of the new foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>body</replaceable>
</term><listitem><para>One or more forms that provide a definition of the new foreign type.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>


<!-- TODO: update example. The boolean type is probably a good choice. -->

<bridgehead renderas="sect2">Examples</bridgehead>
<para>Taken from <acronym>CFFI</acronym>&#8217;s <literal>:boolean</literal> type definition:
</para>
<programlisting>(define-foreign-type :boolean (&amp;optional (base-type :int))
  &quot;Boolean type. Maps to an :int by default. Only accepts integer types.&quot;
  (ecase base-type
    ((:char
      :unsigned-char
      :int
      :unsigned-int
      :long
      :unsigned-long) base-type)))

CFFI&gt; (canonicalize-foreign-type :boolean)
&#8658; :INT
CFFI&gt; (canonicalize-foreign-type '(:boolean :long))
&#8658; :LONG
CFFI&gt; (canonicalize-foreign-type '(:boolean :float))
;; error&#8594; signalled by ECASE.
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="define_002dforeign_002dtype">define-foreign-type</link>
</para>

<!-- =================================================================== -->
<!-- EXPLAIN-FOREIGN-SLOT-VALUE -->

<!-- @node explain-foreign-slot-value -->
<!-- @heading explain-foreign-slot-value -->
<!-- @subheading Syntax -->
<!-- @Macro{explain-foreign-slot-value ptr type &rest slot-names} -->

<!-- @subheading Arguments and Values -->

<!-- @table @var -->
<!-- @item ptr -->
<!-- ... -->

<!-- @item type -->
<!-- ... -->

<!-- @item slot-names -->
<!-- ... -->
<!-- @end table -->

<!-- @subheading Description -->
<!-- This macro translates the slot access that would occur by calling -->
<!-- @code{foreign-slot-value} with the same arguments into an equivalent -->
<!-- expression in C and prints it to @code{*standard-output*}. -->

<!-- @emph{Note: this is not implemented yet.} -->

<!-- @subheading Examples -->
<!-- @lisp -->
<!-- CFFI> (explain-foreign-slot-value ptr 'timeval 'tv-secs) -->
<!-- @result{} ptr->tv_secs -->

<!-- CFFI> (explain-foreign-slot-value emp 'employee 'hire-date 'tv-usecs) -->
<!-- @result{} emp->hire_date.tv_usecs -->
<!-- @end lisp -->

<!-- @subheading See Also -->


<!-- =================================================================== -->
<!-- FOREIGN-BITFIELD-SYMBOLS -->

<anchor id="foreign_002dbitfield_002dsymbols"/>
<bridgehead renderas="sect1">foreign-bitfield-symbols</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-bitfield-symbols</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-bitfield-symbols</function> <replaceable>type</replaceable> <replaceable>value</replaceable> <replaceable>&#8658;</replaceable> <replaceable>symbols</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A bitfield type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>symbols</replaceable>
</term><listitem><para>A potentially shared list of symbols.
<literal>nil</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-bitfield-symbols</literal> returns a possibly shared
list of symbols that correspond to <replaceable>value</replaceable> in <replaceable>type</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defbitfield flags
  (flag-a 1)
  (flag-b 2)
  (flag-c 4))

CFFI&gt; (foreign-bitfield-symbols 'flags #b101)
&#8658; (FLAG-A FLAG-C)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defbitfield">defbitfield</link> 

<link linkend="foreign_002dbitfield_002dvalue">foreign-bitfield-value</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-BITFIELD-VALUE -->

<anchor id="foreign_002dbitfield_002dvalue"/>
<bridgehead renderas="sect1">foreign-bitfield-value</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-bitfield-value</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-bitfield-value</function> <replaceable>type</replaceable> <replaceable>symbols</replaceable> <replaceable>&#8658;</replaceable> <replaceable>value</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A <literal>bitfield</literal> type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>symbol</replaceable>
</term><listitem><para>A Lisp symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-bitfield-value</literal> returns the <replaceable>value</replaceable> that
corresponds to the symbols in the <replaceable>symbols</replaceable> list.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defbitfield flags
  (flag-a 1)
  (flag-b 2)
  (flag-c 4))

CFFI&gt; (foreign-bitfield-value 'flags '(flag-a flag-c))
&#8658; 5  ; #b101
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defbitfield">defbitfield</link> 

<link linkend="foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-ENUM-KEYWORD -->

<anchor id="foreign_002denum_002dkeyword"/>
<bridgehead renderas="sect1">foreign-enum-keyword</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-enum-keyword</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-enum-keyword</function> <replaceable>type</replaceable> <replaceable>value</replaceable> <replaceable>&amp;key</replaceable> <replaceable>errorp</replaceable> <replaceable>&#8658;</replaceable> <replaceable>keyword</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>An <literal>enum</literal> type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>errorp</replaceable>
</term><listitem><para>If true (the default), signal an error if <replaceable>value</replaceable> is not defined
in <replaceable>type</replaceable>.  If false, <literal>foreign-enum-keyword</literal> returns
<literal>nil</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>keyword</replaceable>
</term><listitem><para>A keyword symbol.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-enum-keyword</literal> returns the keyword symbol
that corresponds to <replaceable>value</replaceable> in <replaceable>type</replaceable>.
</para>
<para>An error is signaled if <replaceable>type</replaceable> doesn&#8217;t contain such <replaceable>value</replaceable>
and <replaceable>errorp</replaceable> is true.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcenum boolean
  :no
  :yes)

CFFI&gt; (foreign-enum-keyword 'boolean 1)
&#8658; :YES
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcenum">defcenum</link> 

<link linkend="foreign_002denum_002dvalue">foreign-enum-value</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-ENUM-VALUE -->

<anchor id="foreign_002denum_002dvalue"/>
<bridgehead renderas="sect1">foreign-enum-value</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-enum-value</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-enum-value</function> <replaceable>type</replaceable> <replaceable>keyword</replaceable> <replaceable>&amp;key</replaceable> <replaceable>errorp</replaceable> <replaceable>&#8658;</replaceable> <replaceable>value</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>An <literal>enum</literal> type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>keyword</replaceable>
</term><listitem><para>A keyword symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>errorp</replaceable>
</term><listitem><para>If true (the default), signal an error if <replaceable>keyword</replaceable> is not
defined in <replaceable>type</replaceable>.  If false, <literal>foreign-enum-value</literal> returns
<literal>nil</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>value</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-enum-value</literal> returns the <replaceable>value</replaceable> that
corresponds to <replaceable>keyword</replaceable> in <replaceable>type</replaceable>.
</para>
<para>An error is signaled if <replaceable>type</replaceable> doesn&#8217;t contain such
<replaceable>keyword</replaceable>, and <replaceable>errorp</replaceable> is true.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcenum boolean
  :no
  :yes)

CFFI&gt; (foreign-enum-value 'boolean :yes)
&#8658; 1
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcenum">defcenum</link> 

<link linkend="foreign_002denum_002dkeyword">foreign-enum-keyword</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-NAMES -->

<anchor id="foreign_002dslot_002dnames"/>
<bridgehead renderas="sect1">foreign-slot-names</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-slot-names</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-slot-names</function> <replaceable>type</replaceable> <replaceable>&#8658;</replaceable> <replaceable>names</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign struct type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>names</replaceable>
</term><listitem><para>A list.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-slot-names</literal> returns a potentially shared
list of slot <replaceable>names</replaceable> for the given structure <replaceable>type</replaceable>. This list
has no particular order.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct timeval
  (tv-secs :long)
  (tv-usecs :long))

CFFI&gt; (foreign-slot-names '(:struct timeval))
&#8658; (TV-SECS TV-USECS)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcstruct">defcstruct</link> 

<link linkend="foreign_002dslot_002doffset">foreign-slot-offset</link> 

<link linkend="foreign_002dslot_002dvalue">foreign-slot-value</link> 

<link linkend="foreign_002dslot_002dpointer">foreign-slot-pointer</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-OFFSET -->

<anchor id="foreign_002dslot_002doffset"/>
<bridgehead renderas="sect1">foreign-slot-offset</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-slot-offset</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-slot-offset</function> <replaceable>type</replaceable> <replaceable>slot-name</replaceable> <replaceable>&#8658;</replaceable> <replaceable>offset</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign struct type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-name</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>offset</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-slot-offset</literal> returns the <replaceable>offset</replaceable> in
bytes of a slot in a foreign struct type.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct timeval
  (tv-secs :long)
  (tv-usecs :long))

CFFI&gt; (foreign-slot-offset '(:struct timeval) 'tv-secs)
&#8658; 0
CFFI&gt; (foreign-slot-offset '(:struct timeval) 'tv-usecs)
&#8658; 4
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcstruct">defcstruct</link> 

<link linkend="foreign_002dslot_002dnames">foreign-slot-names</link> 

<link linkend="foreign_002dslot_002dpointer">foreign-slot-pointer</link> 

<link linkend="foreign_002dslot_002dvalue">foreign-slot-value</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-POINTER -->

<anchor id="foreign_002dslot_002dpointer"/>
<bridgehead renderas="sect1">foreign-slot-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-slot-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-slot-pointer</function> <replaceable>ptr</replaceable> <replaceable>type</replaceable> <replaceable>slot-name</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A pointer to a structure.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign structure type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-names</replaceable>
</term><listitem><para>A slot name in the <replaceable>type</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A pointer to the slot <replaceable>slot-name</replaceable>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>Returns a pointer to the location of the slot <replaceable>slot-name</replaceable> in a
foreign object of type <replaceable>type</replaceable> at <replaceable>ptr</replaceable>. The returned pointer
points inside the structure. Both the pointer and the memory it points
to have the same extent as <replaceable>ptr</replaceable>.
</para>
<para>For aggregate slots, this is the same value returned by
<literal>foreign-slot-value</literal>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct point
  &quot;Pointer structure.&quot;
  (x :int)
  (y :int))

CFFI&gt; (with-foreign-object (ptr '(:struct point))
        (foreign-slot-pointer ptr '(:struct point) 'x))
&#8658; #&lt;FOREIGN-ADDRESS #xBFFF6E60&gt;
;; Note: the exact pointer representation varies from lisp to lisp.
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcstruct">defcstruct</link> 

<link linkend="foreign_002dslot_002dvalue">foreign-slot-value</link> 

<link linkend="foreign_002dslot_002dnames">foreign-slot-names</link> 

<link linkend="foreign_002dslot_002doffset">foreign-slot-offset</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-VALUE -->

<anchor id="foreign_002dslot_002dvalue"/>
<bridgehead renderas="sect1">foreign-slot-value</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-slot-value</primary></indexterm><phrase role="category"><emphasis role="bold">Accessor</emphasis>:</phrase> <function>foreign-slot-value</function> <replaceable>ptr</replaceable> <replaceable>type</replaceable> <replaceable>slot-name</replaceable> <replaceable>&#8658;</replaceable> <replaceable>object</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A pointer to a structure.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign structure type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>slot-name</replaceable>
</term><listitem><para>A symbol naming a slot in the structure type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>object</replaceable>
</term><listitem><para>The object contained in the slot specified by <replaceable>slot-name</replaceable>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>For simple slots, <literal>foreign-slot-value</literal> returns the value of the
object, such as a Lisp integer or pointer. In C, this would be
expressed as <literal>ptr-&gt;slot</literal>.
</para>
<para>For aggregate slots, a pointer inside the structure to the beginning
of the slot&#8217;s data is returned. In C, this would be expressed as
<literal>&amp;ptr-&gt;slot</literal>. This pointer and the memory it points to have the
same extent as <replaceable>ptr</replaceable>.
</para>
<para>There are compiler macros for <literal>foreign-slot-value</literal> and its
<literal>setf</literal> expansion that open code the memory access when
<replaceable>type</replaceable> and <replaceable>slot-names</replaceable> are constant at compile-time.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct point
  &quot;Pointer structure.&quot;
  (x :int)
  (y :int))

CFFI&gt; (with-foreign-object (ptr '(:struct point))
        ;; Initialize the slots
        (setf (foreign-slot-value ptr '(:struct point) 'x) 42
              (foreign-slot-value ptr '(:struct point) 'y) 42)
        ;; Return a list with the coordinates
        (with-foreign-slots ((x y) ptr (:struct point))
          (list x y)))
&#8658; (42 42)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcstruct">defcstruct</link> 

<link linkend="foreign_002dslot_002dnames">foreign-slot-names</link> 

<link linkend="foreign_002dslot_002doffset">foreign-slot-offset</link> 

<link linkend="foreign_002dslot_002dpointer">foreign-slot-pointer</link> 

<link linkend="with_002dforeign_002dslots">with-foreign-slots</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-TYPE-ALIGNMENT -->

<anchor id="foreign_002dtype_002dalignment"/>
<bridgehead renderas="sect1">foreign-type-alignment</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<!-- XXX: This is actually a generic function. -->
<synopsis><indexterm role="fn"><primary>foreign-type-alignment</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-type-alignment</function> <replaceable>type</replaceable> <replaceable>&#8658;</replaceable> <replaceable>alignment</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>alignment</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-type-alignment</literal> returns the
<replaceable>alignment</replaceable> of <replaceable>type</replaceable> in bytes.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>CFFI&gt; (foreign-type-alignment :char)
&#8658; 1
CFFI&gt; (foreign-type-alignment :short)
&#8658; 2
CFFI&gt; (foreign-type-alignment :int)
&#8658; 4
</programlisting>
<programlisting>(defcstruct foo
  (a :char))

CFFI&gt; (foreign-type-alignment '(:struct foo))
&#8658; 1
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dtype_002dsize">foreign-type-size</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-TYPE-SIZE -->

<anchor id="foreign_002dtype_002dsize"/>
<bridgehead renderas="sect1">foreign-type-size</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<!-- XXX: this is actually a generic function. -->
<synopsis><indexterm role="fn"><primary>foreign-type-size</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-type-size</function> <replaceable>type</replaceable> <replaceable>&#8658;</replaceable> <replaceable>size</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>size</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-type-size</literal> return the <replaceable>size</replaceable> of
<replaceable>type</replaceable> in bytes.  This includes any padding within and following
the in-memory representation as needed to create an array of
<replaceable>type</replaceable> objects.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct foo
  (a :double)
  (c :char))

CFFI&gt; (foreign-type-size :double)
&#8658; 8
CFFI&gt; (foreign-type-size :char)
&#8658; 1
CFFI&gt; (foreign-type-size '(:struct foo))
&#8658; 16
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dtype_002dalignment">foreign-type-alignment</link>
</para>

<!-- =================================================================== -->
<!-- FREE-CONVERTED-OBJECT -->

<anchor id="free_002dconverted_002dobject"/>
<bridgehead renderas="sect1">free-converted-object</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>free-converted-object</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>free-converted-object</function> <replaceable>foreign-value</replaceable> <replaceable>type</replaceable> <replaceable>params</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-value</replaceable>
</term><listitem><para>The C object to be freed.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A <acronym>CFFI</acronym> type specifier.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>params</replaceable>
</term><listitem><para>The state returned as the second value from <literal>convert-to-foreign</literal>;
used to implement the third argument to <literal>free-translated-object</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<para>The return value is unspecified.
</para>
<para>This is an external interface to the type translation facility.  In
the implementation, all foreign functions are ultimately defined as
type translation wrappers around primitive foreign function
invocations.
</para>
<para>This function is available mostly for inspection of the type
translation process, and possibly optimization of special cases of
your foreign function calls.
</para>
<para>Its behavior is better described under <literal>free-translated-object</literal>&#8217;s
documentation.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI-USER&gt; (convert-to-foreign &quot;a boat&quot; :string)
&#8658; #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
&#8658; T
CFFI-USER&gt; (free-converted-object * :string t)
&#8658; NIL
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="convert_002dfrom_002dforeign">convert-from-foreign</link> 

<link linkend="convert_002dto_002dforeign">convert-to-foreign</link> 

<link linkend="free_002dtranslated_002dobject">free-translated-object</link>
</para>

<!-- =================================================================== -->
<!-- FREE-TRANSLATED-OBJECT -->

<!-- TODO: update -->

<anchor id="free_002dtranslated_002dobject"/>
<bridgehead renderas="sect1">free-translated-object</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>free-translated-object</primary></indexterm><phrase role="category"><emphasis role="bold">Generic Function</emphasis>:</phrase> <function>free-translated-object</function> <replaceable>value</replaceable> <replaceable>type-name</replaceable> <replaceable>param</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>The foreign value returned by <literal>translate-to-foreign</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type-name</replaceable>
</term><listitem><para>A symbol naming a foreign type defined by <literal>defctype</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>param</replaceable>
</term><listitem><para>The second value, if any, returned by <literal>translate-to-foreign</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>This generic function may be specialized by user code to perform
automatic deallocation of foreign objects as they are passed to C
functions.
</para>
<para>Any methods defined on this generic function must EQL-specialize the
<replaceable>type-name</replaceable> parameter on a symbol defined as a foreign type by
the <literal>defctype</literal> macro.
</para>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="Foreign-Type-Translators">Foreign Type Translators</link> 

<link linkend="translate_002dto_002dforeign">translate-to-foreign</link>
</para>

<!-- =================================================================== -->
<!-- TRANSLATE-FROM-FOREIGN -->

<!-- TODO: update -->

<anchor id="translate_002dfrom_002dforeign"/>
<bridgehead renderas="sect1">translate-from-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-from-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Generic Function</emphasis>:</phrase> <function>translate-from-foreign</function> <replaceable>foreign-value</replaceable> <replaceable>type-name</replaceable>                                         <replaceable>&#8658;</replaceable> <replaceable>lisp-value</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-value</replaceable>
</term><listitem><para>The foreign value to convert to a Lisp object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type-name</replaceable>
</term><listitem><para>A symbol naming a foreign type defined by <literal>defctype</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>lisp-value</replaceable>
</term><listitem><para>The lisp value to pass in place of <literal>foreign-value</literal> to Lisp code.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>This generic function is invoked by <acronym>CFFI</acronym> to convert a foreign value to
a Lisp value, such as when returning from a foreign function, passing
arguments to a callback function, or accessing a foreign variable.
</para>
<para>To extend the <acronym>CFFI</acronym> type system by performing custom translations, this
method may be specialized by EQL-specializing <literal>type-name</literal> on a
symbol naming a foreign type defined with <literal>defctype</literal>.  This
method should return the appropriate Lisp value to use in place of the
foreign value.
</para>
<para>The results are undefined if the <literal>type-name</literal> parameter is
specialized in any way except an EQL specializer on a foreign type
defined with <literal>defctype</literal>.  Specifically, translations may not be
defined for built-in types.
</para>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="Foreign-Type-Translators">Foreign Type Translators</link> 

<link linkend="translate_002dto_002dforeign">translate-to-foreign</link> 

<link linkend="free_002dtranslated_002dobject">free-translated-object</link>
</para>

<!-- =================================================================== -->
<!-- TRANSLATE-TO-FOREIGN -->

<!-- TODO: update -->

<anchor id="translate_002dto_002dforeign"/>
<bridgehead renderas="sect1">translate-to-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-to-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Generic Function</emphasis>:</phrase> <function>translate-to-foreign</function> <replaceable>lisp-value</replaceable> <replaceable>type-name</replaceable>                                       <replaceable>&#8658;</replaceable> <replaceable>foreign-value</replaceable>, <replaceable>alloc-param</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>lisp-value</replaceable>
</term><listitem><para>The Lisp value to convert to foreign representation.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type-name</replaceable>
</term><listitem><para>A symbol naming a foreign type defined by <literal>defctype</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>foreign-value</replaceable>
</term><listitem><para>The foreign value to pass in place of <literal>lisp-value</literal> to foreign code.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>alloc-param</replaceable>
</term><listitem><para>If present, this value will be passed to
<literal>free-translated-object</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>This generic function is invoked by <acronym>CFFI</acronym> to convert a Lisp value to a
foreign value, such as when passing arguments to a foreign function,
returning a value from a callback, or setting a foreign variable.  A
&#8220;foreign value&#8221; is one appropriate for passing to the next-lowest
translator, including the low-level translators that are ultimately
invoked invisibly with <acronym>CFFI</acronym>.
</para>
<para>To extend the <acronym>CFFI</acronym> type system by performing custom translations, this
method may be specialized by EQL-specializing <literal>type-name</literal> on a
symbol naming a foreign type defined with <literal>defctype</literal>.  This
method should return the appropriate foreign value to use in place of
the Lisp value.
</para>
<para>In cases where <acronym>CFFI</acronym> can determine the lifetime of the foreign object
returned by this method, it will invoke <literal>free-translated-object</literal>
on the foreign object at the appropriate time.  If
<literal>translate-to-foreign</literal> returns a second value, it will be passed
as the <literal>param</literal> argument to <literal>free-translated-object</literal>.  This
can be used to establish communication between the allocation and
deallocation methods.
</para>
<para>The results are undefined if the <literal>type-name</literal> parameter is
specialized in any way except an EQL specializer on a foreign type
defined with <literal>defctype</literal>.  Specifically, translations may not be
defined for built-in types.
</para>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="Foreign-Type-Translators">Foreign Type Translators</link> 

<link linkend="translate_002dfrom_002dforeign">translate-from-foreign</link> 

<link linkend="free_002dtranslated_002dobject">free-translated-object</link>
</para>

<!-- =================================================================== -->
<!-- TRANSLATE-INTO-FOREIGN-MEMORY -->

<anchor id="translate_002dinto_002dforeign_002dmemory"/>
<bridgehead renderas="sect1">translate-into-foreign-memory</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-into-foreign-memory</primary></indexterm><phrase role="category"><emphasis role="bold">Generic Function</emphasis>:</phrase> <function>translate-into-foreign-memory</function> <replaceable>lisp-value</replaceable> <replaceable>type-name</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>lisp-value</replaceable>
</term><listitem><para>The Lisp value to convert to foreign representation.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type-name</replaceable>
</term><listitem><para>A symbol or list <literal>(:struct <replaceable>structure-name</replaceable>)</literal> naming a foreign type defined by <literal>defctype</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>The foreign pointer where the translated object should be stored.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>Translate the Lisp value into the foreign memory location given by
pointer.  The return value is not used.
</para>
<!-- =================================================================== -->
<!-- WITH-FOREIGN-SLOTS -->

<anchor id="with_002dforeign_002dslots"/>
<bridgehead renderas="sect1">with-foreign-slots</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>with-foreign-slots</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-slots</function> (<replaceable>vars</replaceable> <replaceable>ptr</replaceable> <replaceable>type</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>vars</replaceable>
</term><listitem><para>A list with each element a symbol, or list of length two with the
first element <literal>:pointer</literal> and the second a symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer to a structure.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A structure type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>body</replaceable>
</term><listitem><para>A list of forms to be executed.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>with-foreign-slots</literal> macro creates local symbol macros for each
var in <replaceable>vars</replaceable> to reference foreign slots in <replaceable>ptr</replaceable> of <replaceable>type</replaceable>.
If the var is a list starting with <literal>:pointer</literal>, it will bind the
pointer to the slot (rather than the value). It is similar to Common
Lisp&#8217;s <literal>with-slots</literal> macro.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>(defcstruct tm
  (sec :int)
  (min :int)
  (hour :int)
  (mday :int)
  (mon  :int)
  (year :int)
  (wday :int)
  (yday :int)
  (isdst  :boolean)
  (zone   :string)
  (gmtoff :long))

CFFI&gt; (with-foreign-object (time :int)
        (setf (mem-ref time :int)
              (foreign-funcall &quot;time&quot; :pointer (null-pointer) :int))
        (foreign-funcall &quot;gmtime&quot; :pointer time (:pointer (:struct tm))))
&#8658; #&lt;A Mac Pointer #x102A30&gt;
CFFI&gt; (with-foreign-slots ((sec min hour mday mon year) * (:struct tm))
        (format nil &quot;~A:~A:~A, ~A/~A/~A&quot;
                hour min sec (+ 1900 year) mon mday))
&#8658; &quot;7:22:47, 2005/8/2&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcstruct">defcstruct</link> 

<link linkend="defcunion">defcunion</link> 

<link linkend="foreign_002dslot_002dvalue">foreign-slot-value</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Pointers -->

</sect1>
</chapter>
<chapter label="7" id="Pointers">
<title>Pointers</title>

<para>All C data in <acronym>CFFI</acronym> is referenced through pointers.  This includes
defined C variables that hold immediate values, and integers.
</para>
<para>To see why this is, consider the case of the C integer.  It is not
only an arbitrary representation for an integer, congruent to Lisp&#8217;s
fixnums; the C integer has a specific bit pattern in memory defined by
the C <acronym>ABI</acronym>.  Lisp has no such constraint on its fixnums;
therefore, it only makes sense to think of fixnums as C integers if
you assume that <acronym>CFFI</acronym> converts them when necessary, such as when
storing one for use in a C function call, or as the value of a C
variable.  This requires defining an area of memory<footnote><para>The
definition of <firstterm>memory</firstterm> includes the <acronym>CPU</acronym> registers.</para></footnote>,
represented through an effective address, and storing it there.
</para>
<para>Due to this compartmentalization, it only makes sense to manipulate
raw C data in Lisp through pointers to it.  For example, while there
may be a Lisp representation of a <literal>struct</literal> that is converted to C
at store time, you may only manipulate its raw data through a pointer.
The C compiler does this also, albeit informally.
</para>

<sect1 label="7.1" id="Basic-Pointer-Operations">
<title>Basic Pointer Operations</title>

<para>Manipulating pointers proper can be accomplished through most of the
other operations defined in the Pointers dictionary, such as
<literal>make-pointer</literal>, <literal>pointer-address</literal>, and <literal>pointer-eq</literal>.
When using them, keep in mind that they merely manipulate the Lisp
representation of pointers, not the values they point to.
</para>
<synopsis><indexterm role="tp"><primary>foreign-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Lisp Type</emphasis>:</phrase> <structname>foreign-pointer</structname></synopsis>
<blockquote><para>The pointers&#8217; representations differ from implementation to
implementation and have different types.  <literal>foreign-pointer</literal>
provides a portable type alias to each of these types.
</para></blockquote>

</sect1>
<sect1 label="7.2" id="Allocating-Foreign-Memory">
<title>Allocating Foreign Memory</title>

<para><acronym>CFFI</acronym> provides support for stack and heap C memory allocation.
Stack allocation, done with <literal>with-foreign-object</literal>, is sometimes
called &#8220;dynamic&#8221; allocation in Lisp, because memory allocated as
such has dynamic extent, much as with <literal>let</literal> bindings of special
variables.
</para>
<para>This should not be confused with what C calls &#8220;dynamic&#8221; allocation,
or that done with <literal>malloc</literal> and friends.  This sort of heap
allocation is done with <literal>foreign-alloc</literal>, creating objects that
exist until freed with <literal>foreign-free</literal>.
</para>

</sect1>
<sect1 label="7.3" id="Accessing-Foreign-Memory">
<title>Accessing Foreign Memory</title>

<para>When manipulating raw C data, consider that all pointers are pointing
to an array.  When you only want one C value, such as a single
<literal>struct</literal>, this array only has one such value.  It is worthwhile
to remember that everything is an array, though, because this is also
the semantic that C imposes natively.
</para>
<para>C values are accessed as the <literal>setf</literal>-able places defined by
<literal>mem-aref</literal> and <literal>mem-ref</literal>.  Given a pointer and a <acronym>CFFI</acronym>
type (see <link linkend="Foreign-Types">Foreign Types</link>), either of these will dereference the
pointer, translate the C data there back to Lisp, and return the
result of said translation, performing the reverse operation when
<literal>setf</literal>-ing.  To decide which one to use, consider whether you
would use the array index operator <literal>[<replaceable>n</replaceable>]</literal> or the pointer
dereference <literal>*</literal> in C; use <literal>mem-aref</literal> for array indexing and
<literal>mem-ref</literal> for pointer dereferencing.
</para>

<!-- =================================================================== -->
<!-- FOREIGN-FREE -->

<anchor id="foreign_002dfree"/>
<bridgehead renderas="sect1">foreign-free</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-free</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-free</function> <replaceable>ptr</replaceable> <replaceable>&#8658;</replaceable> <replaceable>undefined</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-free</literal> function frees a <literal>ptr</literal> previously
allocated by <literal>foreign-alloc</literal>. The consequences of freeing a given
pointer twice are undefined.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-alloc :int)
&#8658; #&lt;A Mac Pointer #x1022E0&gt;
CFFI&gt; (foreign-free *)
&#8658; NIL
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dalloc">foreign-alloc</link> 

<link linkend="with_002dforeign_002dpointer">with-foreign-pointer</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-ALLOC -->

<anchor id="foreign_002dalloc"/>
<bridgehead renderas="sect1">foreign-alloc</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-alloc</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-alloc</function> <replaceable>type</replaceable> <replaceable>&amp;key</replaceable> <replaceable>initial-element</replaceable> <replaceable>initial-contents</replaceable> (<replaceable>count</replaceable> <replaceable>1</replaceable>)                         <replaceable>null-terminated-p</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>initial-element</replaceable>
</term><listitem><para>A Lisp object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>initial-contents</replaceable>
</term><listitem><para>A sequence.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>count</replaceable>
</term><listitem><para>An integer. Defaults to 1 or the length of <replaceable>initial-contents</replaceable> if
supplied.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>null-terminated-p</replaceable>
</term><listitem><para>A boolean, false by default.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A foreign pointer to the newly allocated memory.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-alloc</literal> function allocates enough memory to hold
<replaceable>count</replaceable> objects of type <replaceable>type</replaceable> and returns a
<replaceable>pointer</replaceable>. This memory must be explicitly freed using
<literal>foreign-free</literal> once it is no longer needed.
</para>
<para>If <replaceable>initial-element</replaceable> is supplied, it is used to initialize the
<replaceable>count</replaceable> objects the newly allocated memory holds.
</para>
<para>If an <replaceable>initial-contents</replaceable> sequence is supplied, it must have a
length less than or equal to <replaceable>count</replaceable> and each of its elements
will be used to initialize the contents of the newly allocated
memory.
</para>
<para>If <replaceable>count</replaceable> is omitted and <replaceable>initial-contents</replaceable> is specified, it
will default to <literal>(length <replaceable>initial-contents</replaceable>)</literal>.
</para>
<para><replaceable>initial-element</replaceable> and <replaceable>initial-contents</replaceable> are mutually
exclusive.
</para>
<para>When <replaceable>null-terminated-p</replaceable> is true,
<literal>(1+ (max <replaceable>count</replaceable> (length <replaceable>initial-contents</replaceable>)))</literal> elements
are allocated and the last one is set to <literal>NULL</literal>. Note that in
this case <replaceable>type</replaceable> must be a pointer type (ie. a type that
canonicalizes to <literal>:pointer</literal>), otherwise an error is signaled.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<programlisting>CFFI&gt; (foreign-alloc :char)
&#8658; #&lt;A Mac Pointer #x102D80&gt;     ; A pointer to 1 byte of memory.

CFFI&gt; (foreign-alloc :char :count 20)
&#8658; #&lt;A Mac Pointer #x1024A0&gt;     ; A pointer to 20 bytes of memory.

CFFI&gt; (foreign-alloc :int :initial-element 12)
&#8658; #&lt;A Mac Pointer #x1028B0&gt;
CFFI&gt; (mem-ref * :int)
&#8658; 12

CFFI&gt; (foreign-alloc :int :initial-contents '(1 2 3))
&#8658; #&lt;A Mac Pointer #x102950&gt;
CFFI&gt; (loop for i from 0 below 3
            collect (mem-aref * :int i))
&#8658; (1 2 3)

CFFI&gt; (foreign-alloc :int :initial-contents #(1 2 3))
&#8658; #&lt;A Mac Pointer #x102960&gt;
CFFI&gt; (loop for i from 0 below 3
            collect (mem-aref * :int i))
&#8658; (1 2 3)

;;; Allocate a char** pointer that points to newly allocated memory
;;; by the :string type translator for the string &quot;foo&quot;.
CFFI&gt; (foreign-alloc :string :initial-element &quot;foo&quot;)
&#8658; #&lt;A Mac Pointer #x102C40&gt;
</programlisting>
<programlisting>;;; Allocate a null-terminated array of strings.
;;; (Note: FOREIGN-STRING-TO-LISP returns NIL when passed a null pointer)
CFFI&gt; (foreign-alloc :string
                     :initial-contents '(&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)
                     :null-terminated-p t)
&#8658; #&lt;A Mac Pointer #x102D20&gt;
CFFI&gt; (loop for i from 0 below 4
            collect (mem-aref * :string i))
&#8658; (&quot;foo&quot; &quot;bar&quot; &quot;baz&quot; NIL)
CFFI&gt; (progn
        (dotimes (i 3)
          (foreign-free (mem-aref ** :pointer i)))
        (foreign-free **))
&#8658; nil
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dfree">foreign-free</link> 

<link linkend="with_002dforeign_002dobject">with-foreign-object</link> 

<link linkend="with_002dforeign_002dpointer">with-foreign-pointer</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-SYMBOL-POINTER -->

<anchor id="foreign_002dsymbol_002dpointer"/>
<bridgehead renderas="sect1">foreign-symbol-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-symbol-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-symbol-pointer</function> <replaceable>foreign-name</replaceable> <replaceable>&amp;key</replaceable> <replaceable>library</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-name</replaceable>
</term><listitem><para>A string.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A foreign pointer, or <literal>nil</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>library</replaceable>
</term><listitem><para>A Lisp symbol or an instance of <literal>foreign-library</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>foreign-symbol-pointer</literal> will return a foreign
pointer corresponding to the foreign symbol denoted by the string
<replaceable>foreign-name</replaceable>.  If a foreign symbol named <replaceable>foreign-name</replaceable>
doesn&#8217;t exist, <literal>nil</literal> is returned.
</para>
<para>ABI name manglings will be performed on <replaceable>foreign-name</replaceable> by
<literal>foreign-symbol-pointer</literal> if necessary. (eg: adding a leading
underscore on darwin/ppc)
</para>
<para><replaceable>library</replaceable> should name a foreign library as defined by
<literal>define-foreign-library</literal>, <literal>:default</literal> (which is the default)
or an instance of <literal>foreign-library</literal> as returned by
<literal>load-foreign-library</literal>.
</para>
<para><emphasis role="bold">Important note:</emphasis> do not keep these pointers across saved Lisp
cores as the foreign-library may move across sessions.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-symbol-pointer &quot;errno&quot;)
&#8658; #&lt;A Mac Pointer #xA0008130&gt;
CFFI&gt; (foreign-symbol-pointer &quot;strerror&quot;)
&#8658; #&lt;A Mac Pointer #x9002D0F8&gt;
CFFI&gt; (foreign-funcall-pointer * () :int (mem-ref ** :int) :string)
&#8658; &quot;No such file or directory&quot;

CFFI&gt; (foreign-symbol-pointer &quot;inexistent symbol&quot;)
&#8658; NIL
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcvar">defcvar</link>
</para>

<!-- =================================================================== -->
<!-- INC-POINTER -->

<anchor id="inc_002dpointer"/>
<bridgehead renderas="sect1">inc-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>inc-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>inc-pointer</function> <replaceable>pointer</replaceable> <replaceable>offset</replaceable> <replaceable>&#8658;</replaceable> <replaceable>new-pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>pointer</replaceable>
</term><term><replaceable>new-pointer</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>offset</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>inc-pointer</literal> will return a <replaceable>new-pointer</replaceable> pointing
<replaceable>offset</replaceable> bytes past <replaceable>pointer</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-string-alloc &quot;Common Lisp&quot;)
&#8658; #&lt;A Mac Pointer #x102EA0&gt;
CFFI&gt; (inc-pointer * 7)
&#8658; #&lt;A Mac Pointer #x102EA7&gt;
CFFI&gt; (foreign-string-to-lisp *)
&#8658; &quot;Lisp&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="incf_002dpointer">incf-pointer</link> 

<link linkend="make_002dpointer">make-pointer</link> 

<link linkend="pointerp">pointerp</link> 

<link linkend="null_002dpointer">null-pointer</link> 

<link linkend="null_002dpointer_002dp">null-pointer-p</link>
</para>

<!-- =================================================================== -->
<!-- INCF-POINTER -->

<anchor id="incf_002dpointer"/>
<bridgehead renderas="sect1">incf-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>incf-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>incf-pointer</function> <replaceable>place</replaceable> <replaceable>&amp;optional</replaceable> (<replaceable>offset</replaceable> <replaceable>1</replaceable>) <replaceable>&#8658;</replaceable> <replaceable>new-pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>place</replaceable>
</term><listitem><para>A <literal>setf</literal> place.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>new-pointer</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>offset</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>incf-pointer</literal> macro takes the foreign pointer from
<replaceable>place</replaceable> and creates a <replaceable>new-pointer</replaceable> incremented by
<replaceable>offset</replaceable> bytes and which is stored in <replaceable>place</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defparameter *two-words* (foreign-string-alloc &quot;Common Lisp&quot;))
&#8658; *TWO-WORDS*
CFFI&gt; (defparameter *one-word* *two-words*)
&#8658; *ONE-WORD*
CFFI&gt; (incf-pointer *one-word* 7)
&#8658; #.(SB-SYS:INT-SAP #X00600457)
CFFI&gt; (foreign-string-to-lisp *one-word*)
&#8658; &quot;Lisp&quot;
CFFI&gt; (foreign-string-to-lisp *two-words*)
&#8658; &quot;Common Lisp&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="inc_002dpointer">inc-pointer</link> 

<link linkend="make_002dpointer">make-pointer</link> 

<link linkend="pointerp">pointerp</link> 

<link linkend="null_002dpointer">null-pointer</link> 

<link linkend="null_002dpointer_002dp">null-pointer-p</link>
</para>

<!-- =================================================================== -->
<!-- MAKE-POINTER -->

<anchor id="make_002dpointer"/>
<bridgehead renderas="sect1">make-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>make-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>make-pointer</function> <replaceable>address</replaceable> <replaceable>&#8658;</replaceable> <replaceable>ptr</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>address</replaceable>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>make-pointer</literal> will return a foreign pointer
pointing to <replaceable>address</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (make-pointer 42)
&#8658; #&lt;FOREIGN-ADDRESS #x0000002A&gt;
CFFI&gt; (pointerp *)
&#8658; T
CFFI&gt; (pointer-address **)
&#8658; 42
CFFI&gt; (inc-pointer *** -42)
&#8658; #&lt;FOREIGN-ADDRESS #x00000000&gt;
CFFI&gt; (null-pointer-p *)
&#8658; T
CFFI&gt; (typep ** 'foreign-pointer)
&#8658; T
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="inc_002dpointer">inc-pointer</link> 

<link linkend="null_002dpointer">null-pointer</link> 

<link linkend="null_002dpointer_002dp">null-pointer-p</link> 

<link linkend="pointerp">pointerp</link> 

<link linkend="pointer_002daddress">pointer-address</link> 

<link linkend="pointer_002deq">pointer-eq</link> 

<link linkend="mem_002dref">mem-ref</link>
</para>

<!-- =================================================================== -->
<!-- MEM-APTR -->

<anchor id="mem_002daptr"/>
<bridgehead renderas="sect1">mem-aptr</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>mem-aptr</primary></indexterm><phrase role="category"><emphasis role="bold">Accessor</emphasis>:</phrase> <function>mem-aptr</function> <replaceable>ptr</replaceable> <replaceable>type</replaceable> <replaceable>&amp;optional</replaceable> (<replaceable>index</replaceable> <replaceable>0</replaceable>)</synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>index</replaceable>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>new-value</replaceable>
</term><listitem><para>A Lisp value compatible with <replaceable>type</replaceable>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>mem-aptr</literal> function finds the pointer to an element of the array.
</para>
<programlisting>(mem-aptr ptr type n)

;; is identical to:

(inc-pointer ptr (* n (foreign-type-size type)))
</programlisting>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-string (str &quot;Hello, foreign world!&quot;)
        (mem-aptr str :char 6))
&#8658; #.(SB-SYS:INT-SAP #X0063D4B6)
</programlisting>
<!-- =================================================================== -->
<!-- MEM-AREF -->

<anchor id="mem_002daref"/>
<bridgehead renderas="sect1">mem-aref</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>mem-aref</primary></indexterm><phrase role="category"><emphasis role="bold">Accessor</emphasis>:</phrase> <function>mem-aref</function> <replaceable>ptr</replaceable> <replaceable>type</replaceable> <replaceable>&amp;optional</replaceable> (<replaceable>index</replaceable> <replaceable>0</replaceable>)</synopsis>

<para>(setf (<emphasis role="bold">mem-aref</emphasis> <emphasis>ptr type &amp;optional (index 0)) new-value</emphasis>)
</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>index</replaceable>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>new-value</replaceable>
</term><listitem><para>A Lisp value compatible with <replaceable>type</replaceable>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>mem-aref</literal> function is similar to <literal>mem-ref</literal> but will
automatically calculate the offset from an <replaceable>index</replaceable>.
</para>
<programlisting>(mem-aref ptr type n)

;; is identical to:

(mem-ref ptr type (* n (foreign-type-size type)))
</programlisting>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-string (str &quot;Hello, foreign world!&quot;)
        (mem-aref str :char 6))
&#8658; 32
CFFI&gt; (code-char *)
&#8658; #\Space

CFFI&gt; (with-foreign-object (array :int 10)
        (loop for i below 10
              do (setf (mem-aref array :int i) (random 100)))
        (loop for i below 10 collect (mem-aref array :int i)))
&#8658; (22 7 22 52 69 1 46 93 90 65)
</programlisting>
<bridgehead renderas="sect2">Compatibility Note</bridgehead>

<para>For compatibility with older versions of CFFI, <link linkend="mem_002daref">mem-aref</link> will
produce a pointer for the deprecated bare structure specification, but
it is consistent with other types for the current specification form
<literal>(:struct <replaceable>structure-name</replaceable>)</literal> and provides a Lisp object
translated from the structure (by default a plist).  In order to obtain
the pointer, you should use the new function <link linkend="mem_002daptr">mem-aptr</link>.
</para>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="mem_002dref">mem-ref</link> 

<link linkend="mem_002daptr">mem-aptr</link>
</para>
<!-- =================================================================== -->
<!-- MEM-REF -->

<anchor id="mem_002dref"/>
<bridgehead renderas="sect1">mem-ref</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>mem-ref</primary></indexterm><phrase role="category"><emphasis role="bold">Accessor</emphasis>:</phrase> <function>mem-ref</function> <replaceable>ptr</replaceable> <replaceable>type</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>offset</replaceable> <replaceable>&#8658;</replaceable> <replaceable>object</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>offset</replaceable>
</term><listitem><para>An integer (in byte units).
</para>
</listitem></varlistentry><varlistentry><term><replaceable>object</replaceable>
</term><listitem><para>The value <replaceable>ptr</replaceable> points to.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-string (ptr &quot;Saluton&quot;)
        (setf (mem-ref ptr :char 3) (char-code #\a))
        (loop for i from 0 below 8
              collect (code-char (mem-ref ptr :char i))))
&#8658; (#\S #\a #\l #\a #\t #\o #\n #\Null)
CFFI&gt; (setq ptr-to-int (foreign-alloc :int))
&#8658; #&lt;A Mac Pointer #x1047D0&gt;
CFFI&gt; (mem-ref ptr-to-int :int)
&#8658; 1054619
CFFI&gt; (setf (mem-ref ptr-to-int :int) 1984)
&#8658; 1984
CFFI&gt; (mem-ref ptr-to-int :int)
&#8658; 1984
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="mem_002daref">mem-aref</link>
</para>

<!-- =================================================================== -->
<!-- NULL-POINTER -->

<anchor id="null_002dpointer"/>
<bridgehead renderas="sect1">null-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>null-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>null-pointer</function> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A <literal>NULL</literal> pointer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>null-pointer</literal> returns a null pointer.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (null-pointer)
&#8658; #&lt;A Null Mac Pointer&gt;
CFFI&gt; (pointerp *)
&#8658; T
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="null_002dpointer_002dp">null-pointer-p</link> 

<link linkend="make_002dpointer">make-pointer</link>
</para>

<!-- =================================================================== -->
<!-- NULL-POINTER-P -->

<anchor id="null_002dpointer_002dp"/>
<bridgehead renderas="sect1">null-pointer-p</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>null-pointer-p</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>null-pointer-p</function> <replaceable>ptr</replaceable> <replaceable>&#8658;</replaceable> <replaceable>boolean</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer that may be a null pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>boolean</replaceable>
</term><listitem><para><literal>T</literal> or <literal>NIL</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>null-pointer-p</literal> returns true if <replaceable>ptr</replaceable> is a null
pointer and false otherwise.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (null-pointer-p (null-pointer))
&#8658; T
</programlisting>
<programlisting>(defun contains-str-p (big little)
  (not (null-pointer-p
        (foreign-funcall &quot;strstr&quot; :string big :string little :pointer))))

CFFI&gt; (contains-str-p &quot;Popcorns&quot; &quot;corn&quot;)
&#8658; T
CFFI&gt; (contains-str-p &quot;Popcorns&quot; &quot;salt&quot;)
&#8658; NIL
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="null_002dpointer">null-pointer</link> 

<link linkend="pointerp">pointerp</link>
</para>

<!-- =================================================================== -->
<!-- POINTERP -->

<anchor id="pointerp"/>
<bridgehead renderas="sect1">pointerp</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>pointerp</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>pointerp</function> <replaceable>ptr</replaceable> <replaceable>&#8658;</replaceable> <replaceable>boolean</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>An object that may be a foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>boolean</replaceable>
</term><listitem><para><literal>T</literal> or <literal>NIL</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>pointerp</literal> returns true if <replaceable>ptr</replaceable> is a foreign
pointer and false otherwise.
</para>
<bridgehead renderas="sect2">Implementation-specific Notes</bridgehead>
<para>In Allegro CL, foreign pointers are integers thus in this
implementation <literal>pointerp</literal> will return true for any ordinary integer.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-alloc 32)
&#8658; #&lt;A Mac Pointer #x102D20&gt;
CFFI&gt; (pointerp *)
&#8658; T
CFFI&gt; (pointerp &quot;this is not a pointer&quot;)
&#8658; NIL
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="make_002dpointer">make-pointer</link>
<link linkend="null_002dpointer_002dp">null-pointer-p</link>
</para>

<!-- =================================================================== -->
<!-- POINTER-ADDRESS -->

<anchor id="pointer_002daddress"/>
<bridgehead renderas="sect1">pointer-address</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>pointer-address</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>pointer-address</function> <replaceable>ptr</replaceable> <replaceable>&#8658;</replaceable> <replaceable>address</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>address</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>pointer-address</literal> will return the <replaceable>address</replaceable> of
a foreign pointer <replaceable>ptr</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (pointer-address (null-pointer))
&#8658; 0
CFFI&gt; (pointer-address (make-pointer 123))
&#8658; 123
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="make_002dpointer">make-pointer</link> 

<link linkend="inc_002dpointer">inc-pointer</link> 

<link linkend="null_002dpointer">null-pointer</link> 

<link linkend="null_002dpointer_002dp">null-pointer-p</link> 

<link linkend="pointerp">pointerp</link> 

<link linkend="pointer_002deq">pointer-eq</link> 

<link linkend="mem_002dref">mem-ref</link>
</para>

<!-- =================================================================== -->
<!-- POINTER-EQ -->

<anchor id="pointer_002deq"/>
<bridgehead renderas="sect1">pointer-eq</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>pointer-eq</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>pointer-eq</function> <replaceable>ptr1</replaceable> <replaceable>ptr2</replaceable> <replaceable>&#8658;</replaceable> <replaceable>boolean</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr1</replaceable>
</term><term><replaceable>ptr2</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>boolean</replaceable>
</term><listitem><para><literal>T</literal> or <literal>NIL</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>pointer-eq</literal> returns true if <replaceable>ptr1</replaceable> and
<replaceable>ptr2</replaceable> point to the same memory address and false otherwise.
</para>
<bridgehead renderas="sect2">Implementation-specific Notes</bridgehead>
<para>The representation of foreign pointers varies across the various Lisp
implementations as does the behaviour of the built-in Common Lisp
equality predicates. Comparing two pointers that point to the same
address with <literal>EQ</literal> Lisps will return true on some Lisps, others require
more general predicates like <literal>EQL</literal> or <literal>EQUALP</literal> and finally
some will return false using any of these predicates. Therefore, for
portability, you should use <literal>POINTER-EQ</literal>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>
<para>This is an example using <acronym>SBCL</acronym>, see the
implementation-specific notes above.
</para>
<programlisting>CFFI&gt; (eql (null-pointer) (null-pointer))
&#8658; NIL
CFFI&gt; (pointer-eq (null-pointer) (null-pointer))
&#8658; T
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="inc_002dpointer">inc-pointer</link>
</para>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-OBJECT -->

<anchor id="with_002dforeign_002dobject"/>
<bridgehead renderas="sect1">with-foreign-object, with-foreign-objects</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>with-foreign-object</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-object</function> (<replaceable>var</replaceable> <replaceable>type</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>count</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable></synopsis>

<anchor id="with_002dforeign_002dobjects"/><synopsis><indexterm role="fn"><primary>with-foreign-objects</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-objects</function> (<replaceable>bindings</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable></synopsis>

<para>bindings ::= {(var type &amp;optional count)}* 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>var</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type, evaluated.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>count</replaceable>
</term><listitem><para>An integer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The macros <literal>with-foreign-object</literal> and <literal>with-foreign-objects</literal>
bind <replaceable>var</replaceable> to a pointer to <replaceable>count</replaceable> newly allocated objects
of type <replaceable>type</replaceable> during <replaceable>body</replaceable>. The buffer has dynamic extent
and may be stack allocated if supported by the host Lisp.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-object (array :int 10)
        (dotimes (i 10)
          (setf (mem-aref array :int i) (random 100)))
        (loop for i below 10
              collect (mem-aref array :int i)))
&#8658; (22 7 22 52 69 1 46 93 90 65)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dalloc">foreign-alloc</link>
</para>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-POINTER -->

<anchor id="with_002dforeign_002dpointer"/>
<bridgehead renderas="sect1">with-foreign-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>with-foreign-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-pointer</function> (<replaceable>var</replaceable> <replaceable>size</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>size-var</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>var</replaceable>
</term><term><replaceable>size-var</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>size</replaceable>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>body</replaceable>
</term><listitem><para>A list of forms to be executed.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>with-foreign-pointer</literal> macro, binds <replaceable>var</replaceable> to <replaceable>size</replaceable>
bytes of foreign memory during <replaceable>body</replaceable>. The pointer in <replaceable>var</replaceable>
is invalid beyond the dynamic extend of <replaceable>body</replaceable> and may be
stack-allocated if supported by the implementation.
</para>
<para>If <replaceable>size-var</replaceable> is supplied, it will be bound to <replaceable>size</replaceable> during
<replaceable>body</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-pointer (string 4 size)
        (setf (mem-ref string :char (1- size)) 0)
        (lisp-string-to-foreign &quot;Popcorns&quot; string size)
        (loop for i from 0 below size
              collect (code-char (mem-ref string :char i))))
&#8658; (#\P #\o #\p #\Null)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dalloc">foreign-alloc</link> 

<link linkend="foreign_002dfree">foreign-free</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Strings -->

</sect1>
</chapter>
<chapter label="8" id="Strings">
<title>Strings</title>

<para>As with many languages, Lisp and C have special support for logical
arrays of characters, going so far as to give them a special name,
&#8220;strings&#8221;.  In that spirit, <acronym>CFFI</acronym> provides special support for
translating between Lisp and C strings.
</para>
<para>The <literal>:string</literal> type and the symbols related below also serve as an
example of what you can do portably with <acronym>CFFI</acronym>; were it not
included, you could write an equally functional <filename>strings.lisp</filename>
without referring to any implementation-specific symbols.
</para>


<!-- =================================================================== -->
<!-- *DEFAULT-FOREIGN-ENCODING* -->

<anchor id="_002adefault_002dforeign_002dencoding_002a"/>
<bridgehead renderas="sect1">*default-foreign-encoding*</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>

<synopsis><indexterm role="vr"><primary>*default-foreign-encoding*</primary></indexterm><phrase role="category"><emphasis role="bold">Special Variable</emphasis>:</phrase> <varname>*default-foreign-encoding*</varname></synopsis>

<bridgehead renderas="sect2">Value type</bridgehead>

<para>A keyword.
</para>
<bridgehead renderas="sect2">Initial value</bridgehead>

<para><literal>:utf-8</literal>
</para>
<bridgehead renderas="sect2">Description</bridgehead>

<para>This special variable holds the default foreign encoding.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; *default-foreign-encoding*
:utf-8
CFFI&gt; (foreign-funcall &quot;strdup&quot; (:string :encoding :utf-16) &quot;foo&quot; :string)
&quot;f&quot;
CFFI&gt; (let ((*default-foreign-encoding* :utf-16))
        (foreign-funcall &quot;strdup&quot; (:string :encoding :utf-16) &quot;foo&quot; :string))
&quot;foo&quot;
</programlisting>
<bridgehead renderas="sect2">See also</bridgehead>

<para><link linkend="Other-Types">Other Types</link> (<literal>:string</literal> type) 

<link linkend="foreign_002dstring_002dalloc">foreign-string-alloc</link> 

<link linkend="foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</link> 

<link linkend="lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</link> 

<link linkend="with_002dforeign_002dstring">with-foreign-string</link> 

<link linkend="with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-STRING-ALLOC -->

<anchor id="foreign_002dstring_002dalloc"/>
<bridgehead renderas="sect1">foreign-string-alloc</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-string-alloc</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-string-alloc</function> <replaceable>string</replaceable> <replaceable>&amp;key</replaceable> <replaceable>encoding</replaceable> <replaceable>null-terminated-p</replaceable>                                <replaceable>start</replaceable> <replaceable>end</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><emphasis><replaceable>string</replaceable></emphasis>
</term><listitem><para>A Lisp string.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>encoding</replaceable></emphasis>
</term><listitem><para>Foreign encoding. Defaults to <literal>*default-foreign-encoding*</literal>.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>null-terminated-p</replaceable></emphasis>
</term><listitem><para>Boolean, defaults to true.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>start</replaceable>, <replaceable>end</replaceable></emphasis>
</term><listitem><para>Bounding index designators of <replaceable>string</replaceable>. 0 and <literal>nil</literal>, by
default.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>pointer</replaceable></emphasis>
</term><listitem><para>A pointer to the newly allocated foreign string.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-string-alloc</literal> function allocates foreign memory
holding a copy of <replaceable>string</replaceable> converted using the specified
<replaceable>encoding</replaceable>. <replaceable>Start</replaceable> specifies an offset into <replaceable>string</replaceable> and
<replaceable>end</replaceable> marks the position following the last element of the foreign
string.
</para>
<para>This string must be freed with <literal>foreign-string-free</literal>.
</para>
<para>If <replaceable>null-terminated-p</replaceable> is false, the string will not be
null-terminated.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defparameter *str* (foreign-string-alloc &quot;Hello, foreign world!&quot;))
&#8658; #&lt;FOREIGN-ADDRESS #x00400560&gt;
CFFI&gt; (foreign-funcall &quot;strlen&quot; :pointer *str* :int)
&#8658; 21
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dstring_002dfree">foreign-string-free</link> 

<link linkend="with_002dforeign_002dstring">with-foreign-string</link>
<!-- @seealso{:string} -->
</para>

<!-- =================================================================== -->
<!-- FOREIGN-STRING-FREE -->

<anchor id="foreign_002dstring_002dfree"/>
<bridgehead renderas="sect1">foreign-string-free</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-string-free</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-string-free</function> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A pointer to a string allocated by <literal>foreign-string-alloc</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-string-free</literal> function frees a foreign string
allocated by <literal>foreign-string-alloc</literal>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dstring_002dalloc">foreign-string-alloc</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-STRING-TO-LISP -->

<anchor id="foreign_002dstring_002dto_002dlisp"/>
<bridgehead renderas="sect1">foreign-string-to-lisp</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-string-to-lisp</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>foreign-string-to-lisp</function> <replaceable>ptr</replaceable> <replaceable>&amp;key</replaceable> <replaceable>offset</replaceable> <replaceable>count</replaceable> <replaceable>max-chars</replaceable>                                  <replaceable>encoding</replaceable> <replaceable>&#8658;</replaceable> <replaceable>string</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>ptr</replaceable>
</term><listitem><para>A pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>offset</replaceable>
</term><listitem><para>An integer greater than or equal to 0. Defauls to 0.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>count</replaceable>
</term><listitem><para>Either <literal>nil</literal> (the default), or an integer greater than or equal to 0.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>max-chars</replaceable>
</term><listitem><para>An integer greater than or equal to 0.
<literal>(1- array-total-size-limit)</literal>, by default.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>encoding</replaceable>
</term><listitem><para>Foreign encoding. Defaults to <literal>*default-foreign-encoding*</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>string</replaceable>
</term><listitem><para>A Lisp string.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-string-to-lisp</literal> function converts at most
<replaceable>count</replaceable> octets from <replaceable>ptr</replaceable> into a Lisp string, using the
defined <replaceable>encoding</replaceable>.
</para>
<para>If <replaceable>count</replaceable> is <literal>nil</literal> (the default), characters are copied
until <replaceable>max-chars</replaceable> is reached or a <literal>NULL</literal> character is found.
</para>
<para>If <replaceable>ptr</replaceable> is a null pointer, returns <literal>nil</literal>.
</para>
<para>Note that the <literal>:string</literal> type will automatically convert between
Lisp strings and foreign strings.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-funcall &quot;getenv&quot; :string &quot;HOME&quot; :pointer)
&#8658; #&lt;FOREIGN-ADDRESS #xBFFFFFD5&gt;
CFFI&gt; (foreign-string-to-lisp *)
&#8658; &quot;/Users/luis&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</link> 

<link linkend="foreign_002dstring_002dalloc">foreign-string-alloc</link>
<!-- @seealso{:string} -->
</para>

<!-- =================================================================== -->
<!-- LISP-STRING-TO-FOREIGN -->

<anchor id="lisp_002dstring_002dto_002dforeign"/>
<bridgehead renderas="sect1">lisp-string-to-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>lisp-string-to-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>lisp-string-to-foreign</function> <replaceable>string</replaceable> <replaceable>buffer</replaceable> <replaceable>bufsize</replaceable> <replaceable>&amp;key</replaceable> <replaceable>start</replaceable>                                  <replaceable>end</replaceable> <replaceable>offset</replaceable> <replaceable>encoding</replaceable> <replaceable>&#8658;</replaceable> <replaceable>buffer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><emphasis><replaceable>string</replaceable></emphasis>
</term><listitem><para>A Lisp string.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>buffer</replaceable></emphasis>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>bufsize</replaceable></emphasis>
</term><listitem><para>An integer.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>start</replaceable>, <replaceable>end</replaceable></emphasis>
</term><listitem><para>Bounding index designators of <replaceable>string</replaceable>. 0 and <literal>nil</literal>, by
default.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>offset</replaceable></emphasis>
</term><listitem><para>An integer greater than or equal to 0. Defauls to 0.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>encoding</replaceable></emphasis>
</term><listitem><para>Foreign encoding. Defaults to <literal>*default-foreign-encoding*</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>lisp-string-to-foreign</literal> function copies at most
<replaceable>bufsize</replaceable>-1 octets from a Lisp <replaceable>string</replaceable> using the specified
<replaceable>encoding</replaceable> into <replaceable>buffer</replaceable>+<replaceable>offset</replaceable>. The foreign string will
be null-terminated.
</para>
<para><replaceable>Start</replaceable> specifies an offset into <replaceable>string</replaceable> and
<replaceable>end</replaceable> marks the position following the last element of the foreign
string.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-pointer-as-string (str 255)
        (lisp-string-to-foreign &quot;Hello, foreign world!&quot; str 6))
&#8658; &quot;Hello&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dstring_002dalloc">foreign-string-alloc</link> 

<link linkend="foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</link> 

<link linkend="with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</link>
</para>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-STRING -->

<anchor id="with_002dforeign_002dstring"/>
<bridgehead renderas="sect1">with-foreign-string, with-foreign-strings</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>with-foreign-string</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-string</function> (<replaceable>var-or-vars</replaceable> <replaceable>string</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>args</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable></synopsis>

<anchor id="with_002dforeign_002dstrings"/><synopsis><indexterm role="fn"><primary>with-foreign-strings</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-strings</function> (<replaceable>bindings</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable></synopsis>

<para>var-or-vars ::= var | (var &amp;optional octet-size-var) 

bindings ::= {(var-or-vars string &amp;rest args)}*
</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><emphasis><replaceable>var</replaceable>, <replaceable>byte-size-var</replaceable></emphasis>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>string</replaceable></emphasis>
</term><listitem><para>A Lisp string.
</para>
</listitem></varlistentry><varlistentry><term><emphasis><replaceable>body</replaceable></emphasis>
</term><listitem><para>A list of forms to be executed.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>with-foreign-string</literal> macro will bind <replaceable>var</replaceable> to a newly
allocated foreign string containing <replaceable>string</replaceable>. <replaceable>Args</replaceable> is passed
to the underlying <literal>foreign-string-alloc</literal> call.
</para>
<para>If <replaceable>octet-size-var</replaceable> is provided, it will be bound the length of
foreign string in octets including the null terminator.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-string (foo &quot;12345&quot;)
        (foreign-funcall &quot;strlen&quot; :pointer foo :int))
&#8658; 5
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dstring_002dalloc">foreign-string-alloc</link> 

<link linkend="with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</link>
</para>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-POINTER-AS-STRING -->

<anchor id="with_002dforeign_002dpointer_002das_002dstring"/>
<bridgehead renderas="sect1">with-foreign-pointer-as-string</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>with-foreign-pointer-as-string</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>with-foreign-pointer-as-string</function> (<replaceable>var</replaceable> <replaceable>size</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>size-var</replaceable>                                       <replaceable>&amp;rest</replaceable> <replaceable>args</replaceable>) <replaceable>&amp;body</replaceable> <replaceable>body</replaceable> <replaceable>&#8658;</replaceable> <replaceable>string</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>var</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>string</replaceable>
</term><listitem><para>A Lisp string.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>body</replaceable>
</term><listitem><para>List of forms to be executed.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>with-foreign-pointer-as-string</literal> macro is similar to
<literal>with-foreign-pointer</literal> except that <replaceable>var</replaceable> is used as the
returned value of an implicit <literal>progn</literal> around <replaceable>body</replaceable>, after
being converted to a Lisp string using the provided <replaceable>args</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-pointer-as-string (str 6 str-size :encoding :ascii)
        (lisp-string-to-foreign &quot;Hello, foreign world!&quot; str str-size))
&#8658; &quot;Hello&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dstring_002dalloc">foreign-string-alloc</link> 

<link linkend="with_002dforeign_002dstring">with-foreign-string</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Variables -->

</chapter>
<chapter label="9" id="Variables">
<title>Variables</title>



<!-- =================================================================== -->
<!-- DEFCVAR -->

<anchor id="defcvar"/>
<bridgehead renderas="sect1">defcvar</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defcvar</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defcvar</function> <replaceable>name-and-options</replaceable> <replaceable>type</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>documentation</replaceable> <replaceable>&#8658;</replaceable> <replaceable>lisp-name</replaceable></synopsis>

<para><replaceable>name-and-options</replaceable> ::= name | (name &amp;key read-only (library :default)) 

<replaceable>name</replaceable> ::= lisp-name [foreign-name] | foreign-name [lisp-name] 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-name</replaceable>
</term><listitem><para>A string denoting a foreign function.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>lisp-name</replaceable>
</term><listitem><para>A symbol naming the Lisp function to be created.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>read-only</replaceable>
</term><listitem><para>A boolean.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>documentation</replaceable>
</term><listitem><para>A Lisp string; not evaluated.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>defcvar</literal> macro defines a symbol macro <replaceable>lisp-name</replaceable> that looks
up <replaceable>foreign-name</replaceable> and dereferences it acording to <replaceable>type</replaceable>.  It
can also be <literal>setf</literal>ed, unless <replaceable>read-only</replaceable> is true, in which
case an error will be signaled.
</para>
<para>When one of <replaceable>lisp-name</replaceable> or <replaceable>foreign-name</replaceable> is omitted, the
other is automatically derived using the following rules:
</para>
<itemizedlist><listitem><para>Foreign names are converted to Lisp names by uppercasing, replacing
underscores with hyphens, and wrapping around asterisks.
</para></listitem><listitem><para>Lisp names are converted to foreign names by lowercasing, replacing
hyphens with underscores, and removing asterisks, if any.
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defcvar &quot;errno&quot; :int)
&#8658; *ERRNO*
CFFI&gt; (foreign-funcall &quot;strerror&quot; :int *errno* :string)
&#8658; &quot;Inappropriate ioctl for device&quot;
CFFI&gt; (setf *errno* 1)
&#8658; 1
CFFI&gt; (foreign-funcall &quot;strerror&quot; :int *errno* :string)
&#8658; &quot;Operation not permitted&quot;
</programlisting>
<para>Trying to modify a read-only foreign variable:
</para>
<programlisting>CFFI&gt; (defcvar (&quot;errno&quot; +error-number+ :read-only t) :int)
&#8658; +ERROR-NUMBER+
CFFI&gt; (setf +error-number+ 12)
;; error&#8594; Trying to modify read-only foreign var: +ERROR-NUMBER+.
</programlisting>
<para><emphasis>Note that accessing <literal>errno</literal> this way won&#8217;t work with every
implementation of the C standard library.</emphasis>
</para>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="get_002dvar_002dpointer">get-var-pointer</link>
</para>

<!-- =================================================================== -->
<!-- GET-VAR-POINTER -->

<anchor id="get_002dvar_002dpointer"/>
<bridgehead renderas="sect1">get-var-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>get-var-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>get-var-pointer</function> <replaceable>symbol</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>symbol</replaceable>
</term><listitem><para>A symbol denoting a foreign variable defined with <literal>defcvar</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A foreign pointer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The function <literal>get-var-pointer</literal> will return a <replaceable>pointer</replaceable> to the
foreign global variable <replaceable>symbol</replaceable> previously defined with
<literal>defcvar</literal>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defcvar &quot;errno&quot; :int :read-only t)
&#8658; *ERRNO*
CFFI&gt; *errno*
&#8658; 25
CFFI&gt; (get-var-pointer '*errno*)
&#8658; #&lt;A Mac Pointer #xA0008130&gt;
CFFI&gt; (mem-ref * :int)
&#8658; 25
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcvar">defcvar</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Functions -->

</chapter>
<chapter label="10" id="Functions">
<title>Functions</title>


<!-- @node Calling Foreign Functions -->
<!-- @section Calling Foreign Functions -->

<!-- @node Defining Foreign Functions -->
<!-- @section Defining Foreign Functions -->


<!-- =================================================================== -->
<!-- DEFCFUN -->

<anchor id="defcfun"/>
<bridgehead renderas="sect1">defcfun</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defcfun</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defcfun</function> <replaceable>name-and-options</replaceable> <replaceable>return-type</replaceable> <replaceable>&amp;body</replaceable> [<replaceable>docstring</replaceable>] <replaceable>arguments</replaceable> [<replaceable>&amp;rest</replaceable>]                <replaceable>&#8658;</replaceable> <replaceable>lisp-name</replaceable></synopsis>

<para><replaceable>name-and-options</replaceable> ::= <replaceable>name</replaceable> | (<replaceable>name</replaceable> &amp;key <replaceable>library</replaceable> <replaceable>convention</replaceable>) 

<replaceable>name</replaceable> ::= <replaceable>lisp-name</replaceable> [<replaceable>foreign-name</replaceable>] | <replaceable>foreign-name</replaceable> [<replaceable>lisp-name</replaceable>] 

<replaceable>arguments</replaceable> ::= { (<replaceable>arg-name</replaceable> <replaceable>arg-type</replaceable>) }* 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-name</replaceable>
</term><listitem><para>A string denoting a foreign function.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>lisp-name</replaceable>
</term><listitem><para>A symbol naming the Lisp function to be created.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-name</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-type</replaceable>
</term><term><replaceable>arg-type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>library</replaceable>
</term><listitem><para>A symbol designating a foreign library.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>docstring</replaceable>
</term><listitem><para>A documentation string.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>defcfun</literal> macro provides a declarative interface for defining
Lisp functions that call foreign functions.
</para>
<para>When one of <replaceable>lisp-name</replaceable> or <replaceable>foreign-name</replaceable> is omitted, the
other is automatically derived using the following rules:
</para>
<itemizedlist><listitem><para>Foreign names are converted to Lisp names by uppercasing and replacing
underscores with hyphens.
</para></listitem><listitem><para>Lisp names are converted to foreign names by lowercasing and replacing
hyphens with underscores.
</para></listitem></itemizedlist>
<para>If you place the symbol <literal>&amp;rest</literal> in the end of the argument list
after the fixed arguments, <literal>defcfun</literal> will treat the foreign
function as a <emphasis role="bold">variadic function</emphasis>. The variadic arguments
should be passed in a way similar to what <literal>foreign-funcall</literal> would
expect. Unlike <literal>foreign-funcall</literal> though, <literal>defcfun</literal> will take
care of doing argument promotion. Note that in this case
<literal>defcfun</literal> will generate a Lisp <emphasis>macro</emphasis> instead of a
function and will only work for Lisps that support
<literal>foreign-funcall.</literal>
</para>
<para>If a foreign structure is to be passed or returned by value (that is,
the type is of the form <literal>(:struct ...)</literal>), then the cffi-libffi system
must be loaded, which in turn depends on
<ulink url="http://sourceware.org/libffi/">libffi</ulink>, including the header files.
Failure to load that system will result in an error.
Variadic functions cannot at present accept or return structures by
value.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>(defcfun &quot;strlen&quot; :int
  &quot;Calculate the length of a string.&quot;
  (n :string))

CFFI&gt; (strlen &quot;123&quot;)
&#8658; 3
</programlisting>
<programlisting>(defcfun (&quot;abs&quot; c-abs) :int (n :int))

CFFI&gt; (c-abs -42)
&#8658; 42
</programlisting>
<para>Function without arguments:
</para>
<programlisting>(defcfun &quot;rand&quot; :int)

CFFI&gt; (rand)
&#8658; 1804289383
</programlisting>
<para>Variadic function example:
</para>
<programlisting>(defcfun &quot;sprintf&quot; :int
  (str :pointer)
  (control :string)
  &amp;rest)

CFFI&gt; (with-foreign-pointer-as-string (s 100)
        (sprintf s &quot;%c %d %.2f %s&quot; :char 90 :short 42 :float pi
                 :string &quot;super-locrian&quot;))
&#8658; &quot;A 42 3.14 super-locrian&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="foreign_002dfuncall">foreign-funcall</link> 

<link linkend="foreign_002dfuncall_002dpointer">foreign-funcall-pointer</link> 

<link linkend="foreign_002dfuncall_002dvarargs">foreign-funcall-varargs</link> 

<link linkend="foreign_002dfuncall_002dpointer_002dvarargs">foreign-funcall-pointer-varargs</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-FUNCALL -->

<anchor id="foreign_002dfuncall"/>
<bridgehead renderas="sect1">foreign-funcall</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-funcall</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>foreign-funcall</function> <replaceable>name-and-options</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>arguments</replaceable> <replaceable>&#8658;</replaceable> <replaceable>return-value</replaceable></synopsis>

<para><replaceable>arguments</replaceable> ::= { <replaceable>arg-type</replaceable> <replaceable>arg</replaceable> }* [<replaceable>return-type</replaceable>] 

<replaceable>name-and-options</replaceable> ::= <replaceable>name</replaceable> | (<replaceable>name</replaceable> &amp;key <replaceable>library</replaceable> <replaceable>convention</replaceable>) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>A Lisp string.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg</replaceable>
</term><listitem><para>An argument of type <replaceable>arg-type</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-type</replaceable>
</term><listitem><para>A foreign type, <literal>:void</literal> by default.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-value</replaceable>
</term><listitem><para>A lisp object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>library</replaceable>
</term><listitem><para>A lisp symbol; not evaluated.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-funcall</literal> macro is the main primitive for calling
foreign functions.
</para>
<para>If a foreign structure is to be passed or returned by value (that is,
the type is of the form <literal>(:struct ...)</literal>), then the cffi-libffi system
must be loaded, which in turn depends on
<ulink url="http://sourceware.org/libffi/">libffi</ulink>, including the header files.
Failure to load that system will result in an error.
Variadic functions cannot at present accept or return structures by
value.
</para>
<para><emphasis>Note: The return value of foreign-funcall on functions with a
:void return type is still undefined.</emphasis>
</para>
<bridgehead renderas="sect2">Implementation-specific Notes</bridgehead>
<itemizedlist><listitem><para>Corman Lisp does not support <literal>foreign-funcall</literal>. On
implementations that <emphasis role="bold">don&#8217;t</emphasis> support <literal>foreign-funcall</literal>
<literal>cffi-sys::no-foreign-funcall</literal> will be present in
<literal>*features*</literal>. Note: in these Lisps you can still use the
<literal>defcfun</literal> interface.
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-funcall &quot;strlen&quot; :string &quot;foo&quot; :int)
&#8658; 3
</programlisting>
<para>Given the C code:
</para>
<screen>void print_number(int n)
{
    printf(&quot;N: %d\n&quot;, n);
}
</screen>
<programlisting>CFFI&gt; (foreign-funcall &quot;print_number&quot; :int 123456)
&#8867; N: 123456
&#8658; NIL
</programlisting>
<para>Or, equivalently:
</para>
<programlisting>CFFI&gt; (foreign-funcall &quot;print_number&quot; :int 123456 :void)
&#8867; N: 123456
&#8658; NIL
</programlisting>
<programlisting>CFFI&gt; (foreign-funcall &quot;printf&quot; :string (format nil &quot;%s: %d.~%&quot;)
                       :string &quot;So long and thanks for all the fish&quot;
                       :int 42 :int)
&#8867; So long and thanks for all the fish: 42.
&#8658; 41
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcfun">defcfun</link> 

<link linkend="foreign_002dfuncall_002dpointer">foreign-funcall-pointer</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-FUNCALL-POINTER -->

<anchor id="foreign_002dfuncall_002dpointer"/>
<bridgehead renderas="sect1">foreign-funcall-pointer</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-funcall-pointer</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>foreign-funcall-pointer</function> <replaceable>pointer</replaceable> <replaceable>options</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>arguments</replaceable> <replaceable>&#8658;</replaceable> <replaceable>return-value</replaceable></synopsis>

<para><replaceable>arguments</replaceable> ::= { <replaceable>arg-type</replaceable> <replaceable>arg</replaceable> }* [<replaceable>return-type</replaceable>] 

<replaceable>options</replaceable> ::= (&amp;key <replaceable>convention</replaceable>) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg</replaceable>
</term><listitem><para>An argument of type <replaceable>arg-type</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-type</replaceable>
</term><listitem><para>A foreign type, <literal>:void</literal> by default.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-value</replaceable>
</term><listitem><para>A lisp object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-funcall</literal> macro is the main primitive for calling
foreign functions.
</para>
<para><emphasis>Note: The return value of foreign-funcall on functions with a
:void return type is still undefined.</emphasis>
</para>
<bridgehead renderas="sect2">Implementation-specific Notes</bridgehead>
<itemizedlist><listitem><para>Corman Lisp does not support <literal>foreign-funcall</literal>. On
implementations that <emphasis role="bold">don&#8217;t</emphasis> support <literal>foreign-funcall</literal>
<literal>cffi-sys::no-foreign-funcall</literal> will be present in
<literal>*features*</literal>. Note: in these Lisps you can still use the
<literal>defcfun</literal> interface.
</para></listitem></itemizedlist>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (foreign-funcall-pointer (foreign-symbol-pointer &quot;abs&quot;) ()
                               :int -42 :int)
&#8658; 42
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcfun">defcfun</link> 

<link linkend="foreign_002dfuncall">foreign-funcall</link>
</para>

<!-- =================================================================== -->
<!-- FOREIGN-FUNCALL-VARARGS -->

<anchor id="foreign_002dfuncall_002dvarargs"/>
<bridgehead renderas="sect1">foreign-funcall-varargs</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-funcall-varargs</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>foreign-funcall-varargs</function> <replaceable>name-and-options</replaceable> (<replaceable>fixed-arguments</replaceable>) <replaceable>&amp;rest</replaceable> <replaceable>arguments</replaceable> <replaceable>&#8658;</replaceable> <replaceable>return-value</replaceable></synopsis>

<para><replaceable>fixed-arguments</replaceable> ::= { <replaceable>arg-type</replaceable> <replaceable>arg</replaceable> }* [<replaceable>return-type</replaceable>] 

<replaceable>arguments</replaceable> ::= { <replaceable>arg-type</replaceable> <replaceable>arg</replaceable> }* [<replaceable>return-type</replaceable>] 

<replaceable>name-and-options</replaceable> ::= <replaceable>name</replaceable> | (<replaceable>name</replaceable> &amp;key <replaceable>library</replaceable> <replaceable>convention</replaceable>) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>A Lisp string.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg</replaceable>
</term><listitem><para>An argument of type <replaceable>arg-type</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-type</replaceable>
</term><listitem><para>A foreign type, <literal>:void</literal> by default.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-value</replaceable>
</term><listitem><para>A lisp object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>library</replaceable>
</term><listitem><para>A lisp symbol; not evaluated.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-funcall-varargs</literal> macro is the main primitive for
calling foreign variadic functions. It behaves similarily to
<literal>foreign-funcall</literal> except <literal>fixed-arguments</literal> are distinguished
from the remaining arguments.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-pointer-as-string (s 100)
        (setf (mem-ref s :char) 0)
        (foreign-funcall-varargs
         &quot;sprintf&quot; (:pointer s :string) &quot;%.2f&quot;)
         :double (coerce pi 'double-float) :int))
&#8658; 3.14
</programlisting>

<!-- =================================================================== -->
<!-- FOREIGN-FUNCALL-POINTER-VARARGS -->

<anchor id="foreign_002dfuncall_002dpointer_002dvarargs"/>
<bridgehead renderas="sect1">foreign-funcall-pointer-varargs</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>foreign-funcall-pointer-varargs</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>foreign-funcall-pointer-varargs</function> <replaceable>pointer</replaceable> <replaceable>options</replaceable> (<replaceable>fixed-arguments</replaceable>) <replaceable>&amp;rest</replaceable> <replaceable>arguments</replaceable> <replaceable>&#8658;</replaceable> <replaceable>return-value</replaceable></synopsis>

<para><replaceable>fixed-arguments</replaceable> ::= { <replaceable>arg-type</replaceable> <replaceable>arg</replaceable> }* [<replaceable>return-type</replaceable>] 

<replaceable>arguments</replaceable> ::= { <replaceable>arg-type</replaceable> <replaceable>arg</replaceable> }* [<replaceable>return-type</replaceable>] 

<replaceable>options</replaceable> ::= (&amp;key <replaceable>convention</replaceable>) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A foreign pointer.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg</replaceable>
</term><listitem><para>An argument of type <replaceable>arg-type</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-type</replaceable>
</term><listitem><para>A foreign type, <literal>:void</literal> by default.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-value</replaceable>
</term><listitem><para>A lisp object.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>foreign-funcall-pointer-varargs</literal> macro is the main primitive
for calling foreign variadic functions. It behaves similarily to
<literal>foreign-funcall-pointer</literal> except <literal>fixed-arguments</literal> are
distinguished from the remaining arguments.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (with-foreign-pointer-as-string (s 100)
        (setf (mem-ref s :char) 0)
        (foreign-funcall-pointer-varargs
         (foreign-symbol-pointer &quot;sprintf&quot;) () (:pointer s :string &quot;%.2f&quot;)
         :double (coerce pi 'double-float) :int))
&#8658; 3.14
</programlisting>

<!-- =================================================================== -->
<!-- TRANSLATE-CAMELCASE-NAME -->

<anchor id="translate_002dcamelcase_002dname"/>
<bridgehead renderas="sect1">translate-camelcase-name</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-camelcase-name</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>translate-camelcase-name</function> <replaceable>name</replaceable> <replaceable>&amp;key</replaceable> <replaceable>upper-initial-p</replaceable> <replaceable>special-words</replaceable> <replaceable>&#8658;</replaceable> <replaceable>return-value</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>Either a symbol or a string.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>upper-initial-p</replaceable>
</term><listitem><para>A generalized boolean.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>special words</replaceable>
</term><listitem><para>A list of strings.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-value</replaceable>
</term><listitem><para>If <replaceable>name</replaceable> is a symbol, this is a string, and vice versa.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para><literal>translate-camelcase-name</literal> is a helper function for
specializations of <literal>translate-name-from-foreign</literal> and
<literal>translate-name-to-foreign</literal>. It handles the common case of
converting between foreign camelCase names and lisp
names. <replaceable>upper-initial-p</replaceable> indicates whether the first letter of the
foreign name should be uppercase. <replaceable>special-words</replaceable> is a list of
strings that should be treated atomically in translation. This list is
case-sensitive.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (translate-camelcase-name some-xml-function)
&#8658; &quot;someXmlFunction&quot;
CFFI&gt; (translate-camelcase-name some-xml-function :upper-initial-p t)
&#8658; &quot;SomeXmlFunction&quot;
CFFI&gt; (translate-camelcase-name some-xml-function :special-words '(&quot;XML&quot;))
&#8658; &quot;someXMLFunction&quot;
CFFI&gt; (translate-camelcase-name &quot;someXMLFunction&quot;)
&#8658; SOME-X-M-L-FUNCTION
CFFI&gt; (translate-camelcase-name &quot;someXMLFunction&quot; :special-words '(&quot;XML&quot;))
&#8658; SOME-XML-FUNCTION
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</link> 

<link linkend="translate_002dname_002dto_002dforeign">translate-name-to-foreign</link> 

<link linkend="translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</link>
</para>

<!-- =================================================================== -->
<!-- TRANSLATE-NAME-FROM-FOREIGN -->

<anchor id="translate_002dname_002dfrom_002dforeign"/>
<bridgehead renderas="sect1">translate-name-from-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-name-from-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>translate-name-from-foreign</function> <replaceable>foreign-name</replaceable> <replaceable>package</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>varp</replaceable> <replaceable>&#8658;</replaceable> <replaceable>symbol</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>foreign-name</replaceable>
</term><listitem><para>A string denoting a foreign function.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>package</replaceable>
</term><listitem><para>A Lisp package
</para>
</listitem></varlistentry><varlistentry><term><replaceable>varp</replaceable>
</term><listitem><para>A generalized boolean.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>symbol</replaceable>
</term><listitem><para>The Lisp symbol to be used a function name.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para><literal>translate-name-from-foreign</literal> is used by <link linkend="defcfun">defcfun</link> to handle
the conversion of foreign names to lisp names. By default, it
translates using <link linkend="translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</link>. However,
you can create specialized methods on this function to make
translating more closely match the foreign library&#8217;s naming
conventions.
</para>
<para>Specialize <replaceable>package</replaceable> on some package. This allows other packages
to load libraries with different naming conventions.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defcfun &quot;someXmlFunction&quot; ...)
&#8658; SOMEXMLFUNCTION
CFFI&gt; (defmethod translate-name-from-foreign ((spec string)
                                              (package (eql *package*))
                                              &amp;optional varp)
        (let ((name (translate-camelcase-name spec)))
          (if varp (intern (format nil &quot;*~a*&quot; name)) name)))
&#8658; #&lt;STANDARD-METHOD TRANSLATE-NAME-FROM-FOREIGN (STRING (EQL #&lt;Package &quot;SOME-PACKAGE&quot;&gt;))&gt;
CFFI&gt; (defcfun &quot;someXmlFunction&quot; ...)
&#8658; SOME-XML-FUNCTION
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcfun">defcfun</link> 

<link linkend="translate_002dcamelcase_002dname">translate-camelcase-name</link> 

<link linkend="translate_002dname_002dto_002dforeign">translate-name-to-foreign</link> 

<link linkend="translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</link>
</para>

<!-- =================================================================== -->
<!-- TRANSLATE-NAME-TO-FOREIGN -->

<anchor id="translate_002dname_002dto_002dforeign"/>
<bridgehead renderas="sect1">translate-name-to-foreign</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-name-to-foreign</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>translate-name-to-foreign</function> <replaceable>lisp-name</replaceable> <replaceable>package</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>varp</replaceable> <replaceable>&#8658;</replaceable> <replaceable>string</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>lisp-name</replaceable>
</term><listitem><para>A symbol naming the Lisp function to be created.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>package</replaceable>
</term><listitem><para>A Lisp package
</para>
</listitem></varlistentry><varlistentry><term><replaceable>varp</replaceable>
</term><listitem><para>A generalized boolean.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>string</replaceable>
</term><listitem><para>The string representing the foreign function name.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para><literal>translate-name-to-foreign</literal> is used by <link linkend="defcfun">defcfun</link> to handle
the conversion of lisp names to foreign names. By default, it
translates using <link linkend="translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</link>. However,
you can create specialized methods on this function to make
translating more closely match the foreign library&#8217;s naming
conventions.
</para>
<para>Specialize <replaceable>package</replaceable> on some package. This allows other packages
to load libraries with different naming conventions.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defcfun some-xml-function ...)
&#8658; &quot;some_xml_function&quot;
CFFI&gt; (defmethod translate-name-to-foreign ((spec symbol)
                                            (package (eql *package*))
                                            &amp;optional varp)
        (let ((name (translate-camelcase-name spec)))
          (if varp (subseq name 1 (1- (length name))) name)))
&#8658; #&lt;STANDARD-METHOD TRANSLATE-NAME-TO-FOREIGN (STRING (EQL #&lt;Package &quot;SOME-PACKAGE&quot;&gt;))&gt;
CFFI&gt; (defcfun some-xml-function ...)
&#8658; &quot;someXmlFunction&quot;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="defcfun">defcfun</link> 

<link linkend="translate_002dcamelcase_002dname">translate-camelcase-name</link> 

<link linkend="translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</link> 

<link linkend="translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</link>
</para>

<!-- =================================================================== -->
<!-- TRANSLATE-UNDERSCORE-SEPARATED-NAME -->

<anchor id="translate_002dunderscore_002dseparated_002dname"/>
<bridgehead renderas="sect1">translate-underscore-separated-name</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>translate-underscore-separated-name</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>translate-underscore-separated-name</function> <replaceable>name</replaceable> <replaceable>&#8658;</replaceable> <replaceable>return-value</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>Either a symbol or a string.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-value</replaceable>
</term><listitem><para>If <replaceable>name</replaceable> is a symbol, this is a string, and vice versa.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para><literal>translate-underscore-separated-name</literal> is a helper function for
specializations of <link linkend="translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</link> and
<link linkend="translate_002dname_002dto_002dforeign">translate-name-to-foreign</link>. It handles the common case of
converting between foreign underscore_separated names and lisp names.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (translate-underscore-separated-name some-xml-function)
&#8658; &quot;some_xml_function&quot;
CFFI&gt; (translate-camelcase-name &quot;some_xml_function&quot;)
&#8658; SOME-XML-FUNCTION
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</link> 

<link linkend="translate_002dname_002dto_002dforeign">translate-name-to-foreign</link> 

<link linkend="translate_002dcamelcase_002dname">translate-camelcase-name</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Libraries -->

</chapter>
<chapter label="11" id="Libraries">
<title>Libraries</title>



<sect1 label="11.1" id="Defining-a-library">
<title>Defining a library</title>

<para>Almost all foreign code you might want to access exists in some kind
of shared library.  The meaning of <firstterm>shared library</firstterm> varies among
platforms, but for our purposes, we will consider it to include
<filename>.so</filename> files on UNIX, frameworks on Darwin (and derivatives
like Mac <acronym>OS X</acronym>), and <filename>.dll</filename> files on Windows.
</para>
<para>Bringing one of these libraries into the Lisp image is normally a
two-step process.
</para>
<orderedlist numeration="arabic"><listitem><para>Describe to <acronym>CFFI</acronym> how to load the library at some future point,
depending on platform and other factors, with a
<literal>define-foreign-library</literal> top-level form.
</para>
</listitem><listitem><para>Load the library so defined with either a top-level
<literal>use-foreign-library</literal> form or by calling the function
<literal>load-foreign-library</literal>.
</para></listitem></orderedlist>
<para>See <link linkend="Tutorial_002dLoading">Loading foreign libraries</link>, for a working
example of the above two steps.
</para>

</sect1>
<sect1 label="11.2" id="Library-definition-style">
<title>Library definition style</title>

<para>Looking at the <literal>libcurl</literal> library definition presented earlier,
you may ask why we did not simply do this:
</para>
<programlisting>(define-foreign-library libcurl
  (t (:default &quot;libcurl&quot;)))
</programlisting>
<para>Indeed, this would work just as well on the computer on which I tested
the tutorial.  There are a couple of good reasons to provide the
<filename>.so</filename>&#8217;s current version number, however.  Namely, the versionless
<filename>.so</filename> is not packaged on most UNIX systems along with the
actual, fully-versioned library; instead, it is included in the
&#8220;development&#8221; package along with C headers and static <filename>.a</filename>
libraries.
</para>
<para>The reason <acronym>CFFI</acronym> does not try to account for this lies in the
meaning of the version numbers.  A full treatment of shared library
versions is beyond this manual&#8217;s scope; see section &#8220;Library
interface versions&#8221; in <citetitle><acronym>GNU</acronym> Libtool</citetitle>, for helpful
information for the unfamiliar.  For our purposes, consider that a
mismatch between the library version with which you tested and the
installed library version may cause undefined
behavior.<footnote><para>Windows programmers may chafe at adding a
UNIX-specific clause to <literal>define-foreign-library</literal>.  Instead,
ask why the Windows solution to library incompatibility is &#8220;include
your own version of every library you use with every program&#8221;.</para></footnote>
</para>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>Maybe some notes should go here about OS X, which I know
little about.  &#8211;stephen</emphasis>
</para></blockquote>

<!-- =================================================================== -->
<!-- CLOSE-FOREIGN-LIBRARY -->

<anchor id="close_002dforeign_002dlibrary"/>
<bridgehead renderas="sect1">close-foreign-library</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>close-foreign-library</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>close-foreign-library</function> <replaceable>library</replaceable> <replaceable>&#8658;</replaceable> <replaceable>success</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>library</replaceable>
</term><listitem><para>A symbol or an instance of <literal>foreign-library</literal>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>success</replaceable>
</term><listitem><para>A Lisp boolean.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<para>Closes <replaceable>library</replaceable> which can be a symbol designating a library
define through <literal>define-foreign-library</literal> or an instance of
<literal>foreign-library</literal> as returned by <literal>load-foreign-library</literal>.
</para>
<!-- @subheading Examples -->
<!-- @xref{Tutorial-Loading,, Loading foreign libraries}. -->

<bridgehead renderas="sect2">See Also</bridgehead>

<para><link linkend="define_002dforeign_002dlibrary">define-foreign-library</link> 

<link linkend="load_002dforeign_002dlibrary">load-foreign-library</link> 

<link linkend="use_002dforeign_002dlibrary">use-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- *DARWIN-FRAMEWORK-DIRECTORIES* -->

<anchor id="_002adarwin_002dframework_002ddirectories_002a"/>
<bridgehead renderas="sect1">*darwin-framework-directories*</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>

<synopsis><indexterm role="vr"><primary>*darwin-framework-directories*</primary></indexterm><phrase role="category"><emphasis role="bold">Special Variable</emphasis>:</phrase> <varname>*darwin-framework-directories*</varname></synopsis>

<bridgehead renderas="sect2">Value type</bridgehead>

<para>A list, in which each element is a string, a pathname, or a simple
Lisp expression.
</para>
<bridgehead renderas="sect2">Initial value</bridgehead>

<para>A list containing the following, in order: an expression corresponding
to Darwin path <filename>~/Library/Frameworks/</filename>,
<literal>#P&quot;/Library/Frameworks/&quot;</literal>, and
<literal>#P&quot;/System/Library/Frameworks/&quot;</literal>.
</para>
<bridgehead renderas="sect2">Description</bridgehead>

<para>The meaning of &#8220;simple Lisp expression&#8221; is explained in
<link linkend="_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</link>.  In contrast to that variable,
this is not a fallback search path; the default value described above
is intended to be a reasonably complete search path on Darwin systems.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (let ((lib (load-foreign-library '(:framework &quot;OpenGL&quot;))))
        (foreign-library-pathname lib))
&#8658; #P&quot;/System/Library/Frameworks/OpenGL.framework/OpenGL&quot;
</programlisting>
<bridgehead renderas="sect2">See also</bridgehead>

<para><link linkend="_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</link> 

<link linkend="define_002dforeign_002dlibrary">define-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- DEFINE-FOREIGN-LIBRARY -->

<anchor id="define_002dforeign_002dlibrary"/>
<bridgehead renderas="sect1">define-foreign-library</bridgehead>

<bridgehead renderas="sect2">Syntax</bridgehead>

<synopsis><indexterm role="fn"><primary>define-foreign-library</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>define-foreign-library</function> <replaceable>name-and-options</replaceable> <replaceable>{</replaceable> <replaceable>load-clause</replaceable> <replaceable>}</replaceable><replaceable>*</replaceable> <replaceable>&#8658;</replaceable> <replaceable>name</replaceable></synopsis>

<para>name-and-options ::= name | (name &amp;key canary convention search-path) 

load-clause ::= (feature library &amp;key convention search-path) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>feature</replaceable>
</term><listitem><para>A feature expression.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>library</replaceable>
</term><listitem><para>A library designator.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>canary</replaceable>
</term><listitem><para>A string denoting a foreign symbol that will be searched in core
before attempting to load the library. If that symbol is found, the
library is assumed to be statically linked and
<literal>load-foreign-library</literal> only marks the library as loaded.
</para>
<para>Some implementations (Clisp, ECL, SBCL) natively support static
linking, sometimes referred to as a <emphasis>link kit</emphasis>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>
</para>
</listitem></varlistentry><varlistentry><term><replaceable>search-path</replaceable>
</term><listitem><para>A path or list of paths where the library will be searched if not found in
system-global directories. Paths specified in a load clause take priority over
paths specified as library option, with *foreign-library-directories* having
lowest priority.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<para>Creates a new library designator called <replaceable>name</replaceable>.  The
<replaceable>load-clause</replaceable>s describe how to load that designator when passed to
<literal>load-foreign-library</literal> or <literal>use-foreign-library</literal>.
</para>
<para>When trying to load the library <replaceable>name</replaceable>, the relevant function
searches the <replaceable>load-clause</replaceable>s in order for the first one where
<replaceable>feature</replaceable> evaluates to true.  That happens for any of the
following situations:
</para>
<orderedlist numeration="arabic"><listitem><para>If <replaceable>feature</replaceable> is a symbol present in <literal>common-lisp:*features*</literal>.
</para>
</listitem><listitem><para>If <replaceable>feature</replaceable> is a list, depending on <literal>(first <replaceable>feature</replaceable>)</literal>,
a keyword:
</para>
<variablelist><varlistentry><term><literal>:and</literal>
</term><listitem><para>All of the feature expressions in <literal>(rest <replaceable>feature</replaceable>)</literal> are
true.
</para>
</listitem></varlistentry><varlistentry><term><literal>:or</literal>
</term><listitem><para>At least one of the feature expressions in <literal>(rest <replaceable>feature</replaceable>)</literal>
is true.
</para>
</listitem></varlistentry><varlistentry><term><literal>:not</literal>
</term><listitem><para>The feature expression <literal>(second <replaceable>feature</replaceable>)</literal> is not true.
</para></listitem></varlistentry></variablelist>
</listitem><listitem><para>Finally, if <replaceable>feature</replaceable> is <literal>t</literal>, this <replaceable>load-clause</replaceable> is
picked unconditionally.
</para></listitem></orderedlist>
<para>Upon finding the first true <replaceable>feature</replaceable>, the library loader then
loads the <replaceable>library</replaceable>.  The meaning of &#8220;library designator&#8221; is
described in <link linkend="load_002dforeign_002dlibrary">load-foreign-library</link>.
</para>
<para>Functions associated to a library defined by
<literal>define-foreign-library</literal> (e.g. through <literal>defcfun</literal>&#8217;s
<literal>:library</literal> option, will inherit the library&#8217;s options.  The
precedence is as follows:
</para>
<orderedlist numeration="arabic"><listitem><para><literal>defcfun</literal>/<literal>foreign-funcall</literal> specific options;
</para>
</listitem><listitem><para><replaceable>load-clause</replaceable> options;
</para>
</listitem><listitem><para>global library options (the <replaceable>name-and-options</replaceable> argument)
</para></listitem></orderedlist>

<bridgehead renderas="sect2">Examples</bridgehead>

<para>See <link linkend="Tutorial_002dLoading">Loading foreign libraries</link>.
</para>

<bridgehead renderas="sect2">See Also</bridgehead>

<para><link linkend="close_002dforeign_002dlibrary">close-foreign-library</link> 

<link linkend="load_002dforeign_002dlibrary">load-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- *FOREIGN-LIBRARY-DIRECTORIES* -->

<anchor id="_002aforeign_002dlibrary_002ddirectories_002a"/>
<bridgehead renderas="sect1">*foreign-library-directories*</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>

<synopsis><indexterm role="vr"><primary>*foreign-library-directories*</primary></indexterm><phrase role="category"><emphasis role="bold">Special Variable</emphasis>:</phrase> <varname>*foreign-library-directories*</varname></synopsis>

<bridgehead renderas="sect2">Value type</bridgehead>

<para>A list, in which each element is a string, a pathname, or a simple
Lisp expression.
</para>
<bridgehead renderas="sect2">Initial value</bridgehead>

<para>The empty list.
</para>
<bridgehead renderas="sect2">Description</bridgehead>

<para>You should not have to use this variable.
</para>
<para>Most, if not all, Lisps supported by <acronym>CFFI</acronym> have a reasonable default
search algorithm for foreign libraries.  For example, Lisps for
UNIX usually call
<ulink url="http://www.opengroup.org/onlinepubs/009695399/functions/dlopen.html"><literal>dlopen(3)</literal></ulink>, which in turn looks in the system library
directories.  Only if that fails does <acronym>CFFI</acronym> look for the named
library file in these directories, and load it from there if found.
</para>
<para>Thus, this is intended to be a <acronym>CFFI</acronym>-only fallback to the library
search configuration provided by your operating system.  For example,
if you distribute a foreign library with your Lisp package, you can
add the library&#8217;s containing directory to this list and portably
expect <acronym>CFFI</acronym> to find it.
</para>
<para>A <firstterm>simple Lisp expression</firstterm> is intended to provide functionality
commonly used in search paths such as
<acronym>ASDF</acronym>&#8217;s<footnote><para>See section &#8220;Using asdf to load systems&#8221; in <citetitle>asdf: another system definition facility</citetitle>, for information on
<literal>asdf:*central-registry*</literal>.</para></footnote>, and is defined recursively as
follows:<footnote><para>See <literal>mini-eval</literal> in <filename>libraries.lisp</filename> for
the source of this definition.  As is always the case with a Lisp
<literal>eval</literal>, it&#8217;s easier to understand the Lisp definition than the
english.</para></footnote>
</para>
<orderedlist numeration="arabic"><listitem><para>A list, whose &#8216;<literal>first</literal>&#8217; is a function designator, and whose
&#8216;<literal>rest</literal>&#8217; is a list of simple Lisp expressions to be evaluated and
passed to the so-designated function.  The result is the result of the
function call.
</para>
</listitem><listitem><para>A symbol, whose result is its symbol value.
</para>
</listitem><listitem><para>Anything else evaluates to itself.
</para></listitem></orderedlist>
<para>The result of evaluating the <firstterm>simple Lisp expression</firstterm> should yield
a <emphasis>designator</emphasis> for a <emphasis>list</emphasis> of <emphasis>pathname designators</emphasis>.
</para>
<para><emphasis role="bold">Note</emphasis>: in Common Lisp, <literal>#p&quot;/foo/bar&quot;</literal> designates the
<emphasis>bar</emphasis> file within the <emphasis>/foo</emphasis> directory whereas
<literal>#p&quot;/foo/bar/&quot;</literal> designates the <emphasis>/foo/bar</emphasis> directory. Keep
that in mind when customising the value of
<literal>*foreign-library-directories*</literal>.
</para>

<bridgehead renderas="sect2">Examples</bridgehead>

<screen>$ ls
&#8867; liblibli.so    libli.lisp
</screen>
<para>In <filename>libli.lisp</filename>:
</para>
<programlisting>(pushnew #P&quot;/home/sirian/lisp/libli/&quot; *foreign-library-directories*
         :test #'equal)

(load-foreign-library '(:default &quot;liblibli&quot;))
</programlisting>
<para>The following example would achieve the same effect:
</para>
<programlisting>(pushnew '(merge-pathnames #p&quot;lisp/libli/&quot; (user-homedir-pathname))
          *foreign-library-directories*
          :test #'equal)
&#8658; ((MERGE-PATHNAMES #P&quot;lisp/libli/&quot; (USER-HOMEDIR-PATHNAME)))

(load-foreign-library '(:default &quot;liblibli&quot;))
</programlisting>
<bridgehead renderas="sect2">See also</bridgehead>

<para><link linkend="_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</link> 

<link linkend="define_002dforeign_002dlibrary">define-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- LOAD-FOREIGN-LIBRARY -->

<anchor id="load_002dforeign_002dlibrary"/>
<bridgehead renderas="sect1">load-foreign-library</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>load-foreign-library</primary></indexterm><phrase role="category"><emphasis role="bold">Function</emphasis>:</phrase> <function>load-foreign-library</function> <replaceable>library-designator</replaceable> <replaceable>&#8658;</replaceable> <replaceable>library</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>library-designator</replaceable>
</term><listitem><para>A library designator.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>library-designator</replaceable>
</term><listitem><para>An instance of <literal>foreign-library</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>

<para>Load the library indicated by <replaceable>library-designator</replaceable>. A <firstterm>library
designator</firstterm> is defined as follows:
</para>
<orderedlist numeration="arabic"><listitem><para>If a symbol, is considered a name previously defined with
<literal>define-foreign-library</literal>.
</para>
</listitem><listitem><para>If a string or pathname, passed as a namestring directly to the
implementation&#8217;s foreign library loader.  If that fails, search the
directories in <literal>*foreign-library-directories*</literal> with
<literal>cl:probe-file</literal>; if found, the absolute path is passed to the
implementation&#8217;s loader.
</para>
</listitem><listitem><para>If a list, the meaning depends on <literal>(first <replaceable>library</replaceable>)</literal>:
</para>
<variablelist><varlistentry><term><literal>:framework</literal>
</term><listitem><para>The second list element is taken to be a Darwin framework name, which
is then searched in <literal>*darwin-framework-directories*</literal>, and loaded
when found.
</para>
</listitem></varlistentry><varlistentry><term><literal>:or</literal>
</term><listitem><para>Each remaining list element, itself a <firstterm>library designator</firstterm>, is loaded in
order, until one succeeds.
</para>
</listitem></varlistentry><varlistentry><term><literal>:default</literal>
</term><listitem><para>The name is transformed according to the platform&#8217;s naming convention
to shared libraries, and the resultant string is loaded as a <firstterm>library
designator</firstterm>.  For example, on UNIX, the name is suffixed with
<filename>.so</filename>.
</para></listitem></varlistentry></variablelist></listitem></orderedlist>
<para>If the library is already loaded it will be reloaded.
</para>
<para>If the load fails, signal a <literal>load-foreign-library-error</literal>.
</para>
<para><emphasis role="bold">Please note:</emphasis> For system libraries, you should not need to
specify the directory containing the library.  Each operating system
has its own idea of a default search path, and you should rely on it
when it is reasonable.
</para>
<bridgehead renderas="sect2">Implementation-specific Notes</bridgehead>
<para>On ECL platforms where its dynamic FFI is not supported (ie. when
<literal>:dffi</literal> is not present in <literal>*features*</literal>),
<literal>cffi:load-foreign-library</literal> does not work and you must use ECL&#8217;s
own <literal>ffi:load-foreign-library</literal> with a constant string argument.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<para>See <link linkend="Tutorial_002dLoading">Loading foreign libraries</link>.
</para>
<bridgehead renderas="sect2">See Also</bridgehead>

<para><link linkend="close_002dforeign_002dlibrary">close-foreign-library</link> 

<link linkend="_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</link> 

<link linkend="define_002dforeign_002dlibrary">define-foreign-library</link> 

<link linkend="_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</link> 

<link linkend="load_002dforeign_002dlibrary_002derror">load-foreign-library-error</link> 

<link linkend="use_002dforeign_002dlibrary">use-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- LOAD-FOREIGN-LIBRARY-ERROR -->

<anchor id="load_002dforeign_002dlibrary_002derror"/>
<bridgehead renderas="sect1">load-foreign-library-error</bridgehead>

<bridgehead renderas="sect2">Syntax</bridgehead>

<synopsis><indexterm role="tp"><primary>load-foreign-library-error</primary></indexterm><phrase role="category"><emphasis role="bold">Condition Type</emphasis>:</phrase> <structname>load-foreign-library-error</structname></synopsis>

<bridgehead renderas="sect2">Class precedence list</bridgehead>

<para><literal>load-foreign-library-error</literal>, <literal>error</literal>,
<literal>serious-condition</literal>, <literal>condition</literal>, <literal>t</literal>
</para>
<bridgehead renderas="sect2">Description</bridgehead>

<para>Signalled when a foreign library load completely fails.  The exact
meaning of this varies depending on the real conditions at work, but
almost universally, the implementation&#8217;s error message is useless.
However, <acronym>CFFI</acronym> does provide the useful restarts <literal>retry</literal> and
<literal>use-value</literal>; invoke the <literal>retry</literal> restart to try loading the
foreign library again, or the <literal>use-value</literal> restart to try loading
a different foreign library designator.
</para>
<bridgehead renderas="sect2">See also</bridgehead>

<para><link linkend="load_002dforeign_002dlibrary">load-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- USE-FOREIGN-LIBRARY -->

<anchor id="use_002dforeign_002dlibrary"/>
<bridgehead renderas="sect1">use-foreign-library</bridgehead>

<bridgehead renderas="sect2">Syntax</bridgehead>

<synopsis><indexterm role="fn"><primary>use-foreign-library</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>use-foreign-library</function> <replaceable>name</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>A library designator; unevaluated.
</para></listitem></varlistentry></variablelist>

<bridgehead renderas="sect2">Description</bridgehead>

<para>See <link linkend="load_002dforeign_002dlibrary">load-foreign-library</link>, for the meaning of &#8220;library
designator&#8221;.  This is intended to be the top-level form used
idiomatically after a <literal>define-foreign-library</literal> form to go ahead
and load the library. <!-- ; it also sets the ``current foreign library''. -->
Finally, on implementations where the regular evaluation rule is
insufficient for foreign library loading, it loads it at the required
time.<footnote><para>Namely, <acronym>CMUCL</acronym>.  See
<literal>use-foreign-library</literal> in <filename>libraries.lisp</filename> for details.</para></footnote>
</para>
<!-- current foreign library is a concept created a few hours ago as of -->
<!-- this writing.  It is not actually used yet, but probably will be. -->

<bridgehead renderas="sect2">Examples</bridgehead>

<para>See <link linkend="Tutorial_002dLoading">Loading foreign libraries</link>.
</para>

<bridgehead renderas="sect2">See also</bridgehead>

<para><link linkend="load_002dforeign_002dlibrary">load-foreign-library</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: Callbacks -->

</sect1>
</chapter>
<chapter label="12" id="Callbacks">
<title>Callbacks</title>



<!-- =================================================================== -->
<!-- CALLBACK -->

<anchor id="callback"/>
<bridgehead renderas="sect1">callback</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>callback</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>callback</function> <replaceable>symbol</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>symbol</replaceable>
</term><listitem><para>A symbol denoting a callback.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><term><replaceable>new-value</replaceable>
</term><listitem><para>A pointer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>callback</literal> macro is analogous to the standard CL special
operator <literal>function</literal> and will return a pointer to the callback
denoted by the symbol <replaceable>name</replaceable>.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defcallback sum :int ((a :int) (b :int))
        (+ a b))
&#8658; SUM
CFFI&gt; (callback sum)
&#8658; #&lt;A Mac Pointer #x102350&gt;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="get_002dcallback">get-callback</link> 

<link linkend="defcallback">defcallback</link>
</para>

<!-- =================================================================== -->
<!-- DEFCALLBACK -->

<anchor id="defcallback"/>
<bridgehead renderas="sect1">defcallback</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>defcallback</primary></indexterm><phrase role="category"><emphasis role="bold">Macro</emphasis>:</phrase> <function>defcallback</function> <replaceable>name-and-options</replaceable> <replaceable>return-type</replaceable> <replaceable>arguments</replaceable> <replaceable>&amp;body</replaceable> <replaceable>body</replaceable> <replaceable>&#8658;</replaceable> <replaceable>name</replaceable></synopsis>

<para>name-and-options ::= name | (name &amp;key convention) 

arguments ::= ({ (arg-name arg-type) }*) 

</para>
<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>name</replaceable>
</term><listitem><para>A symbol naming the callback created.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>return-type</replaceable>
</term><listitem><para>The foreign type for the callback&#8217;s return value.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-name</replaceable>
</term><listitem><para>A symbol.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>arg-type</replaceable>
</term><listitem><para>A foreign type.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>convention</replaceable>
</term><listitem><para>One of <literal>:cdecl</literal> (default) or <literal>:stdcall</literal>.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>The <literal>defcallback</literal> macro defines a Lisp function that can be called
from C. The arguments passed to this function will be converted to the
appropriate Lisp representation and its return value will be converted
to its C representation.
</para>
<para>This Lisp function can be accessed by the <literal>callback</literal> macro or the
<literal>get-callback</literal> function.
</para>
<para><emphasis role="bold">Portability note:</emphasis> <literal>defcallback</literal> will not work correctly
on some Lisps if it&#8217;s not a top-level form.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>(defcfun &quot;qsort&quot; :void
  (base :pointer)
  (nmemb :int)
  (size :int)
  (fun-compar :pointer))

(defcallback &lt; :int ((a :pointer) (b :pointer))
  (let ((x (mem-ref a :int))
        (y (mem-ref b :int)))
    (cond ((&gt; x y) 1)
          ((&lt; x y) -1)
          (t 0))))

CFFI&gt; (with-foreign-object (array :int 10)
        ;; Initialize array.
        (loop for i from 0 and n in '(7 2 10 4 3 5 1 6 9 8)
              do (setf (mem-aref array :int i) n))
        ;; Sort it.
        (qsort array 10 (foreign-type-size :int) (callback &lt;))
        ;; Return it as a list.
        (loop for i from 0 below 10
              collect (mem-aref array :int i)))
&#8658; (1 2 3 4 5 6 7 8 9 10)
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="callback">callback</link> 

<link linkend="get_002dcallback">get-callback</link>
</para>

<!-- =================================================================== -->
<!-- GET-CALLBACK -->

<anchor id="get_002dcallback"/>
<bridgehead renderas="sect1">get-callback</bridgehead>
<bridgehead renderas="sect2">Syntax</bridgehead>
<synopsis><indexterm role="fn"><primary>get-callback</primary></indexterm><phrase role="category"><emphasis role="bold">Accessor</emphasis>:</phrase> <function>get-callback</function> <replaceable>symbol</replaceable> <replaceable>&#8658;</replaceable> <replaceable>pointer</replaceable></synopsis>

<bridgehead renderas="sect2">Arguments and Values</bridgehead>

<variablelist><varlistentry><term><replaceable>symbol</replaceable>
</term><listitem><para>A symbol denoting a callback.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>pointer</replaceable>
</term><listitem><para>A pointer.
</para></listitem></varlistentry></variablelist>
<bridgehead renderas="sect2">Description</bridgehead>
<para>This is the functional version of the <literal>callback</literal> macro. It
returns a pointer to the callback named by <replaceable>symbol</replaceable> suitable, for
example, to pass as arguments to foreign functions.
</para>
<bridgehead renderas="sect2">Examples</bridgehead>

<programlisting>CFFI&gt; (defcallback sum :int ((a :int) (b :int))
        (+ a b))
&#8658; SUM
CFFI&gt; (get-callback 'sum)
&#8658; #&lt;A Mac Pointer #x102350&gt;
</programlisting>
<bridgehead renderas="sect2">See Also</bridgehead>
<para><link linkend="callback">callback</link> 

<link linkend="defcallback">defcallback</link>
</para>

<!-- =================================================================== -->
<!-- CHAPTER: The Groveller -->

</chapter>
<chapter label="13" id="The-Groveller">
<title>The Groveller</title>

<para><acronym>CFFI</acronym>-Grovel is a tool which makes it easier to write <acronym>CFFI</acronym>
declarations for libraries that are implemented in C.  That is, it
grovels through the system headers, getting information about types
and structures, so you don&#8217;t have to.  This is especially important
for libraries which are implemented in different ways by different
vendors, such as the UNIX/POSIX functions.  The <acronym>CFFI</acronym>
declarations are usually quite different from platform to platform,
but the information you give to <acronym>CFFI</acronym>-Grovel is the same.  Hence,
much less work is required!
</para>
<para>If you use <acronym>ASDF</acronym>, <acronym>CFFI</acronym>-Grovel is integrated, so that it
will run automatically when your system is building.  This feature was
inspired by SB-Grovel, a similar <acronym>SBCL</acronym>-specific project.
<acronym>CFFI</acronym>-Grovel can also be used without <acronym>ASDF</acronym>.
</para>
<sect1 label="13.1">
<title>Building FFIs with CFFI-Grovel</title>

<para><acronym>CFFI</acronym>-Grovel uses a specification file (*.lisp) describing the
features that need groveling.  The C compiler is used to retrieve this
data and write a Lisp file (*.cffi.lisp) which contains the necessary
<acronym>CFFI</acronym> definitions to access the variables, structures, constants, and
enums mentioned in the specification.
</para>
<!-- This is most similar to the SB-Grovel package, upon which it is -->
<!-- based.  Unlike SB-Grovel, we do not currently support defining -->
<!-- regular foreign functions in the specification file; those are best -->
<!-- defined in normal Lisp code. -->

<para><acronym>CFFI</acronym>-Grovel provides an <acronym>ASDF</acronym> component for handling the
necessary calls to the C compiler and resulting file management.
</para>
<!-- See the included CFFI-Unix package for an example of how to -->
<!-- integrate a specification file with ASDF-built packages. -->


</sect1>
<sect1 label="13.2" id="Groveller-Syntax">
<title>Specification File Syntax</title>

<para>The specification files are read by the normal Lisp reader, so they
have syntax very similar to normal Lisp code.  In particular,
semicolon-comments and reader-macros will work as expected.
</para>
<para>There are several forms recognized by <acronym>CFFI</acronym>-Grovel:
</para>
<synopsis><indexterm role="fn"><primary>progn</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>progn</function> <replaceable>&amp;rest</replaceable> <replaceable>forms</replaceable></synopsis>
<blockquote>
<para>Processes a list of forms. Useful for conditionalizing several
forms. For example:
</para></blockquote>
<programlisting>#+freebsd
(progn
  (constant (ev-enable &quot;EV_ENABLE&quot;))
  (constant (ev-disable &quot;EV_DISABLE&quot;)))
</programlisting>
<synopsis><indexterm role="fn"><primary>include</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>include</function> <replaceable>&amp;rest</replaceable> <replaceable>files</replaceable></synopsis>
<blockquote>
<para>Include the specified files (specified as strings) in the generated C
source code.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>in-package</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>in-package</function> <replaceable>symbol</replaceable></synopsis>
<blockquote>
<para>Set the package to be used for the final Lisp output.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>ctype</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>ctype</function> <replaceable>lisp-name</replaceable> <replaceable>size-designator</replaceable></synopsis>
<blockquote>
<para>Define a <acronym>CFFI</acronym> foreign type for the string in <replaceable>size-designator</replaceable>,
e.g. <literal>(ctype :pid &quot;pid_t&quot;)</literal>.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>constant</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>constant</function> (<replaceable>lisp-name</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>c-names</replaceable>) <replaceable>&amp;key</replaceable> <replaceable>type</replaceable> <replaceable>documentation</replaceable> <replaceable>optional</replaceable></synopsis>
<blockquote>
<para>Search for the constant named by the first <replaceable>c-name</replaceable> string found
to be known to the C preprocessor and define it as <replaceable>lisp-name</replaceable>.
</para>
<para>The <replaceable>type</replaceable> keyword argument specifies how to grovel the constant:
either <literal>integer</literal> (the default) or <literal>double-float</literal>. If
<replaceable>optional</replaceable> is true, no error will be raised if all the
<replaceable>c-names</replaceable> are unknown. If <replaceable>lisp-name</replaceable> is a keyword, the actual
constant will be a symbol of the same name interned in the current
package.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>feature</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>feature</function> <replaceable>lisp-feature-name</replaceable> <replaceable>c-name</replaceable> <replaceable>&amp;key</replaceable> <replaceable>feature-list</replaceable></synopsis>
<blockquote>
<para>Adds <replaceable>lisp-feature-name</replaceable> to the list <replaceable>feature-list</replaceable> if the <replaceable>c-name</replaceable>
string is known to the C preprocessor. <replaceable>feature-list</replaceable> defaults
to <literal>cl:*features*</literal>.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>define</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>define</function> <replaceable>name</replaceable> <replaceable>&amp;optional</replaceable> <replaceable>value</replaceable></synopsis>
<blockquote>
<para>Defines an additional C preprocessor symbol, which is useful for
altering the behavior of included system headers.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>cc-flags</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>cc-flags</function> <replaceable>&amp;rest</replaceable> <replaceable>flags</replaceable></synopsis>
<blockquote>
<para>Adds <replaceable>cc-flags</replaceable> to the command line arguments used for the C compiler
invocation.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>pkg-config-cflags</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>pkg-config-cflags</function> <replaceable>pkg</replaceable> <replaceable>&amp;key</replaceable> <replaceable>optional</replaceable></synopsis>
<blockquote>
<para>Adds <replaceable>pkg</replaceable> to the command line arguments for the external program
<literal>pkg-config</literal> and runs it to retrieve the relevant include flags
used for the C compiler invocation. This syntax can be used instead of
hard-coding paths using <literal>cc-flags</literal>, and ensures that include
flags are added correctly on the build system. Assumes
<literal>pkg-config</literal> is installed and working.  <replaceable>pkg</replaceable> is a string
that identifies an installed <literal>pkg-config</literal> package. See the
pkg-config manual for more information. If <replaceable>optional</replaceable> is true,
failure to execute <literal>pkg-config</literal> does <emphasis>not</emphasis> abort
compilation.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>cstruct</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>cstruct</function> <replaceable>lisp-name</replaceable> <replaceable>c-name</replaceable> <replaceable>slots</replaceable></synopsis>
<blockquote>
<para>Define a <acronym>CFFI</acronym> foreign struct with the slot data specfied.  Slots
are of the form <literal>(lisp-name c-name &amp;key type count (signed t))</literal>.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>cunion</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>cunion</function> <replaceable>lisp-name</replaceable> <replaceable>c-name</replaceable> <replaceable>slots</replaceable></synopsis>
<blockquote>
<para>Identical to <literal>cstruct</literal>, but defines a <acronym>CFFI</acronym> foreign union.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>cstruct-and-class</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>cstruct-and-class</function> <replaceable>c-name</replaceable> <replaceable>slots</replaceable></synopsis>
<blockquote>
<para>Defines a <acronym>CFFI</acronym> foreign struct, as with <literal>cstruct</literal> and defines a
<acronym>CLOS</acronym> class to be used with it.  This is useful for mapping
foreign structures to application-layer code that shouldn&#8217;t need to
worry about memory allocation issues.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>cvar</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>cvar</function> <replaceable>namespec</replaceable> <replaceable>type</replaceable> <replaceable>&amp;key</replaceable> <replaceable>read-only</replaceable></synopsis>
<blockquote>
<para>Defines a foreign variable of the specified type, even if that
variable is potentially a C preprocessor pseudo-variable.  e.g.
<literal>(cvar (&quot;errno&quot; errno) errno-values)</literal>, assuming that errno-values
is an enum or equivalent to type <literal>:int</literal>.
</para>
<para>The <replaceable>namespec</replaceable> is similar to the one used in <link linkend="defcvar">defcvar</link>.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>cenum</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>cenum</function> <replaceable>name-and-opts</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>elements</replaceable></synopsis>
<blockquote>
<para>Defines a true C enum, with elements specified as <literal>((lisp-name
&amp;rest c-names) &amp;key optional documentation)</literal>.
<replaceable>name-and-opts</replaceable> can be either a symbol as name, or a list
<literal>(name &amp;key base-type define-constants)</literal>. If <replaceable>define-constants</replaceable>
is non-null, a Lisp constant will be defined for each enum member.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>constantenum</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>constantenum</function> <replaceable>name-and-opts</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>elements</replaceable></synopsis>
<blockquote>
<para>Defines an enumeration of pre-processor constants, with elements
specified as <literal>((lisp-name &amp;rest c-names) &amp;key optional
documentation)</literal>.
<replaceable>name-and-opts</replaceable> can be either a symbol as name, or a list
<literal>(name &amp;key base-type define-constants)</literal>. If <replaceable>define-constants</replaceable>
is non-null, a Lisp constant will be defined for each enum member.
</para>
<para>This example defines <literal>:af-inet</literal> to represent the value held by
<literal>AF_INET</literal> or <literal>PF_INET</literal>, whichever the pre-processor finds
first.  Similarly for <literal>:af-packet</literal>, but no error will be
signalled if the platform supports neither <literal>AF_PACKET</literal> nor
<literal>PF_PACKET</literal>.
</para></blockquote>
<programlisting>(constantenum address-family
  ((:af-inet &quot;AF_INET&quot; &quot;PF_INET&quot;)
   :documentation &quot;IPv4 Protocol family&quot;)
  ((:af-local &quot;AF_UNIX&quot; &quot;AF_LOCAL&quot; &quot;PF_UNIX&quot; &quot;PF_LOCAL&quot;)
   :documentation &quot;File domain sockets&quot;)
  ((:af-inet6 &quot;AF_INET6&quot; &quot;PF_INET6&quot;)
   :documentation &quot;IPv6 Protocol family&quot;)
  ((:af-packet &quot;AF_PACKET&quot; &quot;PF_PACKET&quot;)
   :documentation &quot;Raw packet access&quot;
   :optional t))
</programlisting>
<synopsis><indexterm role="fn"><primary>bitfield</primary></indexterm><phrase role="category"><emphasis role="bold">Grovel Form</emphasis>:</phrase> <function>bitfield</function> <replaceable>name-and-opts</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>elements</replaceable></synopsis>
<blockquote>
<para>Defines a bitfield, with elements specified as <literal>((lisp-name &amp;rest
c-names) &amp;key optional documentation)</literal>.  <replaceable>name-and-opts</replaceable> can be either a
symbol as name, or a list <literal>(name &amp;key base-type)</literal>.  For example:
</para></blockquote>
<programlisting>(bitfield flags-ctype
  ((:flag-a &quot;FLAG_A&quot;)
    :documentation &quot;DOCU_A&quot;)
  ((:flag-b &quot;FLAG_B&quot; &quot;FLAG_B_ALT&quot;)
    :documentation &quot;DOCU_B&quot;)
  ((:flag-c &quot;FLAG_C&quot;)
    :documentation &quot;DOCU_C&quot;
    :optional t))
</programlisting>

<!-- =================================================================== -->
<!-- SECTION: Groveller ASDF Integration -->

</sect1>
<sect1 label="13.3" id="Groveller-ASDF-Integration">
<title>ASDF Integration</title>

<para>An example software project might contain four files; an
<acronym>ASDF</acronym> file, a package definition file, an implementation
file, and a <acronym>CFFI</acronym>-Grovel specification file.
</para>
<para>The <acronym>ASDF</acronym> file defines the system and its dependencies.
Notice the use of <literal>eval-when</literal> to ensure <acronym>CFFI</acronym>-Grovel is present
and the use of <literal>(cffi-grovel:grovel-file name &amp;key cc-flags)</literal>
instead of <literal>(:file name)</literal>.
</para>
<para>The <filename>example-software.asd</filename> file would look like that:
</para>
<programlisting>;;; CFFI-Grovel is needed for processing grovel-file components
(defsystem &quot;example-software&quot;
  :defsystem-depends-on (&quot;cffi-grovel&quot;)
  :depends-on (&quot;cffi&quot;)
  :serial t
  :components
  ((:file &quot;package&quot;)
   (:cffi-grovel-file &quot;example-grovelling&quot;)
   (:cffi-wrapper-file &quot;example-wrappers&quot;)
   (:file &quot;example&quot;)))
</programlisting>
<para>The <filename>package.lisp</filename> file would contain one or several
<literal>defpackage</literal> forms, to remove circular dependencies and make
building the project easier.  Note that you may or may not want to
<literal>:use</literal> your internal package.
</para>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>Note that it&#8217;s a not a good idea to <literal>:use</literal> when names may
clash with, say, CL symbols.
Or you could use <literal>uiop:define-package</literal> and its <literal>:mix</literal> option.</emphasis>
</para></blockquote>
<programlisting>(defpackage #:example-internal
  (:use)
  (:nicknames #:exampleint))

(defpackage #:example-software
  (:export ...)
  (:use #:cl #:cffi #:exampleint))
</programlisting>
<para>The internal package is created by Lisp code output from the C program
written by <acronym>CFFI</acronym>-Grovel; if your specification file is
<filename>exampleint.lisp</filename>, the <filename>exampleint.cffi.lisp</filename> file will contain the
<acronym>CFFI</acronym> definitions needed by the rest of your project.
See <link linkend="Groveller-Syntax">Groveller Syntax</link>.
</para>
</sect1>
<sect1 label="13.4" id="Groveller-Implementation-Notes">
<title>Implementation Notes</title>

<para><acronym>CFFI</acronym>-Grovel will generate many files that not only architecture-specific,
but also implementation-specific, and should not be distributed.
ASDF will generate these files in its output cache;
if you build with multiple architectures (e.g. with NFS/AFS home
directories) or implementations, it is critical for avoiding clashes
to keep this cache in an implementation-dependent directory (as is the
default).
</para>
<para>For <literal>foo-internal.lisp</literal>, the resulting <literal>foo-internal.c</literal>,
<literal>foo-internal</literal>, and <literal>foo-internal.cffi.lisp</literal> are all
platform-specific, either because of possible reader-macros in
foo-internal.lisp, or because of varying C environments on the host
system.  For this reason, it is not helpful to distribute any of those
files; end users building <acronym>CFFI</acronym>-Grovel based software will need
<literal>cffi</literal>-Grovel anyway.
</para>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>For now, after some experimentation with CLISP having no
long-long, it seems appropriate to assert that the generated <literal>.c</literal>
files are architecture and operating-system dependent, but
lisp-implementation independent.  This way the same <literal>.c</literal> file
(and so the same <literal>.grovel-tmp.lisp</literal> file) will be shareable
between the implementations running on a given system.</emphasis>
</para></blockquote>
<!-- TODO: document the new wrapper stuff. -->

</sect1>
<sect1 label="13.5" id="Wrapper-for-Inline_002fStatic-Functions-and-Macros">
<title>Wrapper for Inline/Static Functions and Macros</title>

<para>In a shared library, information in static/inlined functions and
macros are already removed during the compilation.  Wrapper file
enables to write an uninlined function wrapping the call to them.
</para>
<para>A wrapper file compilation/loading proceeds as follows: 
Unlike groveller which generates C code that emits lisp files
containing cffi definitions, it generates C code, compiles it as a
shared library, loads the library, generate the cffi definitions (as
lisp code) and then loads the lisp code.
</para>
<para>It has asdf integration similar to groveller. 
</para>
<programlisting>(defsystem &quot;example-software&quot;
  :defsystem-depends-on (&quot;cffi-grovel&quot;)
  :depends-on (&quot;cffi&quot;)
  :serial t
  :components
  ((:file &quot;package&quot;)
   (:cffi-grovel-file &quot;example-grovelling&quot;)
   (:cffi-wrapper-file &quot;example-wrappers&quot;)  ;; &lt;&lt;--- this part
   (:file &quot;example&quot;)))
</programlisting>
<synopsis><indexterm role="fn"><primary>defwrapper</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>defwrapper</function> <replaceable>name-and-options</replaceable> <replaceable>return-type</replaceable> <replaceable>&amp;rest</replaceable> <replaceable>args</replaceable></synopsis>

<screen>static inline int foo(int i) {
  return 1+i;
};
#define bar(i) (1+(i))
</screen>
<programlisting>(in-package :mypackage)
(defwrapper (&quot;foo&quot; foo) :int
  (i :int))
(defwrapper (&quot;bar&quot; bar) :int
  (i :int))
</programlisting>
<para>Other forms are similar to grovel files.
</para>
<synopsis><indexterm role="fn"><primary>progn</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>progn</function> <replaceable>&amp;rest</replaceable> <replaceable>forms</replaceable></synopsis>
<blockquote>
<para>Processes a list of forms. Useful for conditionalizing several
forms. For example:
</para></blockquote>
<programlisting>#+freebsd
(progn
  (constant (ev-enable &quot;EV_ENABLE&quot;))
  (constant (ev-disable &quot;EV_DISABLE&quot;)))
</programlisting>
<synopsis><indexterm role="fn"><primary>include</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>include</function> <replaceable>&amp;rest</replaceable> <replaceable>files</replaceable></synopsis>
<blockquote>
<para>Include the specified files (specified as strings) in the generated C
source code.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>in-package</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>in-package</function> <replaceable>symbol</replaceable></synopsis>
<blockquote>
<para>Set the package to be used for the final Lisp output.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>flags</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>flags</function> <replaceable>&amp;rest</replaceable> <replaceable>flags</replaceable></synopsis>
<blockquote>
<para>Adds <replaceable>cc-flags</replaceable> to the command line arguments used for the C compiler
invocation.
</para></blockquote>
<synopsis><indexterm role="fn"><primary>proclaim</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>proclaim</function> <replaceable>&amp;rest</replaceable> <replaceable>proclaimations</replaceable></synopsis>
<synopsis><indexterm role="fn"><primary>declaim</primary></indexterm><phrase role="category"><emphasis role="bold">Wrapper Form</emphasis>:</phrase> <function>declaim</function> <replaceable>&amp;rest</replaceable> <replaceable>declaimations</replaceable></synopsis>



<!-- =================================================================== -->
<!-- CHAPTER: Static Linking -->

</sect1>
</chapter>
<chapter label="14" id="Static-Linking">
<title>Static Linking</title>

<para>On recent enough versions of supported implementations (currently, GNU
CLISP 2.49 or later, CMUCL 2015-11 or later, and SBCL 1.2.17 or later,
except SBCL 2.0.4), and with a recent enough ASDF (3.1.2 or later),
you can create a statically linked Lisp executable image (or a
standalone application executable) that includes all the C extensions
defined via <link linkend="The-Groveller">The Groveller</link>&#8217;s <literal>:cffi-wrapper-file</literal> ASDF
components (and any other such objects output by
<literal>asdf:compile-op</literal>), as well as those defined by <literal>:c-file</literal> or
<literal>:o-file</literal> ASDF components, and your Lisp code.  This makes it
easier to deliver your code as a single file.
</para>
<para>Note that the resulting binary will typically still depend on any
shared libraries loaded via See <link linkend="load_002dforeign_002dlibrary">load-foreign-library</link> or
See <link linkend="use_002dforeign_002dlibrary">use-foreign-library</link> as well as core libraries such as
<literal>libc</literal>.
</para>
<para>To dump a statically linked executable image, use:
</para>
<programlisting>(asdf:load-system :cffi-grovel)
(asdf:operate :static-image-op :example-software)
</programlisting>
<para>To dump a statically linked executable standalone application, use:
</para>
<programlisting>(asdf:load-system :cffi-grovel)
(asdf:operate :static-program-op :example-software)
</programlisting>
<para>See <ulink url="https://common-lisp.net/project/asdf/">the ASDF
manual</ulink> for documentation about <literal>image-op</literal> and <literal>program-op</literal>
which are the parent operation classes that behave similarly except
they don&#8217;t statically link C code.
</para>
<blockquote><para><emphasis role="bold">Implementor&#8217;s note:</emphasis> <emphasis>There is also an operation <literal>:static-runtime-op</literal> to create the
statically linked runtime alone, but it&#8217;s admittedly not very useful
except as an intermediate step dependency towards building
<literal>:static-image-op</literal> or <literal>:static-program-op</literal>.</emphasis>
</para></blockquote>


<!-- =================================================================== -->
<!-- CHAPTER: Limitations -->

</chapter>
<chapter label="15" id="Limitations">
<title>Limitations</title>

<para>These are <acronym>CFFI</acronym>&#8217;s limitations across all platforms; for information
on the warts on particular Lisp implementations, see
<link linkend="Implementation-Support">Implementation Support</link>.
</para>
<itemizedlist><listitem><para>The tutorial includes a treatment of the primary, intractable
limitation of <acronym>CFFI</acronym>, or any <acronym>FFI</acronym>: that the abstractions
commonly used by C are insufficiently expressive.
See <link linkend="Tutorial_002dAbstraction">Breaking the abstraction</link>, for more
details.
</para>
</listitem></itemizedlist>

</chapter>
<appendix label="A" id="Platform_002dspecific-features">
<title>Platform-specific features</title>

<para>Whenever a backend doesn&#8217;t support one of <acronym>CFFI</acronym>&#8217;s features, a
specific symbol is pushed onto <literal>common-lisp:*features*</literal>.  The
meanings of these symbols follow.
</para>
<variablelist><varlistentry><term><replaceable>cffi-sys::flat-namespace</replaceable>
</term><listitem><para>This Lisp has a flat namespace for foreign symbols meaning that you
won&#8217;t be able to load two different libraries with homograph functions
and successfully differentiate them through the <literal>:library</literal>
option to <literal>defcfun</literal>, <literal>defcvar</literal>, etc&#8230;
</para>
</listitem></varlistentry><varlistentry><term><replaceable>cffi-sys::no-foreign-funcall</replaceable>
</term><listitem><para>The macro <literal>foreign-funcall</literal> is <emphasis role="bold">not</emphasis> available.  On such
platforms, the only way to call a foreign function is through
<literal>defcfun</literal>.  See <link linkend="foreign_002dfuncall">foreign-funcall</link>, and <link linkend="defcfun">defcfun</link>.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>cffi-sys::no-long-long</replaceable>
</term><listitem><para>The C <literal>long long</literal> type is <emphasis role="bold">not</emphasis> available as a foreign
type.
</para>
<para>However, on such platforms <acronym>CFFI</acronym> provides its own implementation of
the <literal>long long</literal> type for all of operations in chapters
<link linkend="Foreign-Types">Foreign Types</link>, <link linkend="Pointers">Pointers</link> and <link linkend="Variables">Variables</link>. The
functionality described in <link linkend="Functions">Functions</link> and <link linkend="Callbacks">Callbacks</link> will
not be available.
</para>
<para>32-bit Lispworks 5.0+ is an exception. In addition to the <acronym>CFFI</acronym>
implementation described above, Lispworks itself implements the
<literal>long long</literal> type for <link linkend="Functions">Functions</link>. <link linkend="Callbacks">Callbacks</link> are still
missing <literal>long long</literal> support, though.
</para>
</listitem></varlistentry><varlistentry><term><replaceable>cffi-sys::no-stdcall</replaceable>
</term><listitem><para>This Lisp doesn&#8217;t support the <literal>stdcall</literal> calling convention.  Note
that it only makes sense to support <literal>stdcall</literal> on (32-bit) x86
platforms.
</para>
</listitem></varlistentry></variablelist>

</appendix>
<appendix label="B" id="Glossary">
<title>Glossary</title>

<variablelist><varlistentry><term><firstterm>aggregate type</firstterm>
</term><listitem><para>A <acronym>CFFI</acronym> type for C data defined as an organization of data of simple
type; in structures and unions, which are themselves aggregate types,
they are represented by value.
</para>
</listitem></varlistentry><varlistentry><term><firstterm>foreign value</firstterm>
</term><listitem><para>This has two meanings; in any context, only one makes sense.
</para>
<para>When using type translators, the foreign value is the lower-level Lisp
value derived from the object passed to <literal>translate-to-foreign</literal>
(see <link linkend="translate_002dto_002dforeign">translate-to-foreign</link>).  This value should be a Lisp number or
a pointer (satisfies <literal>pointerp</literal>), and it can be treated like any
general Lisp object; it only completes the transformation to a true
foreign value when passed through low-level code in the Lisp
implementation, such as the foreign function caller or indirect memory
addressing combined with a data move.
</para>
<para>In other contexts, this refers to a value accessible by C, but which
may only be accessed through <acronym>CFFI</acronym> functions.  The closest you can
get to such a foreign value is through a pointer Lisp object, which
itself counts as a foreign value in only the previous sense.
</para>
</listitem></varlistentry><varlistentry><term><firstterm>simple type</firstterm>
</term><listitem><para>A <acronym>CFFI</acronym> type that is ultimately represented as a builtin type;
<acronym>CFFI</acronym> only provides extra semantics for Lisp that are invisible to C
code or data.
</para></listitem></varlistentry></variablelist>
</appendix>
<chapter label="" id="Comprehensive-Index">
<title>Index</title>
<index role="cp"></index>

</chapter>
</book>
