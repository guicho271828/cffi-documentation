<html><head><link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Comfortaa|Raleway|Ubuntu' /><link rel='stylesheet' type='text/css' href='default.css' /><script type='text/javascript' src='default.js'></script><title>cffi</title></head><body><div class="page-header"><div class="title"><h1>cffi</h1></div><div class="table-of-contents"><h1>Index</h1><ol><li><a href="#" data-node=""><span class="directory"></span></a><ol><li><a href="#README.md" data-node="README.md"><span class="file">README</span><span class="extension">md</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/readme.md">[source]</a></a></li></ol></li><li><a href="#doc" data-node="doc"><span class="directory">doc</span></a><ol><li><a href="#doc/allegro-internals.txt" data-node="doc/allegro-internals.txt"><span class="file">allegro-internals</span><span class="extension">txt</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/allegro-internals.txt">[source]</a></a></li><li><a href="#doc/cffi-manual.texinfo" data-node="doc/cffi-manual.texinfo"><span class="file">cffi-manual</span><span class="extension">texinfo</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/cffi-manual.texinfo">[source]</a></a></li><li><a href="#doc/cffi-sys-spec.texinfo" data-node="doc/cffi-sys-spec.texinfo"><span class="file">cffi-sys-spec</span><span class="extension">texinfo</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/cffi-sys-spec.texinfo">[source]</a></a></li><li><a href="#doc/mem-vector.txt" data-node="doc/mem-vector.txt"><span class="file">mem-vector</span><span class="extension">txt</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/mem-vector.txt">[source]</a></a></li><li><a href="#doc/shareable-vectors.txt" data-node="doc/shareable-vectors.txt"><span class="file">shareable-vectors</span><span class="extension">txt</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/shareable-vectors.txt">[source]</a></a></li></ol></li><li><a href="#" data-node=""><span class="directory"></span></a><ol><li><a href="#cffi.asd" data-node="cffi.asd"><span class="file">cffi</span><span class="extension">asd</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/cffi.asd">[source]</a></a></li></ol></li><li><a href="#src" data-node="src"><span class="directory">src</span></a><ol><li><a href="#src/cffi-sbcl.lisp" data-node="src/cffi-sbcl.lisp"><span class="file">cffi-sbcl</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/cffi-sbcl.lisp">[source]</a></a></li><li><a href="#src/libraries.lisp" data-node="src/libraries.lisp"><span class="file">libraries</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/libraries.lisp">[source]</a></a></li><li><a href="#src/early-types.lisp" data-node="src/early-types.lisp"><span class="file">early-types</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/early-types.lisp">[source]</a></a></li><li><a href="#src/types.lisp" data-node="src/types.lisp"><span class="file">types</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/types.lisp">[source]</a></a></li><li><a href="#src/enum.lisp" data-node="src/enum.lisp"><span class="file">enum</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/enum.lisp">[source]</a></a></li><li><a href="#src/strings.lisp" data-node="src/strings.lisp"><span class="file">strings</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/strings.lisp">[source]</a></a></li><li><a href="#src/structures.lisp" data-node="src/structures.lisp"><span class="file">structures</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/structures.lisp">[source]</a></a></li><li><a href="#src/functions.lisp" data-node="src/functions.lisp"><span class="file">functions</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/functions.lisp">[source]</a></a></li><li><a href="#src/foreign-vars.lisp" data-node="src/foreign-vars.lisp"><span class="file">foreign-vars</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/foreign-vars.lisp">[source]</a></a></li><li><a href="#src/foreign-vars.lisp" data-node="src/foreign-vars.lisp"><span class="file">foreign-vars</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/foreign-vars.lisp">[source]</a></a></li></ol></li></ol></div></div><div class="main"><h1 id=""><span class="directory"></span></h1><h2 id="README.md"><span class="file">README</span><span class="extension">md</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/readme.md">[source]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><p><a href="https://travis-ci.org/cffi/cffi"><img src="https://travis-ci.org/cffi/cffi.svg?branch=master" alt="Build Status" /></a></p>
<p>CFFI, the Common Foreign Function Interface, purports to be a portable foreign function interface for Common Lisp. The CFFI library is composed of a Lisp-implementation-specific backend in the CFFI-SYS package, and a portable frontend in the CFFI package.</p>
<p>The CFFI-SYS backend package defines a low-level interface to the native FFI support in the Lisp implementation. It offers operators for allocating and dereferencing foreign memory, calling foreign functions, and loading shared libraries. The CFFI frontend provides a declarative interface for defining foreign functions, structures, typedefs, enumerated types, etc. It is implemented in portable ANSI CL making use of the low-level operators exported by CFFI-SYS.</p>
<p>CFFI/C2FFI is a mechanism to automatically generate CFFI bindings based on the output of <a href="https://github.com/rpav/c2ffi">c2ffi</a>. Until it is properly documented please see [these]((https://github.com/hu-dwim/hu.dwim.bluez) <a href="https://github.com/hu-dwim/hu.dwim.zlib">projects</a> <a href="https://github.com/hu-dwim/hu.dwim.sdl">as</a> <a href="https://github.com/attila-lendvai/hu.dwim.mosquitto">examples</a>.</p>
<p>Please consult <a href="http://common-lisp.net/project/cffi/manual/html_node/">the manual</a> for further details, including installation instructions.</p>
<p>Please visit <a href="http://bugs.launchpad.net/cffi">Launchpad</a> for bug reports and feature suggestions.</p>
</div></div></div></div><h1 id="doc"><span class="directory">doc</span></h1><h2 id="doc/allegro-internals.txt"><span class="file">allegro-internals</span><span class="extension">txt</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/allegro-internals.txt">[source]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><p>July 2005 These details were kindly provided by Duane Rettig of Franz.</p>
<p>Regarding the following snippet of the macro expansion of FF:DEF-FOREIGN-CALL:</p>
<p>(SYSTEM::FF-FUNCALL (LOAD-TIME-VALUE (EXCL::DETERMINE-FOREIGN-ADDRESS ‘(“foo” :LANGUAGE :C) 2 NIL))’(:INT (INTEGER * <em>)) ARG1 ’(:DOUBLE (DOUBLE-FLOAT </em> <em>)) ARG2 ’(:INT (INTEGER </em> *)))</p>
<p>" … in Allegro CL, if you define a foreign call FOO with C entry point “foo” and with :call-direct t in the arguments, and if other things are satisfied, then if a lisp function BAR is compiled which has a call to FOO, that call will not go through ff-funcall (and thus a large amount of argument manipulation and processing) but will instead set up its arguments directly on the stack, and will then perform the “call” more or less directly, through the “entry vec” (a small structure which keeps track of a foreign entry’s address and status)."</p>
<p>This is the code that generates what the compiler expects to see:</p>
<p>(setq call-direct-form (if* call-direct then <code>(setf (get ',lispname 'sys::direct-ff-call)              (list ',external-name                    ,callback                    ,convention                    ',returning                    ',arg-types                    ,arg-checking                    ,entry-vec-flags))        else</code>(remprop ’,lispname ’sys::direct-ff-call)))</p>
<p>Thus generating something like:</p>
<pre><code>    (EVAL-WHEN (COMPILE LOAD EVAL)
      (SETF (GET &#39;FOO &#39;SYSTEM::DIRECT-FF-CALL)
            (LIST &#39;(&quot;foo&quot; :LANGUAGE :C) T :C
                  &#39;(:INT (INTEGER * *))
                  &#39;((:INT (INTEGER * *))
                    (:FLOAT (SINGLE-FLOAT * *)))
                  T
                  2 ; this magic value is explained later
                  )))</code></pre>
<p>" (defun determine-foreign-address (name &amp;optional (flags 0) method-index) ;; return an entry-vec struct suitable for the foreign-call of name. ;; ;; name is either a string, which is taken without conversion, or ;; a list consisting of a string to convert or a conversion function ;; call. ;; flags is an integer representing the flags to place into the entry-vec. ;; method-index, if non-nil, is a word-index into a vtbl (virtual table). ;; If method-index is true, then the name must be a string uniquely ;; represented by the index and by the flags field.</p>
<p>Note that not all architectures implement the :method-index argument to def-foreign-call, but your interface likely won’t support it anyway, so just leave it nil. As for the flags, they are constants stored into the entry-vec returned by d-f-a and are given here:</p>
<p>(defconstant ep-flag-call-semidirect 1) ; Real address stored in alt-address slot (defconstant ep-flag-never-release 2) ; Never release the heap (defconstant ep-flag-always-release 4) ; Always release the heap (defconstant ep-flag-release-when-ok 8) ; Release the heap unless without-interrupts</p>
<p>(defconstant ep-flag-tramp-calls #x70) ; Make calls through special trampolines (defconstant ep-flag-tramp-shift 4)</p>
<p>(defconstant ep-flag-variable-address #x100) ; Entry-point contains address of C var (defconstant ep-flag-strings-convert #x200) ; Convert strings automatically</p>
<p>(defconstant ep-flag-get-errno #x1000) ;; [rfe5060]: Get errno value after call (defconstant ep-flag-get-last-error #x2000) ;; [rfe5060]: call GetLastError after call ;; Leave #x4000 and #x8000 open for expansion</p>
<p>Mostly, you’ll give the value 2 (never release the heap), but if you give 4 or 8, then d-f-a will automatically set the 1 bit as well, which takes the call through a heap-release/reacquire process.</p>
<p>Some docs for entry-vec are:</p>
<p>;; – entry vec – ;; An entry-vec is an entry-point descriptor, usually a pointer into ;; a shared-library. It is represented as a 5-element struct of type ;; foreign-vector. The reason for this represntation is ;; that it allows the entry point to be stored in a table, called ;; the .saved-entry-points. table, and to be used by a foreign ;; function. When the location of the foreign function to which the entry ;; point refers changes, it is simply a matter of changing the value in entry ;; point vector and the foreign call code sees it immediately. There is ;; even an address that can be put in the entry point vector that denotes ;; a missing foreign function, thus lookup can happen dynamically.</p>
<p>(defstruct (entry-vec (:type (vector excl::foreign (<em>))) (:constructor make-entry-vec-boa ())) name ; entry point name (address 0) ; jump address for foreign code (handle 0) ; shared-lib handle (flags 0) ; ep-</em> flags (alt-address 0) ; sometimes holds the real func addr )</p>
<p>[…] "</p>
<p>Regarding the arguments to SYSTEM::FF-FUNCALL: ’(:int (integer * *)) argN</p>
<p>“The type-spec is as it is given in the def-foreign-call syntax, with a C type optionally followed by a lisp type, followed optionally by a user-conversion function name[…]”</p>
<p>Getting the alignment:</p>
<p>CL-USER(2): (ff:get-foreign-type :int) #S(FOREIGN-FUNCTIONS::IFOREIGN-TYPE :ATTRIBUTES NIL :SFTYPE #S(FOREIGN-FUNCTIONS::SIZED-FTYPE-PRIM :KIND :INT :WIDTH 4 :OFFSET 0 :ALIGN 4) …)</p>
</div></div></div></div><h2 id="doc/cffi-manual.texinfo"><span class="file">cffi-manual</span><span class="extension">texinfo</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/cffi-manual.texinfo">[source]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><p>Copyright © 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; Copyright © 2005-2015 Luís Oliveira &lt;loliveira at common-lisp.net&gt; Copyright © 2005-2006 Dan Knapp &lt;danka at accela.net&gt; Copyright © 2005-2006 Emily Backes &lt;lucca at accela.net&gt; Copyright © 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<h1 id="Top">cffi</h1>
<p>Copyright © 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; Copyright © 2005-2015 Luís Oliveira &lt;loliveira at common-lisp.net&gt; Copyright © 2005-2006 Dan Knapp &lt;danka at accela.net&gt; Copyright © 2005-2006 Emily Backes &lt;lucca at accela.net&gt; Copyright © 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<h1 id="Introduction">Introduction</h1>
<p>CFFI is the Common Foreign Function Interface for ANSI Common Lisp systems. By foreign function we mean a function written in another programming language and having different data and calling conventions than Common Lisp, namely, C. CFFI allows you to call foreign functions and access foreign variables, all without leaving the Lisp image.</p>
<p>We consider this manual ever a work in progress. If you have difficulty with anything CFFI-specific presented in the manual, please contact <a href="mailto:cffi-devel@common-lisp.net">the developers</a> with details.</p>
<p><strong>Motivation</strong></p>
<p>See <a href="#Tutorial_002dComparison">What makes Lisp different</a>, for an argument in favor of FFI in general.</p>
<p>CFFI’s primary role in any image is to mediate between Lisp developers and the widely varying FFIs present in the various Lisp implementations it supports. With CFFI, you can define foreign function interfaces while still maintaining portability between implementations. It is not the first Common Lisp package with this objective; however, it is meant to be a more malleable framework than similar packages.</p>
<p><strong>Design Philosophy</strong></p>
<ul>
<li><p>Pointers do not carry around type information. Instead, type information is supplied when pointers are dereferenced.</p></li>
<li><p>A type safe pointer interface can be developed on top of an untyped one. It is difficult to do the opposite.</p></li>
<li><p>Functions are better than macros. When a macro could be used for performance, use a compiler-macro instead.</p></li>
</ul>
<h1 id="Installation">Installation</h1>
<p>CFFI can be obtained through one of the following means available through its <a href="http://common-lisp.net/project/cffi/">website</a>:</p>
<ul>
<li><p><a href="http://common-lisp.net/project/cffi/releases/?M=D">official release tarballs</a></p></li>
<li><p><a href="http://common-lisp.net/gitweb?p=projects/cffi/cffi.git">git repository</a></p></li>
</ul>
<p>In addition, you will need to obtain and install the following dependencies:</p>
<ul>
<li><p><a href="http://common-lisp.net/project/babel/">Babel</a>, a charset encoding/decoding library.</p></li>
<li><p><a href="http://common-lisp.net/project/alexandria/">Alexandria</a>, a collection of portable public-domain utilities.</p></li>
<li><p><a href="http://www.cliki.net/trivial-features">trivial-features</a>, a portability layer that ensures consistent <code>*features*</code> across multiple Common Lisp implementations.</p></li>
</ul>
<p>Furthermore, if you wish to run the testsuite, <a href="http://www.cliki.net/rt">RT</a> is required.</p>
<p>You may find mechanisms such as <a href="https://www.quicklisp.org/beta/">Quicklisp</a> (recommended) or <a href="http://common-lisp.net/project/clbuild/">clbuild</a> (for advanced uses) helpful in getting and managing CFFI and its dependencies.</p>
<h1 id="Implementation-Support">Implementation Support</h1>
<p>CFFI supports various free and commercial Lisp implementations: ABCL, Allegro CL, Clasp, CLISP, Clozure CL, CMUCL, Corman CL, ECL, GCL, LispWorks, MCL, SBCL and the Scieneer CL.</p>
<p>In general, you should work with the latest versions of each implementation since those will usually be tested against recent versions of CFFI more often and might include necessary features or bug fixes. Reasonable patches for compatibility with earlier versions are welcome nevertheless.</p>
<h2>Limitations</h2>
<p>Some features are not supported in all implementations.</p>
<p><strong>Allegro CL</strong></p>
<ul>
<li><p>Does not support the <code>:long-long</code> type natively.</p></li>
<li><p>Unicode support is limited to the Basic Multilingual Plane (16-bit code points).</p></li>
</ul>
<p><strong>Clasp</strong></p>
<ul>
<li><p>Only supports a flat namespace.</p></li>
</ul>
<p><strong>CMUCL</strong></p>
<ul>
<li><p>No Unicode support. (8-bit code points)</p></li>
</ul>
<p><strong>Corman CL</strong></p>
<ul>
<li><p>Does not support <code>foreign-funcall</code>.</p></li>
</ul>
<p><strong>ECL</strong></p>
<ul>
<li><p>On platforms where ECL’s dynamic FFI is not supported (ie. when <code>:dffi</code> is not present in <code>*features*</code>), <code>cffi:load-foreign-library</code> does not work and you must use ECL’s own <code>ffi:load-foreign-library</code> with a constant string argument.</p></li>
</ul>
<p><strong>Lispworks</strong></p>
<ul>
<li><p>Does not completely support the <code>:long-long</code> type natively in 32-bit platforms.</p></li>
<li><p>Unicode support is limited to the Basic Multilingual Plane (16-bit code points).</p></li>
</ul>
<p><strong>SBCL</strong></p>
<ul>
<li><p>Not all platforms support callbacks.</p></li>
</ul>
<h1 id="Tutorial">An Introduction to Foreign Interfaces and CFFI</h1>
tutorial,
CFFI
<p>Users of many popular languages bearing semantic similarity to Lisp, such as Perl and Python, are accustomed to having access to popular C libraries, such as GTK, by way of “bindings”. In Lisp, we do something similar, but take a fundamentally different approach. This tutorial first explains this difference, then explains how you can use CFFI, a powerful system for calling out to C and C++ and access C data from many Common Lisp implementations.</p>
foreign functions and data
<p>The concept can be generalized to other languages; at the time of writing, only CFFI’s C support is fairly complete. Therefore, we will interchangeably refer to foreign functions and foreign data, and “C functions” and “C data”. At no time will the word “foreign” carry its usual, non-programming meaning.</p>
<p>This tutorial expects you to have a working understanding of both Common Lisp and C, including the Common Lisp macro system.</p>
<h2 id="Tutorial_002dComparison">What makes Lisp different</h2>
<p>The following sums up how bindings to foreign libraries are usually implemented in other languages, then in Common Lisp:</p>
<dl>
<dt>Perl, Python, Java, other one-implementation languages</dt>
<dd>SWIG
Perl
Python
<p>Bindings are implemented as shared objects written in C. In some cases, the C code is generated by a tool, such as SWIG, but the result is the same: a new C library that manually translates between the language implementation’s objects, such as <code>PyObject</code> in Python, and whatever C object is called for, often using C functions provided by the implementation. It also translates between the calling conventions of the language and C.</p>
</dd>
<dt>Common Lisp</dt>
<dd>SLIME
<p>Bindings are written in Lisp. They can be created at-will by Lisp programs. Lisp programmers can write new bindings and add them to the image, using a listener such as SLIME, as easily as with regular Lisp definitions. The only foreign library to load is the one being wrapped—the one with the pure C interface; no C or other non-Lisp compilation is required.</p>
</dd>
</dl>
advantages of
FFI
benefits of
FFI
<p>We believe the advantages of the Common Lisp approach far outweigh any disadvantages. Incremental development with a listener can be as productive for C binding development as it is with other Lisp development. Keeping it “in the [Lisp] family”, as it were, makes it much easier for you and other Lisp programmers to load and use the bindings. Common Lisp implementations such as CMUCL, freed from having to provide a C interface to their own objects, are thus freed to be implemented in another language (as CMUCL is) while still allowing programmers to call foreign functions.</p>
minimal bindings
<p>Perhaps the greatest advantage is that using an FFI doesn’t obligate you to become a professional binding developer. Writers of bindings for other languages usually end up maintaining or failing to maintain complete bindings to the foreign library. Using an FFI, however, means if you only need one or two functions, you can write bindings for only those functions, and be assured that you can just as easily add to the bindings if need be.</p>
C abstractions
abstractions in C
<p>The removal of the C compiler, or C interpretation of any kind, creates the main disadvantage: some of C’s “abstractions” are not available, violating information encapsulation. For example, <code>struct</code>s that must be passed on the stack, or used as return values, without corresponding functional abstractions to create and manage the <code>struct</code>s, must be declared explicitly in Lisp. This is fine for structs whose contents are “public”, but is not so pleasant when a struct is supposed to be “opaque” by convention, even though it is not so defined.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Without an abstraction to create the struct, Lisp needs to be able to lay out the struct in memory, so must know its internal details.</p>
workaround for C
<p>In these cases, you can create a minimal C library to provide the missing abstractions, without destroying all the advantages of the Common Lisp approach discussed above. In the case of <code>struct</code>s, you can write simple, pure C functions that tell you how many bytes a struct requires or allocate new structs, read and write fields of the struct, or whatever operations are supposed to be public.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a href="#The-Groveller">The Groveller</a> automates this and other processes.</p>
<p>Another disadvantage appears when you would rather use the foreign language than Lisp. However, someone who prefers C to Lisp is not a likely candidate for developing a Lisp interface to a C library.</p>
<h2 id="Tutorial_002dGetting-a-URL">Getting a URL</h2>
c
URL
<p>The widely available <code>libcurl</code> is a library for downloading files over protocols like HTTP. We will use <code>libcurl</code> with CFFI to download a web page.</p>
<p>Please note that there are many other ways to download files from the web, not least the CL-CURL project to provide bindings to <code>libcurl</code> via a similar FFI.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p><a href="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html">libcurl-tutorial(3)</a> is a tutorial for <code>libcurl</code> programming in C. We will follow that to develop a binding to download a file. We will also use <code>curl.h</code>, <code>easy.h</code>, and the <code>man</code> pages for the <code>libcurl</code> function, all available in the ‘<code>curl-dev</code>’ package or equivalent for your system, or in the cURL source code package. If you have the development package, the headers should be installed in <code>/usr/include/curl/</code>, and the <code>man</code> pages may be accessed through your favorite <code>man</code> facility.</p>
<h2 id="Tutorial_002dLoading">Loading foreign libraries</h2>
loading
CFFI
requiring
CFFI
<p>First of all, we will create a package to work in. You can save these forms in a file, or just send them to the listener as they are. If creating bindings for an ASDF package of yours, you will want to add <code>:cffi</code> to the <code>:depends-on</code> list in your <code>.asd</code> file. Otherwise, just use the <code>asdf:load-system</code> function to load CFFI.</p>
<pre><code>(asdf:load-system :cffi)

;;; Nothing special about the &quot;CFFI-USER&quot; package.  We&#39;re just
;;; using it as a substitute for your own CL package.
(defpackage :cffi-user
  (:use :common-lisp :cffi))

(in-package :cffi-user)

(define-foreign-library libcurl
  (:darwin (:or &quot;libcurl.3.dylib&quot; &quot;libcurl.dylib&quot;))
  (:unix (:or &quot;libcurl.so.3&quot; &quot;libcurl.so&quot;))
  (t (:default &quot;libcurl&quot;)))

(use-foreign-library libcurl)</code></pre>
foreign library load
library, foreign
<p>Using <code>define-foreign-library</code> and <code>use-foreign-library</code>, we have loaded <code>libcurl</code> into Lisp, much as the linker does when you start a C program, or <code>common-lisp:load</code> does with a Lisp source file or FASL file. We special-cased for UNIX machines to always load a particular version, the one this tutorial was tested with; for those who don’t care, the <code>define-foreign-library</code> clause <code>(t (:default "libcurl"))</code> should be satisfactory, and will adapt to various operating systems.</p>
<h2 id="Tutorial_002dInitializing">Initializing <code>libcurl</code></h2>
function definition
<p>After the introductory matter, the tutorial goes on to present the first function you should use.</p>
<pre><code>CURLcode curl_global_init(long flags);</code></pre>
<p>Let’s pick this apart into appropriate Lisp code:</p>
<pre><code>;;; A CURLcode is the universal error code.  curl/curl.h says
;;; no return code will ever be removed, and new ones will be
;;; added to the end.
(defctype curl-code :int)

;;; Initialize libcurl with FLAGS.
(defcfun &quot;curl_global_init&quot; curl-code
  (flags :long))</code></pre>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>By default, CFFI assumes the UNIX viewpoint that there is one C symbol namespace, containing all symbols in all loaded objects. This is not so on Windows and Darwin, but we emulate UNIX’s behaviour there. <a href="#defcfun">defcfun</a> for more details.</em></p>
</blockquote>
<p>Note the parallels with the original C declaration. We’ve defined <code>curl-code</code> as a wrapping type for <code>:int</code>; right now, it only marks it as special, but later we will do something more interesting with it. The point is that we don’t have to do it yet.</p>
calling foreign functions
<p>Looking at <code>curl.h</code>, <code>CURL_GLOBAL_NOTHING</code>, a possible value for <code>flags</code> above, is defined as ‘<code>0</code>’. So we can now call the function:</p>
<pre><code>CFFI-USER&gt; (curl-global-init 0)
⇒ 0</code></pre>
looks like it worked
<p>Looking at <code>curl.h</code> again, <code>0</code> means <code>CURLE_OK</code>, so it looks like the call succeeded. Note that CFFI converted the function name to a Lisp-friendly name. You can specify your own name if you want; use <code>("curl_global_init" your-name-here)</code> as the name argument to <code>defcfun</code>.</p>
<p>The tutorial goes on to have us allocate a handle. For good measure, we should also include the deallocator. Let’s look at these functions:</p>
<pre><code>CURL *curl_easy_init( );
void curl_easy_cleanup(CURL *handle);</code></pre>
<p>Advanced users may want to define special pointer types; we will explore this possibility later. For now, just treat every pointer as the same:</p>
<pre><code>(defcfun &quot;curl_easy_init&quot; :pointer)

(defcfun &quot;curl_easy_cleanup&quot; :void
  (easy-handle :pointer))</code></pre>
<p>Now we can continue with the tutorial:</p>
<pre><code>CFFI-USER&gt; (defparameter *easy-handle* (curl-easy-init))
⇒ *EASY-HANDLE*
CFFI-USER&gt; *easy-handle*
⇒ #&lt;FOREIGN-ADDRESS #x09844EE0&gt;</code></pre>
pointers in Lisp
<p>Note the print representation of a pointer. It changes depending on what Lisp you are using, but that doesn’t make any difference to CFFI.</p>
<h2 id="Tutorial_002deasy_005fsetopt">Setting download options</h2>
<p>The <code>libcurl</code> tutorial says we’ll want to set many options before performing any download actions. This is done through <code>curl_easy_setopt</code>:</p>
<pre><code>CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);</code></pre>
varargs
foreign arguments
<p>We’ve introduced a new twist: variable arguments. There is no obvious translation to the <code>defcfun</code> form, particularly as there are four possible argument types. Because of the way C works, we could define four wrappers around <code>curl_easy_setopt</code>, one for each type; in this case, however, we’ll use the general-purpose macro <code>foreign-funcall</code> to call this function.</p>
enumeration, C
<p>To make things easier on ourselves, we’ll create an enumeration of the kinds of options we want to set. The <code>enum CURLoption</code> isn’t the most straightforward, but reading the <code>CINIT</code> C macro definition should be enlightening.</p>
<pre><code>(defmacro define-curl-options (name type-offsets &amp;rest enum-args)
  &quot;As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:

    (NAME TYPE NUMBER)

Where the arguments are as they are with the CINIT macro defined
in curl.h, except NAME is a keyword.

TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
defined by the CURLOPTTYPE_LONG et al constants in curl.h.&quot;
  (flet ((enumerated-value (type offset)
           (+ (getf type-offsets type) offset)))
    `(progn
       (defcenum ,name
         ,@(loop for (name type number) in enum-args
              collect (list name (enumerated-value type number))))
       &#39;,name)))                ;for REPL users&#39; sanity

(define-curl-options curl-option
    (long 0 objectpoint 10000 functionpoint 20000 off-t 30000)
  (:noprogress long 43)
  (:nosignal long 99)
  (:errorbuffer objectpoint 10)
  (:url objectpoint 2))</code></pre>
<p>With some well-placed Emacs <code>query-replace-regexp</code>s, you could probably similarly define the entire <code>CURLoption</code> enumeration. I have selected to transcribe a few that we will use in this tutorial.</p>
<p>If you’re having trouble following the macrology, just macroexpand the <code>curl-option</code> definition, or see the following macroexpansion, conveniently downcased and reformatted:</p>
<pre><code>(progn
  (defcenum curl-option
    (:noprogress 43)
    (:nosignal 99)
    (:errorbuffer 10010)
    (:url 10002))
  &#39;curl-option)</code></pre>
<p>That seems more than reasonable. You may notice that we only use the type to compute the real enumeration offset; we will also need the type information later.</p>
<p>First, however, let’s make sure a simple call to the foreign function works:</p>
<pre><code>CFFI-USER&gt; (foreign-funcall &quot;curl_easy_setopt&quot;
               :pointer *easy-handle*
               curl-option :nosignal :long 1 curl-code)
⇒ 0</code></pre>
<p><code>foreign-funcall</code>, despite its surface simplicity, can be used to call any C function. Its first argument is a string, naming the function to be called. Next, for each argument, we pass the name of the C type, which is the same as in <code>defcfun</code>, followed by a Lisp object representing the data to be passed as the argument. The final argument is the return type, for which we use the <code>curl-code</code> type defined earlier.</p>
<p><code>defcfun</code> just puts a convenient façade on <code>foreign-funcall</code>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Our earlier call to <code>curl-global-init</code> could have been written as follows:</p>
<pre><code>CFFI-USER&gt; (foreign-funcall &quot;curl_global_init&quot; :long 0
                            curl-code)
⇒ 0</code></pre>
<p>Before we continue, we will take a look at what CFFI can and can’t do, and why this is so.</p>
<h2 id="Tutorial_002dAbstraction">Breaking the abstraction</h2>
breaking the abstraction
abstraction breaking
<p>In <a href="#Tutorial_002dComparison">What makes Lisp different</a>, we mentioned that writing an FFI sometimes requires depending on information not provided as part of the interface. The easy option <code>CURLOPT_WRITEDATA</code>, which we will not provide as part of the Lisp interface, illustrates this issue.</p>
<p>Strictly speaking, the <code>curl-option</code> enumeration is not necessary; we could have used <code>:int 99</code> instead of <code>curl-option :nosignal</code> in our call to <code>curl_easy_setopt</code> above. We defined it anyway, in part to hide the fact that we are breaking the abstraction that the C <code>enum</code> provides. If the cURL developers decide to change those numbers later, we must change the Lisp enumeration, because enumeration values are not provided in the compiled C library, <code>libcurl.so.3</code>.</p>
<p>CFFI works because the most useful things in C libraries — non-static functions and non-static variables — are included accessibly in <code>libcurl.so.3</code>. A C compiler that violated this would be considered a worthless compiler.</p>
<p>The other thing <code>define-curl-options</code> does is give the “type” of the third argument passed to <code>curl_easy_setopt</code>. Using this information, we can tell that the <code>:nosignal</code> option should accept a long integer argument. We can implicitly assume <code>t</code> ≡ 1 and <code>nil</code> ≡ 0, as it is in C, which takes care of the fact that <code>CURLOPT_NOSIGNAL</code> is really asking for a boolean.</p>
<p>The “type” of <code>CURLOPT_WRITEDATA</code> is <code>objectpoint</code>. However, it is really looking for a <code>FILE*</code>. <code>CURLOPT_ERRORBUFFER</code> is looking for a <code>char*</code>, so there is no obvious CFFI type but <code>:pointer</code>.</p>
<p>The first thing to note is that nowhere in the C interface includes this information; it can only be found in the manual. We could disjoin these clearly different types ourselves, by splitting <code>objectpoint</code> into <code>filepoint</code> and <code>charpoint</code>, but we are still breaking the abstraction, because we have to augment the entire enumeration form with this additional information.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
streams and C
FILE* and streams
<p>The second is that the <code>CURLOPT_WRITEDATA</code> argument is completely incompatible with the desired Lisp data, a stream.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> It is probably acceptable if we are controlling every file we might want to use as this argument, in which case we can just call the foreign function <code>fopen</code>. Regardless, though, we can’t write to arbitrary streams, which is exactly what we want to do for this application.</p>
<p>Finally, note that the <code>curl_easy_setopt</code> interface itself is a hack, intended to work around some of the drawbacks of C. The definition of <code>Curl_setopt</code>, while long, is far less cluttered than the equivalent disjoint-function set would be; in addition, setting a new option in an old <code>libcurl</code> can generate a run-time error rather than breaking the compile. Lisp can just as concisely generate functions as compare values, and the “undefined function” error is just as useful as any explicit error we could define here might be.</p>
<h2 id="Tutorial_002dLisp-easy_005fsetopt">Option functions in Lisp</h2>
<p>We could use <code>foreign-funcall</code> directly every time we wanted to call <code>curl_easy_setopt</code>. However, we can encapsulate some of the necessary information with the following.</p>
<pre><code>;;; We will use this type later in a more creative way.  For
;;; now, just consider it a marker that this isn&#39;t just any
;;; pointer.
(defctype easy-handle :pointer)

(defmacro curl-easy-setopt (easy-handle enumerated-name
                            value-type new-value)
  &quot;Call `curl_easy_setopt&#39; on EASY-HANDLE, using ENUMERATED-NAME
as the OPTION.  VALUE-TYPE is the CFFI foreign type of the third
argument, and NEW-VALUE is the Lisp data to be translated to the
third argument.  VALUE-TYPE is not evaluated.&quot;
  `(foreign-funcall &quot;curl_easy_setopt&quot; easy-handle ,easy-handle
                    curl-option ,enumerated-name
                    ,value-type ,new-value curl-code))</code></pre>
<p>Now we define a function for each kind of argument that encodes the correct <code>value-type</code> in the above. This can be done reasonably in the <code>define-curl-options</code> macroexpansion; after all, that is where the different options are listed!</p>
Lispy C functions
<p>We could make <code>cl:defun</code> forms in the expansion that simply call <code>curl-easy-setopt</code>; however, it is probably easier and clearer to use <code>defcfun</code>. <code>define-curl-options</code> was becoming unwieldy, so I defined some helpers in this new definition.</p>
<pre><code>(defun curry-curl-option-setter (function-name option-keyword)
  &quot;Wrap the function named by FUNCTION-NAME with a version that
curries the second argument as OPTION-KEYWORD.

This function is intended for use in DEFINE-CURL-OPTION-SETTER.&quot;
  (setf (symbol-function function-name)
          (let ((c-function (symbol-function function-name)))
            (lambda (easy-handle new-value)
              (funcall c-function easy-handle option-keyword
                       new-value)))))

(defmacro define-curl-option-setter (name option-type
                                     option-value foreign-type)
  &quot;Define (with DEFCFUN) a function NAME that calls
curl_easy_setopt.  OPTION-TYPE and OPTION-VALUE are the CFFI
foreign type and value to be passed as the second argument to
easy_setopt, and FOREIGN-TYPE is the CFFI foreign type to be used
for the resultant function&#39;s third argument.

This macro is intended for use in DEFINE-CURL-OPTIONS.&quot;
  `(progn
     (defcfun (&quot;curl_easy_setopt&quot; ,name) curl-code
       (easy-handle easy-handle)
       (option ,option-type)
       (new-value ,foreign-type))
     (curry-curl-option-setter &#39;,name &#39;,option-value)))

(defmacro define-curl-options (type-name type-offsets &amp;rest enum-args)
  &quot;As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:

    (NAME TYPE NUMBER)

Where the arguments are as they are with the CINIT macro defined
in curl.h, except NAME is a keyword.

TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
defined by the CURLOPTTYPE_LONG et al constants in curl.h.

Also, define functions for each option named
set-`TYPE-NAME&#39;-`OPTION-NAME&#39;, where OPTION-NAME is the NAME from
the above destructuring.&quot;
  (flet ((enumerated-value (type offset)
           (+ (getf type-offsets type) offset))
         ;; map PROCEDURE, destructuring each of ENUM-ARGS
         (map-enum-args (procedure)
           (mapcar (lambda (arg) (apply procedure arg)) enum-args))
         ;; build a name like SET-CURL-OPTION-NOSIGNAL
         (make-setter-name (option-name)
           (intern (concatenate
                    &#39;string &quot;SET-&quot; (symbol-name type-name)
                    &quot;-&quot; (symbol-name option-name)))))
    `(progn
       (defcenum ,type-name
         ,@(map-enum-args
            (lambda (name type number)
              (list name (enumerated-value type number)))))
       ,@(map-enum-args
          (lambda (name type number)
            (declare (ignore number))
            `(define-curl-option-setter ,(make-setter-name name)
               ,type-name ,name ,(ecase type
                                   (long :long)
                                   (objectpoint :pointer)
                                   (functionpoint :pointer)
                                   (off-t :long)))))
       &#39;,type-name)))</code></pre>
<p>Macroexpanding our <code>define-curl-options</code> form once more, we see something different:</p>
<pre><code>(progn
  (defcenum curl-option
    (:noprogress 43)
    (:nosignal 99)
    (:errorbuffer 10010)
    (:url 10002))
  (define-curl-option-setter set-curl-option-noprogress
    curl-option :noprogress :long)
  (define-curl-option-setter set-curl-option-nosignal
    curl-option :nosignal :long)
  (define-curl-option-setter set-curl-option-errorbuffer
    curl-option :errorbuffer :pointer)
  (define-curl-option-setter set-curl-option-url
    curl-option :url :pointer)
  &#39;curl-option)</code></pre>
<p>Macroexpanding one of the new <code>define-curl-option-setter</code> forms yields the following:</p>
<pre><code>(progn
  (defcfun (&quot;curl_easy_setopt&quot; set-curl-option-nosignal) curl-code
    (easy-handle easy-handle)
    (option curl-option)
    (new-value :long))
  (curry-curl-option-setter &#39;set-curl-option-nosignal &#39;:nosignal))</code></pre>
<p>Finally, let’s try this out:</p>
<pre><code>CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
⇒ 0</code></pre>
<p>Looks like it works just as well. This interface is now reasonably high-level to wash out some of the ugliness of the thinnest possible <code>curl_easy_setopt</code> FFI, without obscuring the remaining C bookkeeping details we will explore.</p>
<h2 id="Tutorial_002dMemory">Memory management</h2>
<p>According to the documentation for <code>curl_easy_setopt</code>, the type of the third argument when option is <code>CURLOPT_ERRORBUFFER</code> is <code>char*</code>. Above, we’ve defined <code>set-curl-option-errorbuffer</code> to accept a <code>:pointer</code> as the new option value. However, there is a CFFI type <code>:string</code>, which translates Lisp strings to C strings when passed as arguments to foreign function calls. Why not, then, use <code>:string</code> as the CFFI type of the third argument? There are two reasons, both related to the necessity of breaking abstraction described in <a href="#Tutorial_002dAbstraction">Breaking the abstraction</a>.</p>
<p>The first reason also applies to <code>CURLOPT_URL</code>, which we will use to illustrate the point. Assuming we have changed the type of the third argument underlying <code>set-curl-option-url</code> to <code>:string</code>, look at these two equivalent forms.</p>
<pre><code>(set-curl-option-url *easy-handle* &quot;http://www.cliki.net/CFFI&quot;)

≡ (with-foreign-string (url &quot;http://www.cliki.net/CFFI&quot;)
     (foreign-funcall &quot;curl_easy_setopt&quot; easy-handle *easy-handle*
                      curl-option :url :pointer url curl-code))</code></pre>
<p>The latter, in fact, is mostly equivalent to what a foreign function call’s macroexpansion actually does. As you can see, the Lisp string <code>"http://www.cliki.net/CFFI"</code> is copied into a <code>char</code> array and null-terminated; the pointer to beginning of this array, now a C string, is passed as a CFFI <code>:pointer</code> to the foreign function.</p>
dynamic extent
foreign values with dynamic extent
<p>Unfortunately, the C abstraction has failed us, and we must break it. While <code>:string</code> works well for many <code>char*</code> arguments, it does not for cases like this. As the <code>curl_easy_setopt</code> documentation explains, “The string must remain present until curl no longer needs it, as it doesn’t copy the string.” The C string created by <code>with-foreign-string</code>, however, only has dynamic extent: it is “deallocated” when the body (above containing the <code>foreign-funcall</code> form) exits.</p>
premature deallocation
<p>If we are supposed to keep the C string around, but it goes away, what happens when some <code>libcurl</code> function tries to access the URL string? We have reentered the dreaded world of C “undefined behavior”. In some Lisps, it will probably get a chunk of the Lisp/C stack. You may segfault. You may get some random piece of other data from the heap. Maybe, in a world where “dynamic extent” is defined to be “infinite extent”, everything will turn out fine. Regardless, results are likely to be almost universally unpleasant.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>Returning to the current <code>set-curl-option-url</code> interface, here is what we must do:</p>
<pre><code>(let (easy-handle)
  (unwind-protect
    (with-foreign-string (url &quot;http://www.cliki.net/CFFI&quot;)
      (setf easy-handle (curl-easy-init))
      (set-curl-option-url easy-handle url)
      #|do more with the easy-handle, like actually get the URL|#)
    (when easy-handle
      (curl-easy-cleanup easy-handle))))</code></pre>
<p>That is fine for the single string defined here, but for every string option we want to pass, we have to surround the body of <code>with-foreign-string</code> with another <code>with-foreign-string</code> wrapper, or else do some extremely error-prone pointer manipulation and size calculation in advance. We could alleviate some of the pain with a recursively expanding macro, but this would not remove the need to modify the block every time we want to add an option, anathema as it is to a modular interface.</p>
<p>Before modifying the code to account for this case, consider the other reason we can’t simply use <code>:string</code> as the foreign type. In C, a <code>char *</code> is a <code>char *</code>, not necessarily a string. The option <code>CURLOPT_ERRORBUFFER</code> accepts a <code>char *</code>, but does not expect anything about the data there. However, it does expect that some <code>libcurl</code> function we call later can write a C string of up to 255 characters there. We, the callers of the function, are expected to read the C string at a later time, exactly the opposite of what <code>:string</code> implies.</p>
<p>With the semantics for an input string in mind — namely, that the string should be kept around until we <code>curl_easy_cleanup</code> the easy handle — we are ready to extend the Lisp interface:</p>
<pre><code>(defvar *easy-handle-cstrings* (make-hash-table)
  &quot;Hashtable of easy handles to lists of C strings that may be
safely freed after the handle is freed.&quot;)

(defun make-easy-handle ()
  &quot;Answer a new CURL easy interface handle, to which the lifetime
of C strings may be tied.  See `add-curl-handle-cstring&#39;.&quot;
  (let ((easy-handle (curl-easy-init)))
    (setf (gethash easy-handle *easy-handle-cstrings*) &#39;())
    easy-handle))

(defun free-easy-handle (handle)
  &quot;Free CURL easy interface HANDLE and any C strings created to
be its options.&quot;
  (curl-easy-cleanup handle)
  (mapc #&#39;foreign-string-free
        (gethash handle *easy-handle-cstrings*))
  (remhash handle *easy-handle-cstrings*))

(defun add-curl-handle-cstring (handle cstring)
  &quot;Add CSTRING to be freed when HANDLE is, answering CSTRING.&quot;
  (car (push cstring (gethash handle *easy-handle-cstrings*))))</code></pre>
<p>Here we have redefined the interface to create and free handles, to associate a list of allocated C strings with each handle while it exists. The strategy of using different function names to wrap around simple foreign functions is more common than the solution implemented earlier with <code>curry-curl-option-setter</code>, which was to modify the function name’s function slot.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>Incidentally, the next step is to redefine <code>curry-curl-option-setter</code> to allocate C strings for the appropriate length of time, given a Lisp string as the <code>new-value</code> argument:</p>
<pre><code>(defun curry-curl-option-setter (function-name option-keyword)
  &quot;Wrap the function named by FUNCTION-NAME with a version that
curries the second argument as OPTION-KEYWORD.

This function is intended for use in DEFINE-CURL-OPTION-SETTER.&quot;
  (setf (symbol-function function-name)
          (let ((c-function (symbol-function function-name)))
            (lambda (easy-handle new-value)
              (funcall c-function easy-handle option-keyword
                       (if (stringp new-value)
                         (add-curl-handle-cstring
                          easy-handle
                          (foreign-string-alloc new-value))
                         new-value))))))</code></pre>
<p>A quick analysis of the code shows that you need only reevaluate the <code>curl-option</code> enumeration definition to take advantage of these new semantics. Now, for good measure, let’s reallocate the handle with the new functions we just defined, and set its URL:</p>
<pre><code>CFFI-USER&gt; (curl-easy-cleanup *easy-handle*)
⇒ NIL
CFFI-USER&gt; (setf *easy-handle* (make-easy-handle))
⇒ #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
⇒ 0
CFFI-USER&gt; (set-curl-option-url *easy-handle*
                                &quot;http://www.cliki.net/CFFI&quot;)
⇒ 0</code></pre>
strings
<p>For fun, let’s inspect the Lisp value of the C string that was created to hold <code>"http://www.cliki.net/CFFI"</code>. By virtue of the implementation of <code>add-curl-handle-cstring</code>, it should be accessible through the hash table defined:</p>
<pre><code>CFFI-USER&gt; (foreign-string-to-lisp
            (car (gethash *easy-handle* *easy-handle-cstrings*)))
⇒ &quot;http://www.cliki.net/CFFI&quot;</code></pre>
<p>Looks like that worked, and <code>libcurl</code> now knows what URL we want to retrieve.</p>
<p>Finally, we turn back to the <code>:errorbuffer</code> option mentioned at the beginning of this section. Whereas the abstraction added to support string inputs works fine for cases like <code>CURLOPT_URL</code>, it hides the detail of keeping the C string; for <code>:errorbuffer</code>, however, we need that C string.</p>
<p>In a moment, we’ll define something slightly cleaner, but for now, remember that you can always hack around anything. We’re modifying handle creation, so make sure you free the old handle before redefining <code>free-easy-handle</code>.</p>
<pre><code>(defvar *easy-handle-errorbuffers* (make-hash-table)
  &quot;Hashtable of easy handles to C strings serving as error
writeback buffers.&quot;)

;;; An extra byte is very little to pay for peace of mind.
(defparameter *curl-error-size* 257
  &quot;Minimum char[] size used by cURL to report errors.&quot;)

(defun make-easy-handle ()
  &quot;Answer a new CURL easy interface handle, to which the lifetime
of C strings may be tied.  See `add-curl-handle-cstring&#39;.&quot;
  (let ((easy-handle (curl-easy-init)))
    (setf (gethash easy-handle *easy-handle-cstrings*) &#39;())
    (setf (gethash easy-handle *easy-handle-errorbuffers*)
            (foreign-alloc :char :count *curl-error-size*
                           :initial-element 0))
    easy-handle))

(defun free-easy-handle (handle)
  &quot;Free CURL easy interface HANDLE and any C strings created to
be its options.&quot;
  (curl-easy-cleanup handle)
  (foreign-free (gethash handle *easy-handle-errorbuffers*))
  (remhash handle *easy-handle-errorbuffers*)
  (mapc #&#39;foreign-string-free
        (gethash handle *easy-handle-cstrings*))
  (remhash handle *easy-handle-cstrings*))

(defun get-easy-handle-error (handle)
  &quot;Answer a string containing HANDLE&#39;s current error message.&quot;
  (foreign-string-to-lisp
   (gethash handle *easy-handle-errorbuffers*)))</code></pre>
<p>Be sure to once again set the options we’ve set thus far. You may wish to define yet another wrapper function to do this.</p>
<h2 id="Tutorial_002dCallbacks">Calling Lisp from C</h2>
<p>If you have been reading <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html"><code>curl_easy_setopt(3)</code></a>, you should have noticed that some options accept a function pointer. In particular, we need one function pointer to set as <code>CURLOPT_WRITEFUNCTION</code>, to be called by <code>libcurl</code> rather than the reverse, in order to receive data as it is downloaded.</p>
<p>A binding writer without the aid of FFI usually approaches this problem by writing a C function that accepts C data, converts to the language’s internal objects, and calls the callback provided by the user, again in a reverse of usual practices.</p>
<p>The CFFI approach to callbacks precisely mirrors its differences with the non-FFI approach on the “calling C from Lisp” side, which we have dealt with exclusively up to now. That is, you define a callback function in Lisp using <code>defcallback</code>, and CFFI effectively creates a C function to be passed as a function pointer.</p>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>This is much trickier than calling C functions from Lisp, as it literally involves somehow generating a new C function that is as good as any created by the compiler. Therefore, not all Lisps support them. See <a href="#Implementation-Support">Implementation Support</a>, for information about CFFI support issues in this and other areas. You may want to consider changing to a Lisp that supports callbacks in order to continue with this tutorial.</em></p>
</blockquote>
callback definition
defining callbacks
<p>Defining a callback is very similar to defining a callout; the main difference is that we must provide some Lisp forms to be evaluated as part of the callback. Here is the signature for the function the <code>:writefunction</code> option takes:</p>
<pre><code>size_t
function(void *ptr, size_t size, size_t nmemb, void *stream);</code></pre>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>size_t is almost always an unsigned int. You can get this and many other types using feature tests for your system by using cffi-grovel.</em></p>
</blockquote>
<p>The above signature trivially translates into a CFFI <code>defcallback</code> form, as follows.</p>
<pre><code>;;; Alias in case size_t changes.
(defctype size :unsigned-int)

;;; To be set as the CURLOPT_WRITEFUNCTION of every easy handle.
(defcallback easy-write size ((ptr :pointer) (size size)
                              (nmemb size) (stream :pointer))
  (let ((data-size (* size nmemb)))
    (handler-case
      ;; We use the dynamically-bound *easy-write-procedure* to
      ;; call a closure with useful lexical context.
      (progn (funcall (symbol-value &#39;*easy-write-procedure*)
                      (foreign-string-to-lisp ptr :count data-size))
             data-size)         ;indicates success
      ;; The WRITEFUNCTION should return something other than the
      ;; #bytes available to signal an error.
      (error () (if (zerop data-size) 1 0)))))</code></pre>
<p>First, note the correlation of the first few forms, used to declare the C function’s signature, with the signature in C syntax. We provide a Lisp name for the function, its return type, and a name and type for each argument.</p>
<p>In the body, we call the dynamically-bound <code>*easy-write-procedure*</code> with a “finished” translation, of pulling together the raw data and size into a Lisp string, rather than deal with the data directly. As part of calling <code>curl_easy_perform</code> later, we’ll bind that variable to a closure with more useful lexical bindings than the top-level <code>defcallback</code> form.</p>
<p>Finally, we make a halfhearted effort to prevent non-local exits from unwinding the C stack, covering the most likely case with an <code>error</code> handler, which is usually triggered unexpectedly.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> The reason is that most C code is written to understand its own idiosyncratic error condition, implemented above in the case of <code>curl_easy_perform</code>, and more “undefined behavior” can result if we just wipe C stack frames without allowing them to execute whatever cleanup actions as they like.</p>
<p>Using the <code>CURLoption</code> enumeration in <code>curl.h</code> once more, we can describe the new option by modifying and reevaluating <code>define-curl-options</code>.</p>
<pre><code>(define-curl-options curl-option
    (long 0 objectpoint 10000 functionpoint 20000 off-t 30000)
  (:noprogress long 43)
  (:nosignal long 99)
  (:errorbuffer objectpoint 10)
  (:url objectpoint 2)
  (:writefunction functionpoint 11)) ;new item here</code></pre>
<p>Finally, we can use the defined callback and the new <code>set-curl-option-writefunction</code> to finish configuring the easy handle, using the <code>callback</code> macro to retrieve a CFFI <code>:pointer</code>, which works like a function pointer in C code.</p>
<pre><code>CFFI-USER&gt; (set-curl-option-writefunction
            *easy-handle* (callback easy-write))
⇒ 0</code></pre>
<h2 id="Tutorial_002dCompletion">A complete FFI?</h2>
<p>With all options finally set and a medium-level interface developed, we can finish the definition and retrieve <a href="http://www.cliki.net/CFFI">http://www.cliki.net/CFFI</a>, as is done in the tutorial.</p>
<pre><code>(defcfun &quot;curl_easy_perform&quot; curl-code
  (handle easy-handle))</code></pre>
<pre><code>CFFI-USER&gt; (with-output-to-string (contents)
             (let ((*easy-write-procedure*
                     (lambda (string)
                       (write-string string contents))))
               (declare (special *easy-write-procedure*))
               (curl-easy-perform *easy-handle*)))
⇒ &quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01//EN\&quot;
...
Now fear, comprehensively&lt;/P&gt;
&quot;</code></pre>
<p>Of course, that itself is slightly unwieldy, so you may want to define a function around it that simply retrieves a URL. I will leave synthesis of all the relevant REPL forms presented thus far into a single function as an exercise for the reader.</p>
<p>The remaining sections of this tutorial explore some advanced features of CFFI; the definition of new types will receive special attention. Some of these features are essential for particular foreign function calls; some are very helpful when trying to develop a Lispy interface to C.</p>
<h2 id="Tutorial_002dTypes">Defining new types</h2>
<p>We’ve occasionally used the <code>defctype</code> macro in previous sections as a kind of documentation, much what you’d use <code>typedef</code> for in C. We also tried one special kind of type definition, the <code>defcenum</code> type. See <a href="#defcstruct">defcstruct</a>, for a definition macro that may come in handy if you need to use C <code>struct</code>s as data.</p>
type definition
data in Lisp and C
translating types
<p>However, all of these are mostly sugar for the powerful underlying foreign type interface called type translators. You can easily define new translators for any simple named foreign type. Since we’ve defined the new type <code>curl-code</code> to use as the return type for various <code>libcurl</code> functions, we can use that to directly convert cURL errors to Lisp errors.</p>
<p><code>defctype</code>’s purpose is to define simple <code>typedef</code>-like aliases. In order to use type translators we must use the <code>define-foreign-type</code> macro. So let’s redefine <code>curl-code</code> using it.</p>
<pre><code>(define-foreign-type curl-code-type ()
  ()
  (:actual-type :int)
  (:simple-parser curl-code))</code></pre>
<p><code>define-foreign-type</code> is a thin wrapper around <code>defclass</code>. For now, all you need to know in the context of this example is that it does what <code>(defctype curl-code :int)</code> would do and, additionally, defines a new class <code>curl-code-type</code> which we will take advantage of shortly.</p>
<p>The <code>CURLcode</code> enumeration seems to follow the typical error code convention of ‘<code>0</code>’ meaning all is well, and each non-zero integer indicating a different kind of error. We can apply that trivially to differentiate between normal exits and error exits.</p>
<pre><code>(define-condition curl-code-error (error)
  (($code :initarg :curl-code :reader curl-error-code))
  (:report (lambda (c stream)
             (format stream &quot;libcurl function returned error ~A&quot;
                            (curl-error-code c))))
  (:documentation &quot;Signalled when a libcurl function answers
a code other than CURLE_OK.&quot;))

(defmethod translate-from-foreign (value (type curl-code-type))
  &quot;Raise a CURL-CODE-ERROR if VALUE, a curl-code, is non-zero.&quot;
  (if (zerop value)
      :curle-ok
      (error &#39;curl-code-error :curl-code value)))</code></pre>
<p>The heart of this translator is new method <code>translate-from-foreign</code>. By specializing the type parameter on <code>curl-code-type</code>, we immediately modify the behavior of every function that returns a <code>curl-code</code> to pass the result through this new method.</p>
<p>To see the translator in action, try invoking a function that returns a <code>curl-code</code>. You need to reevaluate the respective <code>defcfun</code> form so that it picks up the new <code>curl-code</code> definition.</p>
<pre><code>CFFI-USER&gt; (set-curl-option-nosignal *easy-handle* 1)
⇒ :CURLE-OK</code></pre>
<p>As the result was ‘<code>0</code>’, the new method returned <code>:curle-ok</code>, just as specified.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> I will leave disjoining the separate <code>CURLcode</code>s into condition types and improving the <code>:report</code> function as an exercise for you.</p>
<p>The creation of <code>*easy-handle-cstrings*</code> and <code>*easy-handle-errorbuffers*</code> as properties of <code>easy-handle</code>s is a kluge. What we really want is a Lisp structure that stores these properties along with the C pointer. Unfortunately, <code>easy-handle</code> is currently just a fancy name for the foreign type <code>:pointer</code>; the actual pointer object varies from Common Lisp implementation to implementation, needing only to satisfy <code>pointerp</code> and be returned from <code>make-pointer</code> and friends.</p>
<p>One solution that would allow us to define a new Lisp structure to represent <code>easy-handle</code>s would be to write a wrapper around every function that currently takes an <code>easy-handle</code>; the wrapper would extract the pointer and pass it to the foreign function. However, we can use type translators to more elegantly integrate this “translation” into the foreign function calling framework, using <code>translate-to-foreign</code>.</p>
<pre><code>(defclass easy-handle ()
  ((pointer :initform (curl-easy-init)
            :documentation &quot;Foreign pointer from curl_easy_init&quot;)
   (error-buffer
    :initform (foreign-alloc :char :count *curl-error-size*
                             :initial-element 0)
    :documentation &quot;C string describing last error&quot;)
   (c-strings :initform &#39;()
              :documentation &quot;C strings set as options&quot;))
  (:documentation &quot;I am a parameterization you may pass to
curl-easy-perform to perform a cURL network protocol request.&quot;))

(defmethod initialize-instance :after ((self easy-handle) &amp;key)
  (set-curl-option-errorbuffer self (slot-value self &#39;error-buffer)))

(defun add-curl-handle-cstring (handle cstring)
  &quot;Add CSTRING to be freed when HANDLE is, answering CSTRING.&quot;
  (car (push cstring (slot-value handle &#39;c-strings))))

(defun get-easy-handle-error (handle)
  &quot;Answer a string containing HANDLE&#39;s current error message.&quot;
  (foreign-string-to-lisp
   (slot-value handle &#39;error-buffer)))

(defun free-easy-handle (handle)
  &quot;Free CURL easy interface HANDLE and any C strings created to
be its options.&quot;
  (with-slots (pointer error-buffer c-strings) handle
    (curl-easy-cleanup pointer)
    (foreign-free error-buffer)
    (mapc #&#39;foreign-string-free c-strings)))

(define-foreign-type easy-handle-type ()
  ()
  (:actual-type :pointer)
  (:simple-parser easy-handle))

(defmethod translate-to-foreign (handle (type easy-handle-type))
  &quot;Extract the pointer from an easy-HANDLE.&quot;
  (slot-value handle &#39;pointer))</code></pre>
<p>While we changed some of the Lisp functions defined earlier to use CLOS slots rather than hash tables, the foreign functions work just as well as they did before.</p>
limitations of type translators
<p>The greatest strength, and the greatest limitation, of the type translator comes from its generalized interface. As stated previously, we could define all foreign function calls in terms of the primitive foreign types provided by CFFI. The type translator interface allows us to cleanly specify the relationship between Lisp and C data, independent of where it appears in a function call. This independence comes at a price; for example, it cannot be used to modify translation semantics based on other arguments to a function call. In these cases, you should rely on other features of Lisp, rather than the powerful, yet domain-specific, type translator interface.</p>
<h2 id="Tutorial_002dConclusion">What’s next?</h2>
<p>CFFI provides a rich and powerful foundation for communicating with foreign libraries; as we have seen, it is up to you to make that experience a pleasantly Lispy one. This tutorial does not cover all the features of CFFI; please see the rest of the manual for details. In particular, if something seems obviously missing, it is likely that either code or a good reason for lack of code is already present.</p>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>There are some other things in CFFI that might deserve tutorial sections, such as free-translated-object, or structs. Let us know which ones you care about.</em></p>
</blockquote>
<h1 id="Wrapper-generators">Wrapper generators</h1>
<p>CFFI’s interface is designed for human programmers, being aimed at aesthetic as well as technical sophistication. However, there are a few programs aimed at translating C and C++ header files, or approximations thereof, into CFFI forms constituting a foreign interface to the symbols in those files.</p>
<p>These wrapper generators are known to support output of CFFI forms.</p>
<dl>
<dt><a href="http://www.cliki.net/Verrazano">Verrazano</a></dt>
<dd><p>Designed specifically for Common Lisp. Uses GCC’s parser output in XML format to discover functions, variables, and other header file data. This means you need GCC to generate forms; on the other hand, the parser employed is mostly compliant with ANSI C.</p>
</dd>
<dt><a href="http://www.cliki.net/SWIG">SWIG</a></dt>
<dd><p>A foreign interface generator originally designed to generate Python bindings, it has been ported to many other systems, including CFFI in version 1.3.28. Includes its own C declaration munger, not intended to be fully-compliant with ANSI C.</p>
</dd>
</dl>
<p>First, this manual does not describe use of these other programs; they have documentation of their own. If you have problems using a generated interface, please look at the output CFFI forms and verify that they are a correct CFFI interface to the library in question; if they are correct, contact CFFI developers with details, keeping in mind that they communicate in terms of those forms rather than any particular wrapper generator. Otherwise, contact the maintainers of the wrapper generator you are using, provided you can reasonably expect more accuracy from the generator.</p>
<p>When is more accuracy an unreasonable expectation? As described in the tutorial (see <a href="#Tutorial_002dAbstraction">Breaking the abstraction</a>), the information in C declarations is insufficient to completely describe every interface. In fact, it is quite common to run into an interface that cannot be handled automatically, and generators should be excused from generating a complete interface in these cases.</p>
<p>As further described in the tutorial, the thinnest Lisp interface to a C function is not always the most pleasant one. In many cases, you will want to manually write a Lispier interface to the C functions that interest you.</p>
<p>Wrapper generators should be treated as time-savers, not complete automation of the full foreign interface writing job. Reports of the amount of work done by generators vary from 30% to 90%. The incremental development style enabled by CFFI generally reduces this proportion below that for languages like Python.</p>
<h1 id="Foreign-Types">Foreign Types</h1>
<p>Foreign types describe how data is translated back and forth between C and Lisp. CFFI provides various built-in types and allows the user to define new types.</p>
<h2 id="Built_002dIn-Types">Built-In Types</h2>
:char
Foreign Type
:
:char
:unsigned-char
Foreign Type
:
:unsigned-char
:short
Foreign Type
:
:short
:unsigned-short
Foreign Type
:
:unsigned-short
:int
Foreign Type
:
:int
:unsigned-int
Foreign Type
:
:unsigned-int
:long
Foreign Type
:
:long
:unsigned-long
Foreign Type
:
:unsigned-long
:long-long
Foreign Type
:
:long-long
:unsigned-long-long
Foreign Type
:
:unsigned-long-long
<p>These types correspond to the native C integer types according to the ABI of the Lisp implementation’s host system.</p>
<p><code>:long-long</code> and <code>:unsigned-long-long</code> are not supported natively on all implementations. However, they are emulated by <code>mem-ref</code> and <code>mem-set</code>.</p>
<p>When those types are <strong>not</strong> available, the symbol <code>cffi-sys::no-long-long</code> is pushed into <code>*features*</code>.</p>
:uchar
Foreign Type
:
:uchar
:ushort
Foreign Type
:
:ushort
:uint
Foreign Type
:
:uint
:ulong
Foreign Type
:
:ulong
:llong
Foreign Type
:
:llong
:ullong
Foreign Type
:
:ullong
<p>For convenience, the above types are provided as shortcuts for <code>unsigned-char</code>, <code>unsigned-short</code>, <code>unsigned-int</code>, <code>unsigned-long</code>, <code>long-long</code> and <code>unsigned-long-long</code>, respectively.</p>
:int8
Foreign Type
:
:int8
:uint8
Foreign Type
:
:uint8
:int16
Foreign Type
:
:int16
:uint16
Foreign Type
:
:uint16
:int32
Foreign Type
:
:int32
:uint32
Foreign Type
:
:uint32
:int64
Foreign Type
:
:int64
:uint64
Foreign Type
:
:uint64
<p>Foreign integer types of specific sizes, corresponding to the C types defined in <code>stdint.h</code>.</p>
:float
Foreign Type
:
:float
:double
Foreign Type
:
:double
<p>On all systems, the <code>:float</code> and <code>:double</code> types represent a C <code>float</code> and <code>double</code>, respectively. On most but not all systems, <code>:float</code> and <code>:double</code> represent a Lisp <code>single-float</code> and <code>double-float</code>, respectively. It is not so useful to consider the relationship between Lisp types and C types as isomorphic, as simply to recognize the relationship, and relative precision, among each respective category.</p>
:long-double
Foreign Type
:
:long-double
<p>This type is only supported on SCL.</p>
:pointer
Foreign Type
:
:pointer
&amp;optional
type
<p>A foreign pointer to an object of any type, corresponding to <code>void *</code>. You can optionally specify type of pointer (e.g. <code>(:pointer :char)</code>). Although CFFI won’t do anything with that information yet, it is useful for documentation purposes.</p>
:void
Foreign Type
:
:void
<p>No type at all. Only valid as the return type of a function.</p>
<h2 id="Other-Types">Other Types</h2>
<p>CFFI also provides a few useful types that aren’t built-in C types.</p>
:string
Foreign Type
:
:string
<p>The <code>:string</code> type performs automatic conversion between Lisp and C strings. Note that, in the case of functions the converted C string will have dynamic extent (i.e. it will be automatically freed after the foreign function returns).</p>
<p>In addition to Lisp strings, this type will accept foreign pointers and pass them unmodified.</p>
<p>A method for <a href="#free_002dtranslated_002dobject">free-translated-object</a> is specialized for this type. So, for example, foreign strings allocated by this type and passed to a foreign function will be freed after the function returns.</p>
<pre><code>CFFI&gt; (foreign-funcall &quot;getenv&quot; :string &quot;SHELL&quot; :string)
⇒ &quot;/bin/bash&quot;

CFFI&gt; (with-foreign-string (str &quot;abcdef&quot;)
        (foreign-funcall &quot;strlen&quot; :string str :int))
⇒ 6</code></pre>
:string+ptr
Foreign Type
:
:string+ptr
<p>Like <code>:string</code> but returns a list with two values when convert from C to Lisp: a Lisp string and the C string’s foreign pointer.</p>
<pre><code>CFFI&gt; (foreign-funcall &quot;getenv&quot; :string &quot;SHELL&quot; :string+ptr)
⇒ (&quot;/bin/bash&quot; #.(SB-SYS:INT-SAP #XBFFFFC6F))</code></pre>
:boolean
Foreign Type
:
:boolean
&amp;optional
(
base-type
:int
)
<p>The <code>:boolean</code> type converts between a Lisp boolean and a C boolean. It canonicalizes to base-type which is <code>:int</code> by default.</p>
<pre><code>(convert-to-foreign nil :boolean) ⇒ 0
(convert-to-foreign t :boolean) ⇒ 1
(convert-from-foreign 0 :boolean) ⇒ nil
(convert-from-foreign 1 :boolean) ⇒ t</code></pre>
:bool
Foreign Type
:
:bool
<p>The <code>:bool</code> type represents the C99 <code>_Bool</code> or C++ <code>bool</code>. Its size is usually 1 byte except on OSX where it’s an <code>int</code>.</p>
:wrapper
Foreign Type
:
:wrapper
base-type
&amp;key
to-c
from-c
<p>The <code>:wrapper</code> type stores two symbols passed to the to-c and from-c arguments. When a value is being translated to or from C, this type <code>funcall</code>s the respective symbol.</p>
<p><code>:wrapper</code> types will be typedefs for base-type and will inherit its translators, if any.</p>
<p>Here’s an example of how the <code>:boolean</code> type could be defined in terms of <code>:wrapper</code>.</p>
<pre><code>(defun bool-c-to-lisp (value)
  (not (zerop value)))

(defun bool-lisp-to-c (value)
  (if value 1 0))

(defctype my-bool (:wrapper :int :from-c bool-c-to-lisp
                                 :to-c bool-lisp-to-c))

(convert-to-foreign nil &#39;my-bool) ⇒ 0
(convert-from-foreign 1 &#39;my-bool) ⇒ t</code></pre>
<h2 id="Defining-Foreign-Types">Defining Foreign Types</h2>
<p>You can define simple C-like <code>typedef</code>s through the <code>defctype</code> macro. Defining a typedef is as simple as giving <code>defctype</code> a new name and the name of the type to be wrapped.</p>
<pre><code>;;; Define MY-INT as an alias for the built-in type :INT.
(defctype my-int :int)</code></pre>
<p>With this type definition, one can, for instance, declare arguments to foreign functions as having the type <code>my-int</code>, and they will be passed as integers.</p>
<p><strong>More complex types</strong></p>
<p>CFFI offers another way to define types through <code>define-foreign-type</code>, a thin wrapper macro around <code>defclass</code>. As an example, let’s go through the steps needed to define a <code>(my-string &amp;key encoding)</code> type. First, we need to define our type class:</p>
<pre><code>(define-foreign-type my-string-type ()
  ((encoding :reader string-type-encoding :initarg :encoding))
  (:actual-type :pointer))</code></pre>
<p>The <code>:actual-type</code> class option tells CFFI that this type will ultimately be passed to and received from foreign code as a <code>:pointer</code>. Now you need to tell CFFI how to parse a type specification such as <code>(my-string :encoding :utf8)</code> into an instance of <code>my-string-type</code>. We do that with <code>define-parse-method</code>:</p>
<pre><code>(define-parse-method my-string (&amp;key (encoding :utf-8))
  (make-instance &#39;my-string-type :encoding encoding))</code></pre>
<p>The next section describes how make this type actually translate between C and Lisp strings.</p>
<h2 id="Foreign-Type-Translators">Foreign Type Translators</h2>
<p>Type translators are used to automatically convert Lisp values to or from foreign values. For example, using type translators, one can take the <code>my-string</code> type defined in the previous section and specify that it should:</p>
<ul>
<li><p>convert C strings to Lisp strings;</p></li>
<li><p>convert Lisp strings to newly allocated C strings;</p></li>
<li><p>free said C strings when they are no longer needed.</p></li>
</ul>
<p>In order to tell CFFI how to automatically convert Lisp values to foreign values, define a specialized method for the <code>translate-to-foreign</code> generic function:</p>
<pre><code>;;; Define a method that converts Lisp strings to C strings.
(defmethod translate-to-foreign (string (type my-string-type))
  (foreign-string-alloc string :encoding (string-type-encoding type)))</code></pre>
<p>From now on, whenever an object is passed as a <code>my-string</code> to a foreign function, this method will be invoked to convert the Lisp value. To perform the inverse operation, which is needed for functions that return a <code>my-string</code>, specialize the <code>translate-from-foreign</code> generic function in the same manner:</p>
<pre><code>;;; Define a method that converts C strings to Lisp strings.
(defmethod translate-from-foreign (pointer (type my-string-type))
  (foreign-string-to-lisp pointer :encoding (string-type-encoding type)))</code></pre>
<p>When a <code>translate-to-foreign</code> method requires allocation of foreign memory, you must also define a <code>free-translated-object</code> method to free the memory once the foreign object is no longer needed, otherwise you’ll be faced with memory leaks. This generic function is called automatically by CFFI when passing objects to foreign functions. Let’s do that:</p>
<pre><code>;;; Free strings allocated by translate-to-foreign.
(defmethod free-translated-object (pointer (type my-string-type) param)
  (declare (ignore param))
  (foreign-string-free pointer))</code></pre>
<p>In this specific example, we don’t need the param argument, so we ignore it. See <a href="#free_002dtranslated_002dobject">free-translated-object</a>, for an explanation of its purpose and how you can use it.</p>
<p>A type translator does not necessarily need to convert the value. For example, one could define a typedef for <code>:pointer</code> that ensures, in the <code>translate-to-foreign</code> method, that the value is not a null pointer, signalling an error if a null pointer is passed. This would prevent some pointer errors when calling foreign functions that cannot handle null pointers.</p>
<p><strong>Please note:</strong> these methods are meant as extensible hooks only, and you should not call them directly. Use <code>convert-to-foreign</code>, <code>convert-from-foreign</code> and <code>free-converted-object</code> instead.</p>
<p>See <a href="#Tutorial_002dTypes">Defining new types</a>, for another example of type translators.</p>
<h2 id="Optimizing-Type-Translators">Optimizing Type Translators</h2>
type translators, optimizing
compiler macros for type translation
defining type-translation compiler macros
<p>Being based on generic functions, the type translation mechanism described above can add a bit of overhead. This is usually not significant, but we nevertheless provide a way of getting rid of the overhead for the cases where it matters.</p>
<p>A good way to understand this issue is to look at the code generated by <code>defcfun</code>. Consider the following example using the previously defined <code>my-string</code> type:</p>
<pre><code>CFFI&gt; (macroexpand-1 &#39;(defcfun foo my-string (x my-string)))
;; (simplified, downcased, etc...)
(defun foo (x)
  (multiple-value-bind (#:G2019 #:PARAM3149)
      (translate-to-foreign x #&lt;MY-STRING-TYPE {11ED5A79}&gt;)
    (unwind-protect
        (translate-from-foreign
         (foreign-funcall &quot;foo&quot; :pointer #:G2019 :pointer)
         #&lt;MY-STRING-TYPE {11ED5659}&gt;)
      (free-translated-object #:G2019 #&lt;MY-STRING-TYPE {11ED51A79}&gt;
                              #:PARAM3149))))</code></pre>
<p>In order to get rid of those generic function calls, CFFI has another set of extensible generic functions that provide functionality similar to CL’s compiler macros: <code>expand-to-foreign-dyn</code>, <code>expand-to-foreign</code> and <code>expand-from-foreign</code>. Here’s how one could define a <code>my-boolean</code> with them:</p>
<pre><code>(define-foreign-type my-boolean-type ()
  ()
  (:actual-type :int)
  (:simple-parser my-boolean))

(defmethod expand-to-foreign (value (type my-boolean-type))
  `(if ,value 1 0))

(defmethod expand-from-foreign (value (type my-boolean-type))
  `(not (zerop ,value)))</code></pre>
<p>And here’s what the macroexpansion of a function using this type would look like:</p>
<pre><code>CFFI&gt; (macroexpand-1 &#39;(defcfun bar my-boolean (x my-boolean)))
;; (simplified, downcased, etc...)
(defun bar (x)
  (let ((#:g3182 (if x 1 0)))
    (not (zerop (foreign-funcall &quot;bar&quot; :int #:g3182 :int)))))</code></pre>
<p>No generic function overhead.</p>
<p>Let’s go back to our <code>my-string</code> type. The expansion interface has no equivalent of <code>free-translated-object</code>; you must instead define a method on <code>expand-to-foreign-dyn</code>, the third generic function in this interface. This is especially useful when you can allocate something much more efficiently if you know the object has dynamic extent, as is the case with function calls that don’t save the relevant allocated arguments.</p>
<p>This exactly what we need for the <code>my-string</code> type:</p>
<pre><code>(defmethod expand-from-foreign (form (type my-string-type))
  `(foreign-string-to-lisp ,form))

(defmethod expand-to-foreign-dyn (value var body (type my-string-type))
  (let ((encoding (string-type-encoding type)))
    `(with-foreign-string (,var ,value :encoding &#39;,encoding)
       ,@body)))</code></pre>
<p>So let’s look at the macro expansion:</p>
<pre><code>CFFI&gt; (macroexpand-1 &#39;(defcfun foo my-string (x my-string)))
;; (simplified, downcased, etc...)
(defun foo (x)
  (with-foreign-string (#:G2021 X :encoding &#39;:utf-8)
    (foreign-string-to-lisp
     (foreign-funcall &quot;foo&quot; :pointer #:g2021 :pointer))))</code></pre>
<p>Again, no generic function overhead.</p>
<p><strong>Other details</strong></p>
<p>To short-circuit expansion and use the <code>translate-*</code> functions instead, simply call the next method. Return its result in cases where your method cannot generate an appropriate replacement for it. This analogous to the <code>&amp;whole form</code> mechanism compiler macros provide.</p>
<p>The <code>expand-*</code> methods have precedence over their <code>translate-*</code> counterparts and are guaranteed to be used in <code>defcfun</code>, <code>foreign-funcall</code>, <code>defcvar</code> and <code>defcallback</code>. If you define a method on each of the <code>expand-*</code> generic functions, you are guaranteed to have full control over the expressions generated for type translation in these macros.</p>
<p>They may or may not be used in other CFFI operators that need to translate between Lisp and C data; you may only assume that <code>expand-*</code> methods will probably only be called during Lisp compilation.</p>
<p><code>expand-to-foreign-dyn</code> has precedence over <code>expand-to-foreign</code> and is only used in <code>defcfun</code> and <code>foreign-funcall</code>, only making sense in those contexts.</p>
<p><strong>Important note:</strong> this set of generic functions is called at macroexpansion time. Methods are defined when loaded or evaluated, not compiled. You are responsible for ensuring that your <code>expand-*</code> methods are defined when the <code>foreign-funcall</code> or other forms that use them are compiled. One way to do this is to put the method definitions earlier in the file and inside an appropriate <code>eval-when</code> form; another way is to always load a separate Lisp or FASL file containing your <code>expand-*</code> definitions before compiling files with forms that ought to use them. Otherwise, they will not be found and the runtime translators will be used instead.</p>
<h2 id="Foreign-Structure-Types">Foreign Structure Types</h2>
<p>For more involved C types than simple aliases to built-in types, such as you can make with <code>defctype</code>, CFFI allows declaration of structures and unions with <code>defcstruct</code> and <code>defcunion</code>.</p>
<p>For example, consider this fictional C structure declaration holding some personal information:</p>
<pre><code>struct person {
  int number;
  char* reason;
};</code></pre>
<p>The equivalent <code>defcstruct</code> form follows:</p>
<pre><code>(defcstruct person
  (number :int)
  (reason :string))</code></pre>
<p>By default, <a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> (and also <a href="#mem_002dref">mem-ref</a>) will make a plist with slot names as keys, and <a href="#convert_002dto_002dforeign">convert-to-foreign</a> will translate such a plist to a foreign structure. A user wishing to define other translations should use the <code>:class</code> argument to <a href="#defcstruct">defcstruct</a>, and then define methods for <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> and <a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a> that specialize on this class, possibly calling <code>call-next-method</code> to translate from and to the plists rather than provide a direct interface to the foreign object. The macro <code>translation-forms-for-class</code> will generate the forms necessary to translate a Lisp class into a foreign structure and vice versa.</p>
<p>Please note that this interface is only for those that must know about the values contained in a relevant struct. If the library you are interfacing returns an opaque pointer that needs only be passed to other C library functions, by all means just use <code>:pointer</code> or a type-safe definition munged together with <code>defctype</code> and type translation. To pass or return a structure by value to a function, load the cffi-libffi system and specify the structure as <code>(:struct
structure-name)</code>. To pass or return the pointer, you can use either <code>:pointer</code> or <code>(:pointer (:struct
structure-name))</code>.</p>
<p><strong>Optimizing translate-into-foreign-memory</strong></p>
<p>Just like how <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> had <code>expand-from-foreign</code> to optimize away the generic function call and <a href="#translate_002dto_002dforeign">translate-to-foreign</a> had the same in <code>expand-to-foreign</code>, <a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a> has <code>expand-into-foreign-memory</code>.</p>
<p>Let’s use our <code>person</code> struct in an example. However, we are going to spice it up by using a lisp struct rather than a plist to represent the person in lisp.</p>
<p>First we redefine <code>person</code> very slightly.</p>
<pre><code>(defcstruct (person :class c-person)
  (number :int)
  (reason :string))</code></pre>
<p>By adding <code>:class</code> we can specialize the <code>translate-*</code> methods on the type <code>c-person</code>.</p>
<p>Next we define a lisp struct to use instead of the plists.</p>
<pre><code>(defstruct lisp-person
  (number 0 :type integer)
  (reason &quot;&quot; :type string))</code></pre>
<p>And now let’s define the type translators we know already:</p>
<pre><code>(defmethod translate-from-foreign (ptr (type c-person))
  (with-foreign-slots ((number reason) ptr (:struct person))
    (make-lisp-person :number number :reason reason)))

(defmethod expand-from-foreign (ptr (type c-person))
  `(with-foreign-slots ((number reason) ,ptr (:struct person))
     (make-lisp-person :number number :reason reason)))

(defmethod translate-into-foreign-memory (value (type c-person) ptr)
  (with-foreign-slots ((number reason) ptr (:struct person))
    (setf number (lisp-person-number value)
          reason (lisp-person-reason value))))</code></pre>
<p>At this point everything works, we can convert to and from our <code>lisp-person</code> and foreign <code>person</code>. If we macroexpand</p>
<pre><code>(setf (mem-aref ptr &#39;(:struct person)) x)</code></pre>
<p>we get something like:</p>
<pre><code>(let ((#:store879 x))
  (translate-into-foreign-memory #:store879 #&lt;c-person person&gt;
                                 (inc-pointer ptr 0))
  #:store879)</code></pre>
<p>Which is good, but now we can do better and get rid of that generic function call to <code>translate-into-foreign-memory</code>.</p>
<pre><code>(defmethod expand-into-foreign-memory (value (type c-person) ptr)
  `(with-foreign-slots ((number reason) ,ptr (:struct person))
     (setf number (lisp-person-number ,value)
           reason (lisp-person-reason ,value))))</code></pre>
<p>Now we can expand again so see the changes:</p>
<pre><code>;; this:
(setf (mem-aref ptr &#39;(:struct person)) x)

;; expands to this
;; (simplified, downcased, etc..)
(let ((#:store887 x))
  (with-foreign-slots ((number reason) (inc-pointer ptr 0) (:struct person))
    (setf number (lisp-person-number #:store887)
          reason (lisp-person-reason #:store887))) #:store887)</code></pre>
<p>And there we are, no generic function overhead.</p>
<p><strong>Compatibility note</strong></p>
<p>Previous versions of CFFI accepted the “bare” structure-name as a type specification, which was interpreted as a pointer to the structure. This is deprecated and produces a style warning. Using this deprecated form means that <a href="#mem_002daref">mem-aref</a> retains its prior meaning and returns a pointer. Using the <code>(:struct structure-name)</code> form for the type, <a href="#mem_002daref">mem-aref</a> provides a Lisp object translated from the structure (by default a plist). Thus the semantics are consistent with all types in returning the object as represented in Lisp, and not a pointer, with the exception of the “bare” structure compatibility retained. In order to obtain the pointer, you should use the function <a href="#mem_002daptr">mem-aptr</a>.</p>
<p>See <a href="#defcstruct">defcstruct</a> for more details.</p>
<h2 id="Allocating-Foreign-Objects">Allocating Foreign Objects</h2>
<p>See <a href="#Allocating-Foreign-Memory">Allocating Foreign Memory</a>.</p>
<p><strong>convert-from-foreign</strong></p>
<p><strong>Syntax</strong></p>
convert-from-foreign
Function
:
convert-from-foreign
foreign-value
type
⇒
value
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-value</dt>
<dd><p>The primitive C value as returned from a primitive foreign function or from <code>convert-to-foreign</code>.</p>
</dd>
<dt>type</dt>
<dd><p>A CFFI type specifier.</p>
</dd>
<dt>value</dt>
<dd><p>The Lisp value translated from foreign-value.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an external interface to the type translation facility. In the implementation, all foreign functions are ultimately defined as type translation wrappers around primitive foreign function invocations.</p>
<p>This function is available mostly for inspection of the type translation process, and possibly optimization of special cases of your foreign function calls.</p>
<p>Its behavior is better described under <code>translate-from-foreign</code>’s documentation.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI-USER&gt; (convert-to-foreign &quot;a boat&quot; :string)
⇒ #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
⇒ T
CFFI-USER&gt; (convert-from-foreign * :string)
⇒ &quot;a boat&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#convert_002dto_002dforeign">convert-to-foreign</a> <a href="#free_002dconverted_002dobject">free-converted-object</a> <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a></p>
<p><strong>convert-to-foreign</strong></p>
<p><strong>Syntax</strong></p>
convert-to-foreign
Function
:
convert-to-foreign
value
type
⇒
foreign-value
,
alloc-params
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>value</dt>
<dd><p>The Lisp object to be translated to a foreign object.</p>
</dd>
<dt>type</dt>
<dd><p>A CFFI type specifier.</p>
</dd>
<dt>foreign-value</dt>
<dd><p>The primitive C value, ready to be passed to a primitive foreign function.</p>
</dd>
<dt>alloc-params</dt>
<dd><p>Something of a translation state; you must pass it to <code>free-converted-object</code> along with the foreign value for that to work.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is an external interface to the type translation facility. In the implementation, all foreign functions are ultimately defined as type translation wrappers around primitive foreign function invocations.</p>
<p>This function is available mostly for inspection of the type translation process, and possibly optimization of special cases of your foreign function calls.</p>
<p>Its behavior is better described under <code>translate-to-foreign</code>’s documentation.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI-USER&gt; (convert-to-foreign t :boolean)
⇒ 1
⇒ NIL
CFFI-USER&gt; (convert-to-foreign &quot;hello, world&quot; :string)
⇒ #&lt;FOREIGN-ADDRESS #x097C5F80&gt;
⇒ T
CFFI-USER&gt; (code-char (mem-aref * :char 5))
⇒ #\,</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> <a href="#free_002dconverted_002dobject">free-converted-object</a> <a href="#translate_002dto_002dforeign">translate-to-foreign</a></p>
<p><strong>defbitfield</strong></p>
<p><strong>Syntax</strong></p>
defbitfield
Macro
:
defbitfield
name-and-options
&amp;body
masks
<p>masks ::= [docstring] { (symbol value) }* name-and-options ::= name | (name &amp;optional (base-type :int))</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>The name of the new bitfield type.</p>
</dd>
<dt>docstring</dt>
<dd><p>A documentation string, ignored.</p>
</dd>
<dt>base-type</dt>
<dd><p>A symbol denoting a foreign type.</p>
</dd>
<dt>symbol</dt>
<dd><p>A Lisp symbol.</p>
</dd>
<dt>value</dt>
<dd><p>An integer representing a bitmask.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>defbitfield</code> macro is used to define foreign types that map lists of symbols to integer values.</p>
<p>If value is omitted, it will be computed as follows: find the greatest value previously used, including those so computed, with only a single 1-bit in its binary representation (that is, powers of two), and left-shift it by one. This rule guarantees that a computed value cannot clash with previous values, but may clash with future explicitly specified values.</p>
<p>Symbol lists will be automatically converted to values and vice versa when being passed as arguments to or returned from foreign functions, respectively. The same applies to any other situations where an object of a bitfield type is expected.</p>
<p>Types defined with <code>defbitfield</code> canonicalize to base-type which is <code>:int</code> by default.</p>
<p><strong>Examples</strong></p>
<pre><code>(defbitfield open-flags
  (:rdonly #x0000)
  :wronly               ;#x0001
  :rdwr                 ;…
  :nonblock
  :append
  (:creat  #x0200))
  ;; etc…

CFFI&gt; (foreign-bitfield-symbols &#39;open-flags #b1101)
⇒ (:WRONLY :NONBLOCK :APPEND)

CFFI&gt; (foreign-bitfield-value &#39;open-flags &#39;(:rdwr :creat))
⇒ 514   ; #x0202

(defcfun (&quot;open&quot; unix-open) :int
  (path :string)
  (flags open-flags)
  (mode :uint16)) ; unportable

CFFI&gt; (unix-open &quot;/tmp/foo&quot; &#39;(:wronly :creat) #o644)
⇒ #&lt;an fd&gt;

;;; Consider also the following lispier wrapper around open()
(defun lispier-open (path mode &amp;rest flags)
  (unix-open path flags mode))</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a> <a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a></p>
<p><strong>defcstruct</strong></p>
<p><strong>Syntax</strong></p>
defcstruct
Macro
:
defcstruct
name-and-options
&amp;body
doc-and-slots
⇒
name
<p>name-and-options ::= structure-name | (structure-name &amp;key size) doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count offset) }*</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>structure-name</dt>
<dd><p>The name of new structure type.</p>
</dd>
<dt>docstring</dt>
<dd><p>A documentation string, ignored.</p>
</dd>
<dt>slot-name</dt>
<dd><p>A symbol naming the slot. It must be unique among slot names in this structure.</p>
</dd>
<dt>size</dt>
<dd><p>Use this option to override the size (in bytes) of the struct.</p>
</dd>
<dt>slot-type</dt>
<dd><p>The type specifier for the slot.</p>
</dd>
<dt>count</dt>
<dd><p>Used to declare an array of size count inside the structure. Defaults to <code>1</code> as such an array and a single element are semantically equivalent.</p>
</dd>
<dt>offset</dt>
<dd><p>Overrides the slot’s offset. The next slot’s offset is calculated based on this one.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This defines a new CFFI aggregate type akin to C <code>struct</code>s. In other words, it specifies that foreign objects of the type structure-name are groups of different pieces of data, or “slots”, of the slot-types, distinguished from each other by the slot-names. Each structure is located in memory at a position, and the slots are allocated sequentially beginning at that point in memory (with some padding allowances as defined by the C ABI, unless otherwise requested by specifying an offset from the beginning of the structure (offset 0).</p>
<p>In other words, it is isomorphic to the C <code>struct</code>, giving several extra features.</p>
<p>There are two kinds of slots, for the two kinds of CFFI types:</p>
<dl>
<dt>Simple</dt>
<dd><p>Contain a single instance of a type that canonicalizes to a built-in type, such as <code>:long</code> or <code>:pointer</code>. Used for simple CFFI types.</p>
</dd>
<dt>Aggregate</dt>
<dd><p>Contain an embedded structure or union, or an array of objects. Used for aggregate CFFI types.</p>
</dd>
</dl>
<p>The use of CLOS terminology for the structure-related features is intentional; structure definitions are very much like classes with (far) fewer features.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct point
  &quot;Point structure.&quot;
  (x :int)
  (y :int))

CFFI&gt; (with-foreign-object (ptr &#39;point)
        ;; Initialize the slots
        (setf (foreign-slot-value ptr &#39;point &#39;x) 42
              (foreign-slot-value ptr &#39;point &#39;y) 42)
        ;; Return a list with the coordinates
        (with-foreign-slots ((x y) ptr point)
          (list x y)))
⇒ (42 42)</code></pre>
<pre><code>;; Using the :size and :offset options to define a partial structure.
;; (this is useful when you are interested in only a few slots
;; of a big foreign structure)

(defcstruct (foo :size 32)
  &quot;Some struct with 32 bytes.&quot;
                        ; &lt;16 bytes we don&#39;t care about&gt;
  (x :int :offset 16)   ; an int at offset 16
  (y :int)              ; another int at offset 16+sizeof(int)
                        ; &lt;a couple more bytes we don&#39;t care about&gt;
  (z :char :offset 24)) ; a char at offset 24
                        ; &lt;7 more bytes ignored (since size is 32)&gt;

CFFI&gt; (foreign-type-size &#39;foo)
⇒ 32</code></pre>
<pre><code>;;; Using :count to define arrays inside of a struct.
(defcstruct video_tuner
  (name :char :count 32))</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <a href="#with_002dforeign_002dslots">with-foreign-slots</a></p>
<p><strong>defcunion</strong></p>
<p><strong>Syntax</strong></p>
defcunion
Macro
:
defcunion
name
&amp;body
doc-and-slots
⇒
name
<p>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count) }*</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>The name of new union type.</p>
</dd>
<dt>docstring</dt>
<dd><p>A documentation string, ignored.</p>
</dd>
<dt>slot-name</dt>
<dd><p>A symbol naming the slot.</p>
</dd>
<dt>slot-type</dt>
<dd><p>The type specifier for the slot.</p>
</dd>
<dt>count</dt>
<dd><p>Used to declare an array of size count inside the structure.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>A union is a structure in which all slots have an offset of zero. It is isomorphic to the C <code>union</code>. Therefore, you should use the usual foreign structure operations for accessing a union’s slots.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcunion uint32-bytes
  (int-value :unsigned-int)
  (bytes :unsigned-char :count 4))</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a></p>
<p><strong>defctype</strong></p>
<p><strong>Syntax</strong></p>
defctype
Macro
:
defctype
name
base-type
&amp;optional
documentation
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>The name of the new foreign type.</p>
</dd>
<dt>base-type</dt>
<dd><p>A symbol or a list defining the new type.</p>
</dd>
<dt>documentation</dt>
<dd><p>A documentation string, currently ignored.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>defctype</code> macro provides a mechanism similar to C’s <code>typedef</code> to define new types. The new type inherits base-type’s translators, if any. There is no way to define translations for types defined with <code>defctype</code>. For that, you should use <a href="#define_002dforeign_002dtype">define-foreign-type</a>.</p>
<p><strong>Examples</strong></p>
<pre><code>(defctype my-string :string
  &quot;My own string type.&quot;)

(defctype long-bools (:boolean :long)
  &quot;Booleans that map to C longs.&quot;)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#define_002dforeign_002dtype">define-foreign-type</a></p>
<p><strong>defcenum</strong></p>
<p><strong>Syntax</strong></p>
defcenum
Macro
:
defcenum
name-and-options
&amp;body
enum-list
<p>enum-list ::= [docstring] { keyword | (keyword value) }* name-and-options ::= name | (name &amp;optional (base-type :int) &amp;key allow-undeclared-values)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>The name of the new enum type.</p>
</dd>
<dt>docstring</dt>
<dd><p>A documentation string, ignored.</p>
</dd>
<dt>base-type</dt>
<dd><p>A symbol denoting a foreign type.</p>
</dd>
<dt>allow-undeclared-values</dt>
<dd><p>Whether to pass through integer values that were not explicitly declared in the enum when translating from foreign memory.</p>
</dd>
<dt>keyword</dt>
<dd><p>A keyword symbol.</p>
</dd>
<dt>value</dt>
<dd><p>An index value for a keyword.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>defcenum</code> macro is used to define foreign types that map keyword symbols to integer values, similar to the C <code>enum</code> type.</p>
<p>If value is omitted its value will either be 0, if it’s the first entry, or it it will continue the progression from the last specified value.</p>
<p>Keywords will be automatically converted to values and vice-versa when being passed as arguments to or returned from foreign functions, respectively. The same applies to any other situations where an object of an <code>enum</code> type is expected.</p>
<p>If a value should be translated to lisp that is not declared in the enum, an error will be signalled. You can elide this error and instead make it pass the original enum value by specifying allow-undeclared-values. This can be useful for very large enumerations of which we only care about a subset of values, or for enumerations that should allow for client or vendor extensions that we cannot know about.</p>
<p>Types defined with <code>defcenum</code> canonicalize to base-type which is <code>:int</code> by default.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcenum boolean
  :no
  :yes)

CFFI&gt; (foreign-enum-value &#39;boolean :no)
⇒ 0</code></pre>
<pre><code>(defcenum numbers
  (:one 1)
  :two
  (:four 4))

CFFI&gt; (foreign-enum-keyword &#39;numbers 2)
⇒ :TWO</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002denum_002dvalue">foreign-enum-value</a> <a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a></p>
<p><strong>define-foreign-type</strong></p>
<p><strong>Syntax</strong></p>
define-foreign-type
Macro
:
define-foreign-type
class-name
supers
slots
&amp;rest
options
⇒
class-name
<p>options ::= (<code>:actual-type</code> type) |   (<code>:simple-parser</code> symbol) |   <em>regular defclass option</em></p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>class-name</dt>
<dd><p>A symbol naming the new foreign type class.</p>
</dd>
<dt>supers</dt>
<dd><p>A list of symbols naming the super classes.</p>
</dd>
<dt>slots</dt>
<dd><p>A list of slot definitions, passed to <code>defclass</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The macro <code>define-foreign-type</code> defines a new class class-name. It is a thin wrapper around <code>defclass</code>. Among other things, it ensures that class-name becomes a subclass of foreign-type, what you need to know about that is that there’s an initarg <code>:actual-type</code> which serves the same purpose as <code>defctype</code>’s base-type argument.</p>
<p><strong>Examples</strong></p>
<p>Taken from CFFI’s <code>:boolean</code> type definition:</p>
<pre><code>(define-foreign-type :boolean (&amp;optional (base-type :int))
  &quot;Boolean type. Maps to an :int by default. Only accepts integer types.&quot;
  (ecase base-type
    ((:char
      :unsigned-char
      :int
      :unsigned-int
      :long
      :unsigned-long) base-type)))

CFFI&gt; (canonicalize-foreign-type :boolean)
⇒ :INT
CFFI&gt; (canonicalize-foreign-type &#39;(:boolean :long))
⇒ :LONG
CFFI&gt; (canonicalize-foreign-type &#39;(:boolean :float))
;; error→ signalled by ECASE.</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defctype">defctype</a> <a href="#define_002dparse_002dmethod">define-parse-method</a></p>
<p><strong>define-parse-method</strong></p>
<p><strong>Syntax</strong></p>
define-parse-method
Macro
:
define-parse-method
name
lambda-list
&amp;body
body
⇒
name
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type-name</dt>
<dd><p>A symbol naming the new foreign type.</p>
</dd>
<dt>lambda-list</dt>
<dd><p>A lambda list which is the argument list of the new foreign type.</p>
</dd>
<dt>body</dt>
<dd><p>One or more forms that provide a definition of the new foreign type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>Examples</strong></p>
<p>Taken from CFFI’s <code>:boolean</code> type definition:</p>
<pre><code>(define-foreign-type :boolean (&amp;optional (base-type :int))
  &quot;Boolean type. Maps to an :int by default. Only accepts integer types.&quot;
  (ecase base-type
    ((:char
      :unsigned-char
      :int
      :unsigned-int
      :long
      :unsigned-long) base-type)))

CFFI&gt; (canonicalize-foreign-type :boolean)
⇒ :INT
CFFI&gt; (canonicalize-foreign-type &#39;(:boolean :long))
⇒ :LONG
CFFI&gt; (canonicalize-foreign-type &#39;(:boolean :float))
;; error→ signalled by ECASE.</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#define_002dforeign_002dtype">define-foreign-type</a></p>
<p><strong>foreign-bitfield-symbols</strong></p>
<p><strong>Syntax</strong></p>
foreign-bitfield-symbols
Function
:
foreign-bitfield-symbols
type
value
⇒
symbols
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A bitfield type.</p>
</dd>
<dt>value</dt>
<dd><p>An integer.</p>
</dd>
<dt>symbols</dt>
<dd><p>A potentially shared list of symbols. <code>nil</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-bitfield-symbols</code> returns a possibly shared list of symbols that correspond to value in type.</p>
<p><strong>Examples</strong></p>
<pre><code>(defbitfield flags
  (flag-a 1)
  (flag-b 2)
  (flag-c 4))

CFFI&gt; (foreign-bitfield-symbols &#39;flags #b101)
⇒ (FLAG-A FLAG-C)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defbitfield">defbitfield</a> <a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a></p>
<p><strong>foreign-bitfield-value</strong></p>
<p><strong>Syntax</strong></p>
foreign-bitfield-value
Function
:
foreign-bitfield-value
type
symbols
⇒
value
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A <code>bitfield</code> type.</p>
</dd>
<dt>symbol</dt>
<dd><p>A Lisp symbol.</p>
</dd>
<dt>value</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-bitfield-value</code> returns the value that corresponds to the symbols in the symbols list.</p>
<p><strong>Examples</strong></p>
<pre><code>(defbitfield flags
  (flag-a 1)
  (flag-b 2)
  (flag-c 4))

CFFI&gt; (foreign-bitfield-value &#39;flags &#39;(flag-a flag-c))
⇒ 5  ; #b101</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defbitfield">defbitfield</a> <a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a></p>
<p><strong>foreign-enum-keyword</strong></p>
<p><strong>Syntax</strong></p>
foreign-enum-keyword
Function
:
foreign-enum-keyword
type
value
&amp;key
errorp
⇒
keyword
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>An <code>enum</code> type.</p>
</dd>
<dt>value</dt>
<dd><p>An integer.</p>
</dd>
<dt>errorp</dt>
<dd><p>If true (the default), signal an error if value is not defined in type. If false, <code>foreign-enum-keyword</code> returns <code>nil</code>.</p>
</dd>
<dt>keyword</dt>
<dd><p>A keyword symbol.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-enum-keyword</code> returns the keyword symbol that corresponds to value in type.</p>
<p>An error is signaled if type doesn’t contain such value and errorp is true.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcenum boolean
  :no
  :yes)

CFFI&gt; (foreign-enum-keyword &#39;boolean 1)
⇒ :YES</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcenum">defcenum</a> <a href="#foreign_002denum_002dvalue">foreign-enum-value</a></p>
<p><strong>foreign-enum-value</strong></p>
<p><strong>Syntax</strong></p>
foreign-enum-value
Function
:
foreign-enum-value
type
keyword
&amp;key
errorp
⇒
value
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>An <code>enum</code> type.</p>
</dd>
<dt>keyword</dt>
<dd><p>A keyword symbol.</p>
</dd>
<dt>errorp</dt>
<dd><p>If true (the default), signal an error if keyword is not defined in type. If false, <code>foreign-enum-value</code> returns <code>nil</code>.</p>
</dd>
<dt>value</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-enum-value</code> returns the value that corresponds to keyword in type.</p>
<p>An error is signaled if type doesn’t contain such keyword, and errorp is true.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcenum boolean
  :no
  :yes)

CFFI&gt; (foreign-enum-value &#39;boolean :yes)
⇒ 1</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcenum">defcenum</a> <a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a></p>
<p><strong>foreign-slot-names</strong></p>
<p><strong>Syntax</strong></p>
foreign-slot-names
Function
:
foreign-slot-names
type
⇒
names
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A foreign struct type.</p>
</dd>
<dt>names</dt>
<dd><p>A list.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-slot-names</code> returns a potentially shared list of slot names for the given structure type. This list has no particular order.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct timeval
  (tv-secs :long)
  (tv-usecs :long))

CFFI&gt; (foreign-slot-names &#39;(:struct timeval))
⇒ (TV-SECS TV-USECS)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcstruct">defcstruct</a> <a href="#foreign_002dslot_002doffset">foreign-slot-offset</a> <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a></p>
<p><strong>foreign-slot-offset</strong></p>
<p><strong>Syntax</strong></p>
foreign-slot-offset
Function
:
foreign-slot-offset
type
slot-name
⇒
offset
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A foreign struct type.</p>
</dd>
<dt>slot-name</dt>
<dd><p>A symbol.</p>
</dd>
<dt>offset</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-slot-offset</code> returns the offset in bytes of a slot in a foreign struct type.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct timeval
  (tv-secs :long)
  (tv-usecs :long))

CFFI&gt; (foreign-slot-offset &#39;(:struct timeval) &#39;tv-secs)
⇒ 0
CFFI&gt; (foreign-slot-offset &#39;(:struct timeval) &#39;tv-usecs)
⇒ 4</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcstruct">defcstruct</a> <a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a></p>
<p><strong>foreign-slot-pointer</strong></p>
<p><strong>Syntax</strong></p>
foreign-slot-pointer
Function
:
foreign-slot-pointer
ptr
type
slot-name
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A pointer to a structure.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign structure type.</p>
</dd>
<dt>slot-names</dt>
<dd><p>A slot name in the type.</p>
</dd>
<dt>pointer</dt>
<dd><p>A pointer to the slot slot-name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Returns a pointer to the location of the slot slot-name in a foreign object of type type at ptr. The returned pointer points inside the structure. Both the pointer and the memory it points to have the same extent as ptr.</p>
<p>For aggregate slots, this is the same value returned by <code>foreign-slot-value</code>.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct point
  &quot;Pointer structure.&quot;
  (x :int)
  (y :int))

CFFI&gt; (with-foreign-object (ptr &#39;(:struct point))
        (foreign-slot-pointer ptr &#39;(:struct point) &#39;x))
⇒ #&lt;FOREIGN-ADDRESS #xBFFF6E60&gt;
;; Note: the exact pointer representation varies from lisp to lisp.</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcstruct">defcstruct</a> <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <a href="#foreign_002dslot_002doffset">foreign-slot-offset</a></p>
<p><strong>foreign-slot-value</strong></p>
<p><strong>Syntax</strong></p>
foreign-slot-value
Accessor
:
foreign-slot-value
ptr
type
slot-name
⇒
object
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A pointer to a structure.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign structure type.</p>
</dd>
<dt>slot-name</dt>
<dd><p>A symbol naming a slot in the structure type.</p>
</dd>
<dt>object</dt>
<dd><p>The object contained in the slot specified by slot-name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>For simple slots, <code>foreign-slot-value</code> returns the value of the object, such as a Lisp integer or pointer. In C, this would be expressed as <code>ptr-&gt;slot</code>.</p>
<p>For aggregate slots, a pointer inside the structure to the beginning of the slot’s data is returned. In C, this would be expressed as <code>&amp;ptr-&gt;slot</code>. This pointer and the memory it points to have the same extent as ptr.</p>
<p>There are compiler macros for <code>foreign-slot-value</code> and its <code>setf</code> expansion that open code the memory access when type and slot-names are constant at compile-time.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct point
  &quot;Pointer structure.&quot;
  (x :int)
  (y :int))

CFFI&gt; (with-foreign-object (ptr &#39;(:struct point))
        ;; Initialize the slots
        (setf (foreign-slot-value ptr &#39;(:struct point) &#39;x) 42
              (foreign-slot-value ptr &#39;(:struct point) &#39;y) 42)
        ;; Return a list with the coordinates
        (with-foreign-slots ((x y) ptr (:struct point))
          (list x y)))
⇒ (42 42)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcstruct">defcstruct</a> <a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <a href="#foreign_002dslot_002doffset">foreign-slot-offset</a> <a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <a href="#with_002dforeign_002dslots">with-foreign-slots</a></p>
<p><strong>foreign-type-alignment</strong></p>
<p><strong>Syntax</strong></p>
foreign-type-alignment
Function
:
foreign-type-alignment
type
⇒
alignment
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>alignment</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-type-alignment</code> returns the alignment of type in bytes.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-type-alignment :char)
⇒ 1
CFFI&gt; (foreign-type-alignment :short)
⇒ 2
CFFI&gt; (foreign-type-alignment :int)
⇒ 4</code></pre>
<pre><code>(defcstruct foo
  (a :char))

CFFI&gt; (foreign-type-alignment &#39;(:struct foo))
⇒ 1</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dtype_002dsize">foreign-type-size</a></p>
<p><strong>foreign-type-size</strong></p>
<p><strong>Syntax</strong></p>
foreign-type-size
Function
:
foreign-type-size
type
⇒
size
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>size</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-type-size</code> return the size of type in bytes. This includes any padding within and following the in-memory representation as needed to create an array of type objects.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct foo
  (a :double)
  (c :char))

CFFI&gt; (foreign-type-size :double)
⇒ 8
CFFI&gt; (foreign-type-size :char)
⇒ 1
CFFI&gt; (foreign-type-size &#39;(:struct foo))
⇒ 16</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a></p>
<p><strong>free-converted-object</strong></p>
<p><strong>Syntax</strong></p>
free-converted-object
Function
:
free-converted-object
foreign-value
type
params
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-value</dt>
<dd><p>The C object to be freed.</p>
</dd>
<dt>type</dt>
<dd><p>A CFFI type specifier.</p>
</dd>
<dt>params</dt>
<dd><p>The state returned as the second value from <code>convert-to-foreign</code>; used to implement the third argument to <code>free-translated-object</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The return value is unspecified.</p>
<p>This is an external interface to the type translation facility. In the implementation, all foreign functions are ultimately defined as type translation wrappers around primitive foreign function invocations.</p>
<p>This function is available mostly for inspection of the type translation process, and possibly optimization of special cases of your foreign function calls.</p>
<p>Its behavior is better described under <code>free-translated-object</code>’s documentation.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI-USER&gt; (convert-to-foreign &quot;a boat&quot; :string)
⇒ #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
⇒ T
CFFI-USER&gt; (free-converted-object * :string t)
⇒ NIL</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> <a href="#convert_002dto_002dforeign">convert-to-foreign</a> <a href="#free_002dtranslated_002dobject">free-translated-object</a></p>
<p><strong>free-translated-object</strong></p>
<p><strong>Syntax</strong></p>
free-translated-object
Generic Function
:
free-translated-object
value
type-name
param
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>pointer</dt>
<dd><p>The foreign value returned by <code>translate-to-foreign</code>.</p>
</dd>
<dt>type-name</dt>
<dd><p>A symbol naming a foreign type defined by <code>defctype</code>.</p>
</dd>
<dt>param</dt>
<dd><p>The second value, if any, returned by <code>translate-to-foreign</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This generic function may be specialized by user code to perform automatic deallocation of foreign objects as they are passed to C functions.</p>
<p>Any methods defined on this generic function must EQL-specialize the type-name parameter on a symbol defined as a foreign type by the <code>defctype</code> macro.</p>
<p><strong>See Also</strong></p>
<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <a href="#translate_002dto_002dforeign">translate-to-foreign</a></p>
<p><strong>translate-from-foreign</strong></p>
<p><strong>Syntax</strong></p>
translate-from-foreign
Generic Function
:
translate-from-foreign
foreign-value
type-name
⇒
lisp-value
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-value</dt>
<dd><p>The foreign value to convert to a Lisp object.</p>
</dd>
<dt>type-name</dt>
<dd><p>A symbol naming a foreign type defined by <code>defctype</code>.</p>
</dd>
<dt>lisp-value</dt>
<dd><p>The lisp value to pass in place of <code>foreign-value</code> to Lisp code.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This generic function is invoked by CFFI to convert a foreign value to a Lisp value, such as when returning from a foreign function, passing arguments to a callback function, or accessing a foreign variable.</p>
<p>To extend the CFFI type system by performing custom translations, this method may be specialized by EQL-specializing <code>type-name</code> on a symbol naming a foreign type defined with <code>defctype</code>. This method should return the appropriate Lisp value to use in place of the foreign value.</p>
<p>The results are undefined if the <code>type-name</code> parameter is specialized in any way except an EQL specializer on a foreign type defined with <code>defctype</code>. Specifically, translations may not be defined for built-in types.</p>
<p><strong>See Also</strong></p>
<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <a href="#translate_002dto_002dforeign">translate-to-foreign</a> <a href="#free_002dtranslated_002dobject">free-translated-object</a></p>
<p><strong>translate-to-foreign</strong></p>
<p><strong>Syntax</strong></p>
translate-to-foreign
Generic Function
:
translate-to-foreign
lisp-value
type-name
⇒
foreign-value
,
alloc-param
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>lisp-value</dt>
<dd><p>The Lisp value to convert to foreign representation.</p>
</dd>
<dt>type-name</dt>
<dd><p>A symbol naming a foreign type defined by <code>defctype</code>.</p>
</dd>
<dt>foreign-value</dt>
<dd><p>The foreign value to pass in place of <code>lisp-value</code> to foreign code.</p>
</dd>
<dt>alloc-param</dt>
<dd><p>If present, this value will be passed to <code>free-translated-object</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This generic function is invoked by CFFI to convert a Lisp value to a foreign value, such as when passing arguments to a foreign function, returning a value from a callback, or setting a foreign variable. A “foreign value” is one appropriate for passing to the next-lowest translator, including the low-level translators that are ultimately invoked invisibly with CFFI.</p>
<p>To extend the CFFI type system by performing custom translations, this method may be specialized by EQL-specializing <code>type-name</code> on a symbol naming a foreign type defined with <code>defctype</code>. This method should return the appropriate foreign value to use in place of the Lisp value.</p>
<p>In cases where CFFI can determine the lifetime of the foreign object returned by this method, it will invoke <code>free-translated-object</code> on the foreign object at the appropriate time. If <code>translate-to-foreign</code> returns a second value, it will be passed as the <code>param</code> argument to <code>free-translated-object</code>. This can be used to establish communication between the allocation and deallocation methods.</p>
<p>The results are undefined if the <code>type-name</code> parameter is specialized in any way except an EQL specializer on a foreign type defined with <code>defctype</code>. Specifically, translations may not be defined for built-in types.</p>
<p><strong>See Also</strong></p>
<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> <a href="#free_002dtranslated_002dobject">free-translated-object</a></p>
<p><strong>translate-into-foreign-memory</strong></p>
<p><strong>Syntax</strong></p>
translate-into-foreign-memory
Generic Function
:
translate-into-foreign-memory
lisp-value
type-name
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>lisp-value</dt>
<dd><p>The Lisp value to convert to foreign representation.</p>
</dd>
<dt>type-name</dt>
<dd><p>A symbol or list <code>(:struct structure-name)</code> naming a foreign type defined by <code>defctype</code>.</p>
</dd>
<dt>pointer</dt>
<dd><p>The foreign pointer where the translated object should be stored.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Translate the Lisp value into the foreign memory location given by pointer. The return value is not used.</p>
<p><strong>with-foreign-slots</strong></p>
<p><strong>Syntax</strong></p>
with-foreign-slots
Macro
:
with-foreign-slots
(
vars
ptr
type
)
&amp;body
body
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>vars</dt>
<dd><p>A list with each element a symbol, or list of length two with the first element <code>:pointer</code> and the second a symbol.</p>
</dd>
<dt>ptr</dt>
<dd><p>A foreign pointer to a structure.</p>
</dd>
<dt>type</dt>
<dd><p>A structure type.</p>
</dd>
<dt>body</dt>
<dd><p>A list of forms to be executed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>with-foreign-slots</code> macro creates local symbol macros for each var in vars to reference foreign slots in ptr of type. If the var is a list starting with <code>:pointer</code>, it will bind the pointer to the slot (rather than the value). It is similar to Common Lisp’s <code>with-slots</code> macro.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcstruct tm
  (sec :int)
  (min :int)
  (hour :int)
  (mday :int)
  (mon  :int)
  (year :int)
  (wday :int)
  (yday :int)
  (isdst  :boolean)
  (zone   :string)
  (gmtoff :long))

CFFI&gt; (with-foreign-object (time :int)
        (setf (mem-ref time :int)
              (foreign-funcall &quot;time&quot; :pointer (null-pointer) :int))
        (foreign-funcall &quot;gmtime&quot; :pointer time (:pointer (:struct tm))))
⇒ #&lt;A Mac Pointer #x102A30&gt;
CFFI&gt; (with-foreign-slots ((sec min hour mday mon year) * (:struct tm))
        (format nil &quot;~A:~A:~A, ~A/~A/~A&quot;
                hour min sec (+ 1900 year) mon mday))
⇒ &quot;7:22:47, 2005/8/2&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcstruct">defcstruct</a> <a href="#defcunion">defcunion</a> <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a></p>
<h1 id="Pointers">Pointers</h1>
<p>All C data in CFFI is referenced through pointers. This includes defined C variables that hold immediate values, and integers.</p>
<p>To see why this is, consider the case of the C integer. It is not only an arbitrary representation for an integer, congruent to Lisp’s fixnums; the C integer has a specific bit pattern in memory defined by the C ABI. Lisp has no such constraint on its fixnums; therefore, it only makes sense to think of fixnums as C integers if you assume that CFFI converts them when necessary, such as when storing one for use in a C function call, or as the value of a C variable. This requires defining an area of memory<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>, represented through an effective address, and storing it there.</p>
<p>Due to this compartmentalization, it only makes sense to manipulate raw C data in Lisp through pointers to it. For example, while there may be a Lisp representation of a <code>struct</code> that is converted to C at store time, you may only manipulate its raw data through a pointer. The C compiler does this also, albeit informally.</p>
<h2 id="Basic-Pointer-Operations">Basic Pointer Operations</h2>
<p>Manipulating pointers proper can be accomplished through most of the other operations defined in the Pointers dictionary, such as <code>make-pointer</code>, <code>pointer-address</code>, and <code>pointer-eq</code>. When using them, keep in mind that they merely manipulate the Lisp representation of pointers, not the values they point to.</p>
foreign-pointer
Lisp Type
:
foreign-pointer
<blockquote>
<p>The pointers’ representations differ from implementation to implementation and have different types. <code>foreign-pointer</code> provides a portable type alias to each of these types.</p>
</blockquote>
<h2 id="Allocating-Foreign-Memory">Allocating Foreign Memory</h2>
<p>CFFI provides support for stack and heap C memory allocation. Stack allocation, done with <code>with-foreign-object</code>, is sometimes called “dynamic” allocation in Lisp, because memory allocated as such has dynamic extent, much as with <code>let</code> bindings of special variables.</p>
<p>This should not be confused with what C calls “dynamic” allocation, or that done with <code>malloc</code> and friends. This sort of heap allocation is done with <code>foreign-alloc</code>, creating objects that exist until freed with <code>foreign-free</code>.</p>
<h2 id="Accessing-Foreign-Memory">Accessing Foreign Memory</h2>
<p>When manipulating raw C data, consider that all pointers are pointing to an array. When you only want one C value, such as a single <code>struct</code>, this array only has one such value. It is worthwhile to remember that everything is an array, though, because this is also the semantic that C imposes natively.</p>
<p>C values are accessed as the <code>setf</code>-able places defined by <code>mem-aref</code> and <code>mem-ref</code>. Given a pointer and a CFFI type (see <a href="#Foreign-Types">Foreign Types</a>), either of these will dereference the pointer, translate the C data there back to Lisp, and return the result of said translation, performing the reverse operation when <code>setf</code>-ing. To decide which one to use, consider whether you would use the array index operator <code>[n]</code> or the pointer dereference <code>*</code> in C; use <code>mem-aref</code> for array indexing and <code>mem-ref</code> for pointer dereferencing.</p>
<p><strong>foreign-free</strong></p>
<p><strong>Syntax</strong></p>
foreign-free
Function
:
foreign-free
ptr
⇒
undefined
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A foreign pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-free</code> function frees a <code>ptr</code> previously allocated by <code>foreign-alloc</code>. The consequences of freeing a given pointer twice are undefined.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-alloc :int)
⇒ #&lt;A Mac Pointer #x1022E0&gt;
CFFI&gt; (foreign-free *)
⇒ NIL</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dalloc">foreign-alloc</a> <a href="#with_002dforeign_002dpointer">with-foreign-pointer</a></p>
<p><strong>foreign-alloc</strong></p>
<p><strong>Syntax</strong></p>
foreign-alloc
Function
:
foreign-alloc
type
&amp;key
initial-element
initial-contents
(
count
1
)
null-terminated-p
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>initial-element</dt>
<dd><p>A Lisp object.</p>
</dd>
<dt>initial-contents</dt>
<dd><p>A sequence.</p>
</dd>
<dt>count</dt>
<dd><p>An integer. Defaults to 1 or the length of initial-contents if supplied.</p>
</dd>
<dt>null-terminated-p</dt>
<dd><p>A boolean, false by default.</p>
</dd>
<dt>pointer</dt>
<dd><p>A foreign pointer to the newly allocated memory.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-alloc</code> function allocates enough memory to hold count objects of type type and returns a pointer. This memory must be explicitly freed using <code>foreign-free</code> once it is no longer needed.</p>
<p>If initial-element is supplied, it is used to initialize the count objects the newly allocated memory holds.</p>
<p>If an initial-contents sequence is supplied, it must have a length less than or equal to count and each of its elements will be used to initialize the contents of the newly allocated memory.</p>
<p>If count is omitted and initial-contents is specified, it will default to <code>(length initial-contents)</code>.</p>
<p>initial-element and initial-contents are mutually exclusive.</p>
<p>When null-terminated-p is true, <code>(1+ (max count (length initial-contents)))</code> elements are allocated and the last one is set to <code>NULL</code>. Note that in this case type must be a pointer type (ie. a type that canonicalizes to <code>:pointer</code>), otherwise an error is signaled.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-alloc :char)
⇒ #&lt;A Mac Pointer #x102D80&gt;     ; A pointer to 1 byte of memory.

CFFI&gt; (foreign-alloc :char :count 20)
⇒ #&lt;A Mac Pointer #x1024A0&gt;     ; A pointer to 20 bytes of memory.

CFFI&gt; (foreign-alloc :int :initial-element 12)
⇒ #&lt;A Mac Pointer #x1028B0&gt;
CFFI&gt; (mem-ref * :int)
⇒ 12

CFFI&gt; (foreign-alloc :int :initial-contents &#39;(1 2 3))
⇒ #&lt;A Mac Pointer #x102950&gt;
CFFI&gt; (loop for i from 0 below 3
            collect (mem-aref * :int i))
⇒ (1 2 3)

CFFI&gt; (foreign-alloc :int :initial-contents #(1 2 3))
⇒ #&lt;A Mac Pointer #x102960&gt;
CFFI&gt; (loop for i from 0 below 3
            collect (mem-aref * :int i))
⇒ (1 2 3)

;;; Allocate a char** pointer that points to newly allocated memory
;;; by the :string type translator for the string &quot;foo&quot;.
CFFI&gt; (foreign-alloc :string :initial-element &quot;foo&quot;)
⇒ #&lt;A Mac Pointer #x102C40&gt;</code></pre>
<pre><code>;;; Allocate a null-terminated array of strings.
;;; (Note: FOREIGN-STRING-TO-LISP returns NIL when passed a null pointer)
CFFI&gt; (foreign-alloc :string
                     :initial-contents &#39;(&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;)
                     :null-terminated-p t)
⇒ #&lt;A Mac Pointer #x102D20&gt;
CFFI&gt; (loop for i from 0 below 4
            collect (mem-aref * :string i))
⇒ (&quot;foo&quot; &quot;bar&quot; &quot;baz&quot; NIL)
CFFI&gt; (progn
        (dotimes (i 3)
          (foreign-free (mem-aref ** :pointer i)))
        (foreign-free **))
⇒ nil</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dfree">foreign-free</a> <a href="#with_002dforeign_002dobject">with-foreign-object</a> <a href="#with_002dforeign_002dpointer">with-foreign-pointer</a></p>
<p><strong>foreign-symbol-pointer</strong></p>
<p><strong>Syntax</strong></p>
foreign-symbol-pointer
Function
:
foreign-symbol-pointer
foreign-name
&amp;key
library
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-name</dt>
<dd><p>A string.</p>
</dd>
<dt>pointer</dt>
<dd><p>A foreign pointer, or <code>nil</code>.</p>
</dd>
<dt>library</dt>
<dd><p>A Lisp symbol or an instance of <code>foreign-library</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>foreign-symbol-pointer</code> will return a foreign pointer corresponding to the foreign symbol denoted by the string foreign-name. If a foreign symbol named foreign-name doesn’t exist, <code>nil</code> is returned.</p>
<p>ABI name manglings will be performed on foreign-name by <code>foreign-symbol-pointer</code> if necessary. (eg: adding a leading underscore on darwin/ppc)</p>
<p>library should name a foreign library as defined by <code>define-foreign-library</code>, <code>:default</code> (which is the default) or an instance of <code>foreign-library</code> as returned by <code>load-foreign-library</code>.</p>
<p><strong>Important note:</strong> do not keep these pointers across saved Lisp cores as the foreign-library may move across sessions.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-symbol-pointer &quot;errno&quot;)
⇒ #&lt;A Mac Pointer #xA0008130&gt;
CFFI&gt; (foreign-symbol-pointer &quot;strerror&quot;)
⇒ #&lt;A Mac Pointer #x9002D0F8&gt;
CFFI&gt; (foreign-funcall-pointer * () :int (mem-ref ** :int) :string)
⇒ &quot;No such file or directory&quot;

CFFI&gt; (foreign-symbol-pointer &quot;inexistent symbol&quot;)
⇒ NIL</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcvar">defcvar</a></p>
<p><strong>inc-pointer</strong></p>
<p><strong>Syntax</strong></p>
inc-pointer
Function
:
inc-pointer
pointer
offset
⇒
new-pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>pointer; new-pointer</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>offset</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>inc-pointer</code> will return a new-pointer pointing offset bytes past pointer.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-string-alloc &quot;Common Lisp&quot;)
⇒ #&lt;A Mac Pointer #x102EA0&gt;
CFFI&gt; (inc-pointer * 7)
⇒ #&lt;A Mac Pointer #x102EA7&gt;
CFFI&gt; (foreign-string-to-lisp *)
⇒ &quot;Lisp&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#incf_002dpointer">incf-pointer</a> <a href="#make_002dpointer">make-pointer</a> <a href="#pointerp">pointerp</a> <a href="#null_002dpointer">null-pointer</a> <a href="#null_002dpointer_002dp">null-pointer-p</a></p>
<p><strong>incf-pointer</strong></p>
<p><strong>Syntax</strong></p>
incf-pointer
Macro
:
incf-pointer
place
&amp;optional
(
offset
1
)
⇒
new-pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>place</dt>
<dd><p>A <code>setf</code> place.</p>
</dd>
<dt>new-pointer</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>offset</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>incf-pointer</code> macro takes the foreign pointer from place and creates a new-pointer incremented by offset bytes and which is stored in place.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defparameter *two-words* (foreign-string-alloc &quot;Common Lisp&quot;))
⇒ *TWO-WORDS*
CFFI&gt; (defparameter *one-word* *two-words*)
⇒ *ONE-WORD*
CFFI&gt; (incf-pointer *one-word* 7)
⇒ #.(SB-SYS:INT-SAP #X00600457)
CFFI&gt; (foreign-string-to-lisp *one-word*)
⇒ &quot;Lisp&quot;
CFFI&gt; (foreign-string-to-lisp *two-words*)
⇒ &quot;Common Lisp&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#inc_002dpointer">inc-pointer</a> <a href="#make_002dpointer">make-pointer</a> <a href="#pointerp">pointerp</a> <a href="#null_002dpointer">null-pointer</a> <a href="#null_002dpointer_002dp">null-pointer-p</a></p>
<p><strong>make-pointer</strong></p>
<p><strong>Syntax</strong></p>
make-pointer
Function
:
make-pointer
address
⇒
ptr
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>address</dt>
<dd><p>An integer.</p>
</dd>
<dt>ptr</dt>
<dd><p>A foreign pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>make-pointer</code> will return a foreign pointer pointing to address.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (make-pointer 42)
⇒ #&lt;FOREIGN-ADDRESS #x0000002A&gt;
CFFI&gt; (pointerp *)
⇒ T
CFFI&gt; (pointer-address **)
⇒ 42
CFFI&gt; (inc-pointer *** -42)
⇒ #&lt;FOREIGN-ADDRESS #x00000000&gt;
CFFI&gt; (null-pointer-p *)
⇒ T
CFFI&gt; (typep ** &#39;foreign-pointer)
⇒ T</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#inc_002dpointer">inc-pointer</a> <a href="#null_002dpointer">null-pointer</a> <a href="#null_002dpointer_002dp">null-pointer-p</a> <a href="#pointerp">pointerp</a> <a href="#pointer_002daddress">pointer-address</a> <a href="#pointer_002deq">pointer-eq</a> <a href="#mem_002dref">mem-ref</a></p>
<p><strong>mem-aptr</strong></p>
<p><strong>Syntax</strong></p>
mem-aptr
Accessor
:
mem-aptr
ptr
type
&amp;optional
(
index
0
)
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>index</dt>
<dd><p>An integer.</p>
</dd>
<dt>new-value</dt>
<dd><p>A Lisp value compatible with type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>mem-aptr</code> function finds the pointer to an element of the array.</p>
<pre><code>(mem-aptr ptr type n)

;; is identical to:

(inc-pointer ptr (* n (foreign-type-size type)))</code></pre>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-string (str &quot;Hello, foreign world!&quot;)
        (mem-aptr str :char 6))
⇒ #.(SB-SYS:INT-SAP #X0063D4B6)</code></pre>
<p><strong>mem-aref</strong></p>
<p><strong>Syntax</strong></p>
mem-aref
Accessor
:
mem-aref
ptr
type
&amp;optional
(
index
0
)
<p>(setf (<strong>mem-aref</strong> <em>ptr type &amp;optional (index 0)) new-value</em>)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>index</dt>
<dd><p>An integer.</p>
</dd>
<dt>new-value</dt>
<dd><p>A Lisp value compatible with type.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>mem-aref</code> function is similar to <code>mem-ref</code> but will automatically calculate the offset from an index.</p>
<pre><code>(mem-aref ptr type n)

;; is identical to:

(mem-ref ptr type (* n (foreign-type-size type)))</code></pre>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-string (str &quot;Hello, foreign world!&quot;)
        (mem-aref str :char 6))
⇒ 32
CFFI&gt; (code-char *)
⇒ #\Space

CFFI&gt; (with-foreign-object (array :int 10)
        (loop for i below 10
              do (setf (mem-aref array :int i) (random 100)))
        (loop for i below 10 collect (mem-aref array :int i)))
⇒ (22 7 22 52 69 1 46 93 90 65)</code></pre>
<p><strong>Compatibility Note</strong></p>
<p>For compatibility with older versions of CFFI, <a href="#mem_002daref">mem-aref</a> will produce a pointer for the deprecated bare structure specification, but it is consistent with other types for the current specification form <code>(:struct structure-name)</code> and provides a Lisp object translated from the structure (by default a plist). In order to obtain the pointer, you should use the new function <a href="#mem_002daptr">mem-aptr</a>.</p>
<p><strong>See Also</strong></p>
<p><a href="#mem_002dref">mem-ref</a> <a href="#mem_002daptr">mem-aptr</a></p>
<p><strong>mem-ref</strong></p>
<p><strong>Syntax</strong></p>
mem-ref
Accessor
:
mem-ref
ptr
type
&amp;optional
offset
⇒
object
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A pointer.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>offset</dt>
<dd><p>An integer (in byte units).</p>
</dd>
<dt>object</dt>
<dd><p>The value ptr points to.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-string (ptr &quot;Saluton&quot;)
        (setf (mem-ref ptr :char 3) (char-code #\a))
        (loop for i from 0 below 8
              collect (code-char (mem-ref ptr :char i))))
⇒ (#\S #\a #\l #\a #\t #\o #\n #\Null)
CFFI&gt; (setq ptr-to-int (foreign-alloc :int))
⇒ #&lt;A Mac Pointer #x1047D0&gt;
CFFI&gt; (mem-ref ptr-to-int :int)
⇒ 1054619
CFFI&gt; (setf (mem-ref ptr-to-int :int) 1984)
⇒ 1984
CFFI&gt; (mem-ref ptr-to-int :int)
⇒ 1984</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#mem_002daref">mem-aref</a></p>
<p><strong>null-pointer</strong></p>
<p><strong>Syntax</strong></p>
null-pointer
Function
:
null-pointer
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>pointer</dt>
<dd><p>A <code>NULL</code> pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>null-pointer</code> returns a null pointer.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (null-pointer)
⇒ #&lt;A Null Mac Pointer&gt;
CFFI&gt; (pointerp *)
⇒ T</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#null_002dpointer_002dp">null-pointer-p</a> <a href="#make_002dpointer">make-pointer</a></p>
<p><strong>null-pointer-p</strong></p>
<p><strong>Syntax</strong></p>
null-pointer-p
Function
:
null-pointer-p
ptr
⇒
boolean
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A foreign pointer that may be a null pointer.</p>
</dd>
<dt>boolean</dt>
<dd><p><code>T</code> or <code>NIL</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>null-pointer-p</code> returns true if ptr is a null pointer and false otherwise.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (null-pointer-p (null-pointer))
⇒ T</code></pre>
<pre><code>(defun contains-str-p (big little)
  (not (null-pointer-p
        (foreign-funcall &quot;strstr&quot; :string big :string little :pointer))))

CFFI&gt; (contains-str-p &quot;Popcorns&quot; &quot;corn&quot;)
⇒ T
CFFI&gt; (contains-str-p &quot;Popcorns&quot; &quot;salt&quot;)
⇒ NIL</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#null_002dpointer">null-pointer</a> <a href="#pointerp">pointerp</a></p>
<p><strong>pointerp</strong></p>
<p><strong>Syntax</strong></p>
pointerp
Function
:
pointerp
ptr
⇒
boolean
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>An object that may be a foreign pointer.</p>
</dd>
<dt>boolean</dt>
<dd><p><code>T</code> or <code>NIL</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>pointerp</code> returns true if ptr is a foreign pointer and false otherwise.</p>
<p><strong>Implementation-specific Notes</strong></p>
<p>In Allegro CL, foreign pointers are integers thus in this implementation <code>pointerp</code> will return true for any ordinary integer.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-alloc 32)
⇒ #&lt;A Mac Pointer #x102D20&gt;
CFFI&gt; (pointerp *)
⇒ T
CFFI&gt; (pointerp &quot;this is not a pointer&quot;)
⇒ NIL</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#make_002dpointer">make-pointer</a> <a href="#null_002dpointer_002dp">null-pointer-p</a></p>
<p><strong>pointer-address</strong></p>
<p><strong>Syntax</strong></p>
pointer-address
Function
:
pointer-address
ptr
⇒
address
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>address</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>pointer-address</code> will return the address of a foreign pointer ptr.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (pointer-address (null-pointer))
⇒ 0
CFFI&gt; (pointer-address (make-pointer 123))
⇒ 123</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#make_002dpointer">make-pointer</a> <a href="#inc_002dpointer">inc-pointer</a> <a href="#null_002dpointer">null-pointer</a> <a href="#null_002dpointer_002dp">null-pointer-p</a> <a href="#pointerp">pointerp</a> <a href="#pointer_002deq">pointer-eq</a> <a href="#mem_002dref">mem-ref</a></p>
<p><strong>pointer-eq</strong></p>
<p><strong>Syntax</strong></p>
pointer-eq
Function
:
pointer-eq
ptr1
ptr2
⇒
boolean
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr1; ptr2</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>boolean</dt>
<dd><p><code>T</code> or <code>NIL</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>pointer-eq</code> returns true if ptr1 and ptr2 point to the same memory address and false otherwise.</p>
<p><strong>Implementation-specific Notes</strong></p>
<p>The representation of foreign pointers varies across the various Lisp implementations as does the behaviour of the built-in Common Lisp equality predicates. Comparing two pointers that point to the same address with <code>EQ</code> Lisps will return true on some Lisps, others require more general predicates like <code>EQL</code> or <code>EQUALP</code> and finally some will return false using any of these predicates. Therefore, for portability, you should use <code>POINTER-EQ</code>.</p>
<p><strong>Examples</strong></p>
<p>This is an example using SBCL, see the implementation-specific notes above.</p>
<pre><code>CFFI&gt; (eql (null-pointer) (null-pointer))
⇒ NIL
CFFI&gt; (pointer-eq (null-pointer) (null-pointer))
⇒ T</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#inc_002dpointer">inc-pointer</a></p>
<p><strong>with-foreign-object, with-foreign-objects</strong></p>
<p><strong>Syntax</strong></p>
with-foreign-object
Macro
:
with-foreign-object
(
var
type
&amp;optional
count
)
&amp;body
body
with-foreign-objects
Macro
:
with-foreign-objects
(
bindings
)
&amp;body
body
<p>bindings ::= {(var type &amp;optional count)}*</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>var</dt>
<dd><p>A symbol.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign type, evaluated.</p>
</dd>
<dt>count</dt>
<dd><p>An integer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The macros <code>with-foreign-object</code> and <code>with-foreign-objects</code> bind var to a pointer to count newly allocated objects of type type during body. The buffer has dynamic extent and may be stack allocated if supported by the host Lisp.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-object (array :int 10)
        (dotimes (i 10)
          (setf (mem-aref array :int i) (random 100)))
        (loop for i below 10
              collect (mem-aref array :int i)))
⇒ (22 7 22 52 69 1 46 93 90 65)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dalloc">foreign-alloc</a></p>
<p><strong>with-foreign-pointer</strong></p>
<p><strong>Syntax</strong></p>
with-foreign-pointer
Macro
:
with-foreign-pointer
(
var
size
&amp;optional
size-var
)
&amp;body
body
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>var; size-var</dt>
<dd><p>A symbol.</p>
</dd>
<dt>size</dt>
<dd><p>An integer.</p>
</dd>
<dt>body</dt>
<dd><p>A list of forms to be executed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>with-foreign-pointer</code> macro, binds var to size bytes of foreign memory during body. The pointer in var is invalid beyond the dynamic extend of body and may be stack-allocated if supported by the implementation.</p>
<p>If size-var is supplied, it will be bound to size during body.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-pointer (string 4 size)
        (setf (mem-ref string :char (1- size)) 0)
        (lisp-string-to-foreign &quot;Popcorns&quot; string size)
        (loop for i from 0 below size
              collect (code-char (mem-ref string :char i))))
⇒ (#\P #\o #\p #\Null)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dalloc">foreign-alloc</a> <a href="#foreign_002dfree">foreign-free</a></p>
<h1 id="Strings">Strings</h1>
<p>As with many languages, Lisp and C have special support for logical arrays of characters, going so far as to give them a special name, “strings”. In that spirit, CFFI provides special support for translating between Lisp and C strings.</p>
<p>The <code>:string</code> type and the symbols related below also serve as an example of what you can do portably with CFFI; were it not included, you could write an equally functional <code>strings.lisp</code> without referring to any implementation-specific symbols.</p>
<p><strong>*default-foreign-encoding*</strong></p>
<p><strong>Syntax</strong></p>
*default-foreign-encoding*
Special Variable
:
*default-foreign-encoding*
<p><strong>Value type</strong></p>
<p>A keyword.</p>
<p><strong>Initial value</strong></p>
<p><code>:utf-8</code></p>
<p><strong>Description</strong></p>
<p>This special variable holds the default foreign encoding.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; *default-foreign-encoding*
:utf-8
CFFI&gt; (foreign-funcall &quot;strdup&quot; (:string :encoding :utf-16) &quot;foo&quot; :string)
&quot;f&quot;
CFFI&gt; (let ((*default-foreign-encoding* :utf-16))
        (foreign-funcall &quot;strdup&quot; (:string :encoding :utf-16) &quot;foo&quot; :string))
&quot;foo&quot;</code></pre>
<p><strong>See also</strong></p>
<p><a href="#Other-Types">Other Types</a> (<code>:string</code> type) <a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a> <a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a> <a href="#with_002dforeign_002dstring">with-foreign-string</a> <a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a></p>
<p><strong>foreign-string-alloc</strong></p>
<p><strong>Syntax</strong></p>
foreign-string-alloc
Function
:
foreign-string-alloc
string
&amp;key
encoding
null-terminated-p
start
end
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt><em>string</em></dt>
<dd><p>A Lisp string.</p>
</dd>
<dt><em>encoding</em></dt>
<dd><p>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.</p>
</dd>
<dt><em>null-terminated-p</em></dt>
<dd><p>Boolean, defaults to true.</p>
</dd>
<dt><em>start, end</em></dt>
<dd><p>Bounding index designators of string. 0 and <code>nil</code>, by default.</p>
</dd>
<dt><em>pointer</em></dt>
<dd><p>A pointer to the newly allocated foreign string.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-string-alloc</code> function allocates foreign memory holding a copy of string converted using the specified encoding. Start specifies an offset into string and end marks the position following the last element of the foreign string.</p>
<p>This string must be freed with <code>foreign-string-free</code>.</p>
<p>If null-terminated-p is false, the string will not be null-terminated.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defparameter *str* (foreign-string-alloc &quot;Hello, foreign world!&quot;))
⇒ #&lt;FOREIGN-ADDRESS #x00400560&gt;
CFFI&gt; (foreign-funcall &quot;strlen&quot; :pointer *str* :int)
⇒ 21</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dstring_002dfree">foreign-string-free</a> <a href="#with_002dforeign_002dstring">with-foreign-string</a></p>
<p><strong>foreign-string-free</strong></p>
<p><strong>Syntax</strong></p>
foreign-string-free
Function
:
foreign-string-free
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>pointer</dt>
<dd><p>A pointer to a string allocated by <code>foreign-string-alloc</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-string-free</code> function frees a foreign string allocated by <code>foreign-string-alloc</code>.</p>
<p><strong>Examples</strong></p>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a></p>
<p><strong>foreign-string-to-lisp</strong></p>
<p><strong>Syntax</strong></p>
foreign-string-to-lisp
Function
:
foreign-string-to-lisp
ptr
&amp;key
offset
count
max-chars
encoding
⇒
string
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>ptr</dt>
<dd><p>A pointer.</p>
</dd>
<dt>offset</dt>
<dd><p>An integer greater than or equal to 0. Defauls to 0.</p>
</dd>
<dt>count</dt>
<dd><p>Either <code>nil</code> (the default), or an integer greater than or equal to 0.</p>
</dd>
<dt>max-chars</dt>
<dd><p>An integer greater than or equal to 0. <code>(1- array-total-size-limit)</code>, by default.</p>
</dd>
<dt>encoding</dt>
<dd><p>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.</p>
</dd>
<dt>string</dt>
<dd><p>A Lisp string.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-string-to-lisp</code> function converts at most count octets from ptr into a Lisp string, using the defined encoding.</p>
<p>If count is <code>nil</code> (the default), characters are copied until max-chars is reached or a <code>NULL</code> character is found.</p>
<p>If ptr is a null pointer, returns <code>nil</code>.</p>
<p>Note that the <code>:string</code> type will automatically convert between Lisp strings and foreign strings.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-funcall &quot;getenv&quot; :string &quot;HOME&quot; :pointer)
⇒ #&lt;FOREIGN-ADDRESS #xBFFFFFD5&gt;
CFFI&gt; (foreign-string-to-lisp *)
⇒ &quot;/Users/luis&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a> <a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a></p>
<p><strong>lisp-string-to-foreign</strong></p>
<p><strong>Syntax</strong></p>
lisp-string-to-foreign
Function
:
lisp-string-to-foreign
string
buffer
bufsize
&amp;key
start
end
offset
encoding
⇒
buffer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt><em>string</em></dt>
<dd><p>A Lisp string.</p>
</dd>
<dt><em>buffer</em></dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt><em>bufsize</em></dt>
<dd><p>An integer.</p>
</dd>
<dt><em>start, end</em></dt>
<dd><p>Bounding index designators of string. 0 and <code>nil</code>, by default.</p>
</dd>
<dt><em>offset</em></dt>
<dd><p>An integer greater than or equal to 0. Defauls to 0.</p>
</dd>
<dt><em>encoding</em></dt>
<dd><p>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>lisp-string-to-foreign</code> function copies at most bufsize-1 octets from a Lisp string using the specified encoding into buffer+offset. The foreign string will be null-terminated.</p>
<p>Start specifies an offset into string and end marks the position following the last element of the foreign string.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-pointer-as-string (str 255)
        (lisp-string-to-foreign &quot;Hello, foreign world!&quot; str 6))
⇒ &quot;Hello&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a> <a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a></p>
<p><strong>with-foreign-string, with-foreign-strings</strong></p>
<p><strong>Syntax</strong></p>
with-foreign-string
Macro
:
with-foreign-string
(
var-or-vars
string
&amp;rest
args
)
&amp;body
body
with-foreign-strings
Macro
:
with-foreign-strings
(
bindings
)
&amp;body
body
<p>var-or-vars ::= var | (var &amp;optional octet-size-var) bindings ::= {(var-or-vars string &amp;rest args)}*</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt><em>var, byte-size-var</em></dt>
<dd><p>A symbol.</p>
</dd>
<dt><em>string</em></dt>
<dd><p>A Lisp string.</p>
</dd>
<dt><em>body</em></dt>
<dd><p>A list of forms to be executed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>with-foreign-string</code> macro will bind var to a newly allocated foreign string containing string. Args is passed to the underlying <code>foreign-string-alloc</code> call.</p>
<p>If octet-size-var is provided, it will be bound the length of foreign string in octets including the null terminator.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-string (foo &quot;12345&quot;)
        (foreign-funcall &quot;strlen&quot; :pointer foo :int))
⇒ 5</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a></p>
<p><strong>with-foreign-pointer-as-string</strong></p>
<p><strong>Syntax</strong></p>
with-foreign-pointer-as-string
Macro
:
with-foreign-pointer-as-string
(
var
size
&amp;optional
size-var
&amp;rest
args
)
&amp;body
body
⇒
string
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>var</dt>
<dd><p>A symbol.</p>
</dd>
<dt>string</dt>
<dd><p>A Lisp string.</p>
</dd>
<dt>body</dt>
<dd><p>List of forms to be executed.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>with-foreign-pointer-as-string</code> macro is similar to <code>with-foreign-pointer</code> except that var is used as the returned value of an implicit <code>progn</code> around body, after being converted to a Lisp string using the provided args.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-pointer-as-string (str 6 str-size :encoding :ascii)
        (lisp-string-to-foreign &quot;Hello, foreign world!&quot; str str-size))
⇒ &quot;Hello&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <a href="#with_002dforeign_002dstring">with-foreign-string</a></p>
<h1 id="Variables">Variables</h1>
<p><strong>defcvar</strong></p>
<p><strong>Syntax</strong></p>
defcvar
Macro
:
defcvar
name-and-options
type
&amp;optional
documentation
⇒
lisp-name
<p>name-and-options ::= name | (name &amp;key read-only (library :default)) name ::= lisp-name [foreign-name] | foreign-name [lisp-name]</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-name</dt>
<dd><p>A string denoting a foreign function.</p>
</dd>
<dt>lisp-name</dt>
<dd><p>A symbol naming the Lisp function to be created.</p>
</dd>
<dt>type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>read-only</dt>
<dd><p>A boolean.</p>
</dd>
<dt>documentation</dt>
<dd><p>A Lisp string; not evaluated.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>defcvar</code> macro defines a symbol macro lisp-name that looks up foreign-name and dereferences it acording to type. It can also be <code>setf</code>ed, unless read-only is true, in which case an error will be signaled.</p>
<p>When one of lisp-name or foreign-name is omitted, the other is automatically derived using the following rules:</p>
<ul>
<li><p>Foreign names are converted to Lisp names by uppercasing, replacing underscores with hyphens, and wrapping around asterisks.</p></li>
<li><p>Lisp names are converted to foreign names by lowercasing, replacing hyphens with underscores, and removing asterisks, if any.</p></li>
</ul>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defcvar &quot;errno&quot; :int)
⇒ *ERRNO*
CFFI&gt; (foreign-funcall &quot;strerror&quot; :int *errno* :string)
⇒ &quot;Inappropriate ioctl for device&quot;
CFFI&gt; (setf *errno* 1)
⇒ 1
CFFI&gt; (foreign-funcall &quot;strerror&quot; :int *errno* :string)
⇒ &quot;Operation not permitted&quot;</code></pre>
<p>Trying to modify a read-only foreign variable:</p>
<pre><code>CFFI&gt; (defcvar (&quot;errno&quot; +error-number+ :read-only t) :int)
⇒ +ERROR-NUMBER+
CFFI&gt; (setf +error-number+ 12)
;; error→ Trying to modify read-only foreign var: +ERROR-NUMBER+.</code></pre>
<p><em>Note that accessing <code>errno</code> this way won’t work with every implementation of the C standard library.</em></p>
<p><strong>See Also</strong></p>
<p><a href="#get_002dvar_002dpointer">get-var-pointer</a></p>
<p><strong>get-var-pointer</strong></p>
<p><strong>Syntax</strong></p>
get-var-pointer
Function
:
get-var-pointer
symbol
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>symbol</dt>
<dd><p>A symbol denoting a foreign variable defined with <code>defcvar</code>.</p>
</dd>
<dt>pointer</dt>
<dd><p>A foreign pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The function <code>get-var-pointer</code> will return a pointer to the foreign global variable symbol previously defined with <code>defcvar</code>.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defcvar &quot;errno&quot; :int :read-only t)
⇒ *ERRNO*
CFFI&gt; *errno*
⇒ 25
CFFI&gt; (get-var-pointer &#39;*errno*)
⇒ #&lt;A Mac Pointer #xA0008130&gt;
CFFI&gt; (mem-ref * :int)
⇒ 25</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcvar">defcvar</a></p>
<h1 id="Functions">Functions</h1>
<p><strong>defcfun</strong></p>
<p><strong>Syntax</strong></p>
defcfun
Macro
:
defcfun
name-and-options
return-type
&amp;body
[
docstring
]
arguments
[
&amp;rest
]
⇒
lisp-name
<p>name-and-options ::= name | (name &amp;key library convention) name ::= lisp-name [foreign-name] | foreign-name [lisp-name] arguments ::= { (arg-name arg-type) }*</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-name</dt>
<dd><p>A string denoting a foreign function.</p>
</dd>
<dt>lisp-name</dt>
<dd><p>A symbol naming the Lisp function to be created.</p>
</dd>
<dt>arg-name</dt>
<dd><p>A symbol.</p>
</dd>
<dt>return-type; arg-type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.</p>
</dd>
<dt>library</dt>
<dd><p>A symbol designating a foreign library.</p>
</dd>
<dt>docstring</dt>
<dd><p>A documentation string.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>defcfun</code> macro provides a declarative interface for defining Lisp functions that call foreign functions.</p>
<p>When one of lisp-name or foreign-name is omitted, the other is automatically derived using the following rules:</p>
<ul>
<li><p>Foreign names are converted to Lisp names by uppercasing and replacing underscores with hyphens.</p></li>
<li><p>Lisp names are converted to foreign names by lowercasing and replacing hyphens with underscores.</p></li>
</ul>
<p>If you place the symbol <code>&amp;rest</code> in the end of the argument list after the fixed arguments, <code>defcfun</code> will treat the foreign function as a <strong>variadic function</strong>. The variadic arguments should be passed in a way similar to what <code>foreign-funcall</code> would expect. Unlike <code>foreign-funcall</code> though, <code>defcfun</code> will take care of doing argument promotion. Note that in this case <code>defcfun</code> will generate a Lisp <em>macro</em> instead of a function and will only work for Lisps that support <code>foreign-funcall.</code></p>
<p>If a foreign structure is to be passed or returned by value (that is, the type is of the form <code>(:struct ...)</code>), then the cffi-libffi system must be loaded, which in turn depends on <a href="http://sourceware.org/libffi/">libffi</a>, including the header files. Failure to load that system will result in an error. Variadic functions cannot at present accept or return structures by value.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcfun &quot;strlen&quot; :int
  &quot;Calculate the length of a string.&quot;
  (n :string))

CFFI&gt; (strlen &quot;123&quot;)
⇒ 3</code></pre>
<pre><code>(defcfun (&quot;abs&quot; c-abs) :int (n :int))

CFFI&gt; (c-abs -42)
⇒ 42</code></pre>
<p>Function without arguments:</p>
<pre><code>(defcfun &quot;rand&quot; :int)

CFFI&gt; (rand)
⇒ 1804289383</code></pre>
<p>Variadic function example:</p>
<pre><code>(defcfun &quot;sprintf&quot; :int
  (str :pointer)
  (control :string)
  &amp;rest)

CFFI&gt; (with-foreign-pointer-as-string (s 100)
        (sprintf s &quot;%c %d %.2f %s&quot; :char 90 :short 42 :float pi
                 :string &quot;super-locrian&quot;))
⇒ &quot;A 42 3.14 super-locrian&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#foreign_002dfuncall">foreign-funcall</a> <a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a> <a href="#foreign_002dfuncall_002dvarargs">foreign-funcall-varargs</a> <a href="#foreign_002dfuncall_002dpointer_002dvarargs">foreign-funcall-pointer-varargs</a></p>
<p><strong>foreign-funcall</strong></p>
<p><strong>Syntax</strong></p>
foreign-funcall
Macro
:
foreign-funcall
name-and-options
&amp;rest
arguments
⇒
return-value
<p>arguments ::= { arg-type arg }* [return-type] name-and-options ::= name | (name &amp;key library convention)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>A Lisp string.</p>
</dd>
<dt>arg-type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>arg</dt>
<dd><p>An argument of type arg-type.</p>
</dd>
<dt>return-type</dt>
<dd><p>A foreign type, <code>:void</code> by default.</p>
</dd>
<dt>return-value</dt>
<dd><p>A lisp object.</p>
</dd>
<dt>library</dt>
<dd><p>A lisp symbol; not evaluated.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-funcall</code> macro is the main primitive for calling foreign functions.</p>
<p>If a foreign structure is to be passed or returned by value (that is, the type is of the form <code>(:struct ...)</code>), then the cffi-libffi system must be loaded, which in turn depends on <a href="http://sourceware.org/libffi/">libffi</a>, including the header files. Failure to load that system will result in an error. Variadic functions cannot at present accept or return structures by value.</p>
<p><em>Note: The return value of foreign-funcall on functions with a :void return type is still undefined.</em></p>
<p><strong>Implementation-specific Notes</strong></p>
<ul>
<li><p>Corman Lisp does not support <code>foreign-funcall</code>. On implementations that <strong>don’t</strong> support <code>foreign-funcall</code> <code>cffi-sys::no-foreign-funcall</code> will be present in <code>*features*</code>. Note: in these Lisps you can still use the <code>defcfun</code> interface.</p></li>
</ul>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-funcall &quot;strlen&quot; :string &quot;foo&quot; :int)
⇒ 3</code></pre>
<p>Given the C code:</p>
<pre><code>void print_number(int n)
{
    printf(&quot;N: %d\n&quot;, n);
}</code></pre>
<pre><code>CFFI&gt; (foreign-funcall &quot;print_number&quot; :int 123456)
⊣ N: 123456
⇒ NIL</code></pre>
<p>Or, equivalently:</p>
<pre><code>CFFI&gt; (foreign-funcall &quot;print_number&quot; :int 123456 :void)
⊣ N: 123456
⇒ NIL</code></pre>
<pre><code>CFFI&gt; (foreign-funcall &quot;printf&quot; :string (format nil &quot;%s: %d.~%&quot;)
                       :string &quot;So long and thanks for all the fish&quot;
                       :int 42 :int)
⊣ So long and thanks for all the fish: 42.
⇒ 41</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcfun">defcfun</a> <a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a></p>
<p><strong>foreign-funcall-pointer</strong></p>
<p><strong>Syntax</strong></p>
foreign-funcall-pointer
Macro
:
foreign-funcall-pointer
pointer
options
&amp;rest
arguments
⇒
return-value
<p>arguments ::= { arg-type arg }* [return-type] options ::= (&amp;key convention)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>pointer</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>arg-type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>arg</dt>
<dd><p>An argument of type arg-type.</p>
</dd>
<dt>return-type</dt>
<dd><p>A foreign type, <code>:void</code> by default.</p>
</dd>
<dt>return-value</dt>
<dd><p>A lisp object.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-funcall</code> macro is the main primitive for calling foreign functions.</p>
<p><em>Note: The return value of foreign-funcall on functions with a :void return type is still undefined.</em></p>
<p><strong>Implementation-specific Notes</strong></p>
<ul>
<li><p>Corman Lisp does not support <code>foreign-funcall</code>. On implementations that <strong>don’t</strong> support <code>foreign-funcall</code> <code>cffi-sys::no-foreign-funcall</code> will be present in <code>*features*</code>. Note: in these Lisps you can still use the <code>defcfun</code> interface.</p></li>
</ul>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (foreign-funcall-pointer (foreign-symbol-pointer &quot;abs&quot;) ()
                               :int -42 :int)
⇒ 42</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcfun">defcfun</a> <a href="#foreign_002dfuncall">foreign-funcall</a></p>
<p><strong>foreign-funcall-varargs</strong></p>
<p><strong>Syntax</strong></p>
foreign-funcall-varargs
Macro
:
foreign-funcall-varargs
name-and-options
(
fixed-arguments
)
&amp;rest
arguments
⇒
return-value
<p>fixed-arguments ::= { arg-type arg }* [return-type] arguments ::= { arg-type arg }* [return-type] name-and-options ::= name | (name &amp;key library convention)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>A Lisp string.</p>
</dd>
<dt>arg-type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>arg</dt>
<dd><p>An argument of type arg-type.</p>
</dd>
<dt>return-type</dt>
<dd><p>A foreign type, <code>:void</code> by default.</p>
</dd>
<dt>return-value</dt>
<dd><p>A lisp object.</p>
</dd>
<dt>library</dt>
<dd><p>A lisp symbol; not evaluated.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-funcall-varargs</code> macro is the main primitive for calling foreign variadic functions. It behaves similarily to <code>foreign-funcall</code> except <code>fixed-arguments</code> are distinguished from the remaining arguments.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-pointer-as-string (s 100)
        (setf (mem-ref s :char) 0)
        (foreign-funcall-varargs
         &quot;sprintf&quot; (:pointer s :string) &quot;%.2f&quot;)
         :double (coerce pi &#39;double-float) :int))
⇒ 3.14</code></pre>
<p><strong>foreign-funcall-pointer-varargs</strong></p>
<p><strong>Syntax</strong></p>
foreign-funcall-pointer-varargs
Macro
:
foreign-funcall-pointer-varargs
pointer
options
(
fixed-arguments
)
&amp;rest
arguments
⇒
return-value
<p>fixed-arguments ::= { arg-type arg }* [return-type] arguments ::= { arg-type arg }* [return-type] options ::= (&amp;key convention)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>pointer</dt>
<dd><p>A foreign pointer.</p>
</dd>
<dt>arg-type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>arg</dt>
<dd><p>An argument of type arg-type.</p>
</dd>
<dt>return-type</dt>
<dd><p>A foreign type, <code>:void</code> by default.</p>
</dd>
<dt>return-value</dt>
<dd><p>A lisp object.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>foreign-funcall-pointer-varargs</code> macro is the main primitive for calling foreign variadic functions. It behaves similarily to <code>foreign-funcall-pointer</code> except <code>fixed-arguments</code> are distinguished from the remaining arguments.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (with-foreign-pointer-as-string (s 100)
        (setf (mem-ref s :char) 0)
        (foreign-funcall-pointer-varargs
         (foreign-symbol-pointer &quot;sprintf&quot;) () (:pointer s :string &quot;%.2f&quot;)
         :double (coerce pi &#39;double-float) :int))
⇒ 3.14</code></pre>
<p><strong>translate-camelcase-name</strong></p>
<p><strong>Syntax</strong></p>
translate-camelcase-name
Function
:
translate-camelcase-name
name
&amp;key
upper-initial-p
special-words
⇒
return-value
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>Either a symbol or a string.</p>
</dd>
<dt>upper-initial-p</dt>
<dd><p>A generalized boolean.</p>
</dd>
<dt>special words</dt>
<dd><p>A list of strings.</p>
</dd>
<dt>return-value</dt>
<dd><p>If name is a symbol, this is a string, and vice versa.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code>translate-camelcase-name</code> is a helper function for specializations of <code>translate-name-from-foreign</code> and <code>translate-name-to-foreign</code>. It handles the common case of converting between foreign camelCase names and lisp names. upper-initial-p indicates whether the first letter of the foreign name should be uppercase. special-words is a list of strings that should be treated atomically in translation. This list is case-sensitive.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (translate-camelcase-name some-xml-function)
⇒ &quot;someXmlFunction&quot;
CFFI&gt; (translate-camelcase-name some-xml-function :upper-initial-p t)
⇒ &quot;SomeXmlFunction&quot;
CFFI&gt; (translate-camelcase-name some-xml-function :special-words &#39;(&quot;XML&quot;))
⇒ &quot;someXMLFunction&quot;
CFFI&gt; (translate-camelcase-name &quot;someXMLFunction&quot;)
⇒ SOME-X-M-L-FUNCTION
CFFI&gt; (translate-camelcase-name &quot;someXMLFunction&quot; :special-words &#39;(&quot;XML&quot;))
⇒ SOME-XML-FUNCTION</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a></p>
<p><strong>translate-name-from-foreign</strong></p>
<p><strong>Syntax</strong></p>
translate-name-from-foreign
Function
:
translate-name-from-foreign
foreign-name
package
&amp;optional
varp
⇒
symbol
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>foreign-name</dt>
<dd><p>A string denoting a foreign function.</p>
</dd>
<dt>package</dt>
<dd><p>A Lisp package</p>
</dd>
<dt>varp</dt>
<dd><p>A generalized boolean.</p>
</dd>
<dt>symbol</dt>
<dd><p>The Lisp symbol to be used a function name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code>translate-name-from-foreign</code> is used by <a href="#defcfun">defcfun</a> to handle the conversion of foreign names to lisp names. By default, it translates using <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>. However, you can create specialized methods on this function to make translating more closely match the foreign library’s naming conventions.</p>
<p>Specialize package on some package. This allows other packages to load libraries with different naming conventions.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defcfun &quot;someXmlFunction&quot; ...)
⇒ SOMEXMLFUNCTION
CFFI&gt; (defmethod translate-name-from-foreign ((spec string)
                                              (package (eql *package*))
                                              &amp;optional varp)
        (let ((name (translate-camelcase-name spec)))
          (if varp (intern (format nil &quot;*~a*&quot; name)) name)))
⇒ #&lt;STANDARD-METHOD TRANSLATE-NAME-FROM-FOREIGN (STRING (EQL #&lt;Package &quot;SOME-PACKAGE&quot;&gt;))&gt;
CFFI&gt; (defcfun &quot;someXmlFunction&quot; ...)
⇒ SOME-XML-FUNCTION</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcfun">defcfun</a> <a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a> <a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a></p>
<p><strong>translate-name-to-foreign</strong></p>
<p><strong>Syntax</strong></p>
translate-name-to-foreign
Function
:
translate-name-to-foreign
lisp-name
package
&amp;optional
varp
⇒
string
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>lisp-name</dt>
<dd><p>A symbol naming the Lisp function to be created.</p>
</dd>
<dt>package</dt>
<dd><p>A Lisp package</p>
</dd>
<dt>varp</dt>
<dd><p>A generalized boolean.</p>
</dd>
<dt>string</dt>
<dd><p>The string representing the foreign function name.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code>translate-name-to-foreign</code> is used by <a href="#defcfun">defcfun</a> to handle the conversion of lisp names to foreign names. By default, it translates using <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>. However, you can create specialized methods on this function to make translating more closely match the foreign library’s naming conventions.</p>
<p>Specialize package on some package. This allows other packages to load libraries with different naming conventions.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defcfun some-xml-function ...)
⇒ &quot;some_xml_function&quot;
CFFI&gt; (defmethod translate-name-to-foreign ((spec symbol)
                                            (package (eql *package*))
                                            &amp;optional varp)
        (let ((name (translate-camelcase-name spec)))
          (if varp (subseq name 1 (1- (length name))) name)))
⇒ #&lt;STANDARD-METHOD TRANSLATE-NAME-TO-FOREIGN (STRING (EQL #&lt;Package &quot;SOME-PACKAGE&quot;&gt;))&gt;
CFFI&gt; (defcfun some-xml-function ...)
⇒ &quot;someXmlFunction&quot;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#defcfun">defcfun</a> <a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a> <a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a></p>
<p><strong>translate-underscore-separated-name</strong></p>
<p><strong>Syntax</strong></p>
translate-underscore-separated-name
Function
:
translate-underscore-separated-name
name
⇒
return-value
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>Either a symbol or a string.</p>
</dd>
<dt>return-value</dt>
<dd><p>If name is a symbol, this is a string, and vice versa.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p><code>translate-underscore-separated-name</code> is a helper function for specializations of <a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> and <a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>. It handles the common case of converting between foreign underscore_separated names and lisp names.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (translate-underscore-separated-name some-xml-function)
⇒ &quot;some_xml_function&quot;
CFFI&gt; (translate-camelcase-name &quot;some_xml_function&quot;)
⇒ SOME-XML-FUNCTION</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a></p>
<h1 id="Libraries">Libraries</h1>
<h2 id="Defining-a-library">Defining a library</h2>
<p>Almost all foreign code you might want to access exists in some kind of shared library. The meaning of shared library varies among platforms, but for our purposes, we will consider it to include <code>.so</code> files on UNIX, frameworks on Darwin (and derivatives like Mac OS X), and <code>.dll</code> files on Windows.</p>
<p>Bringing one of these libraries into the Lisp image is normally a two-step process.</p>
<ol type="1">
<li><p>Describe to CFFI how to load the library at some future point, depending on platform and other factors, with a <code>define-foreign-library</code> top-level form.</p></li>
<li><p>Load the library so defined with either a top-level <code>use-foreign-library</code> form or by calling the function <code>load-foreign-library</code>.</p></li>
</ol>
<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>, for a working example of the above two steps.</p>
<h2 id="Library-definition-style">Library definition style</h2>
<p>Looking at the <code>libcurl</code> library definition presented earlier, you may ask why we did not simply do this:</p>
<pre><code>(define-foreign-library libcurl
  (t (:default &quot;libcurl&quot;)))</code></pre>
<p>Indeed, this would work just as well on the computer on which I tested the tutorial. There are a couple of good reasons to provide the <code>.so</code>’s current version number, however. Namely, the versionless <code>.so</code> is not packaged on most UNIX systems along with the actual, fully-versioned library; instead, it is included in the “development” package along with C headers and static <code>.a</code> libraries.</p>
<p>The reason CFFI does not try to account for this lies in the meaning of the version numbers. A full treatment of shared library versions is beyond this manual’s scope; see section “Library interface versions” in GNU Libtool, for helpful information for the unfamiliar. For our purposes, consider that a mismatch between the library version with which you tested and the installed library version may cause undefined behavior.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>Maybe some notes should go here about OS X, which I know little about. –stephen</em></p>
</blockquote>
<p><strong>close-foreign-library</strong></p>
<p><strong>Syntax</strong></p>
close-foreign-library
Function
:
close-foreign-library
library
⇒
success
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>library</dt>
<dd><p>A symbol or an instance of <code>foreign-library</code>.</p>
</dd>
<dt>success</dt>
<dd><p>A Lisp boolean.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Closes library which can be a symbol designating a library define through <code>define-foreign-library</code> or an instance of <code>foreign-library</code> as returned by <code>load-foreign-library</code>.</p>
<p><strong>See Also</strong></p>
<p><a href="#define_002dforeign_002dlibrary">define-foreign-library</a> <a href="#load_002dforeign_002dlibrary">load-foreign-library</a> <a href="#use_002dforeign_002dlibrary">use-foreign-library</a></p>
<p><strong>*darwin-framework-directories*</strong></p>
<p><strong>Syntax</strong></p>
*darwin-framework-directories*
Special Variable
:
*darwin-framework-directories*
<p><strong>Value type</strong></p>
<p>A list, in which each element is a string, a pathname, or a simple Lisp expression.</p>
<p><strong>Initial value</strong></p>
<p>A list containing the following, in order: an expression corresponding to Darwin path <code>~/Library/Frameworks/</code>, <code>#P"/Library/Frameworks/"</code>, and <code>#P"/System/Library/Frameworks/"</code>.</p>
<p><strong>Description</strong></p>
<p>The meaning of “simple Lisp expression” is explained in <a href="#_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>. In contrast to that variable, this is not a fallback search path; the default value described above is intended to be a reasonably complete search path on Darwin systems.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (let ((lib (load-foreign-library &#39;(:framework &quot;OpenGL&quot;))))
        (foreign-library-pathname lib))
⇒ #P&quot;/System/Library/Frameworks/OpenGL.framework/OpenGL&quot;</code></pre>
<p><strong>See also</strong></p>
<p><a href="#_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a> <a href="#define_002dforeign_002dlibrary">define-foreign-library</a></p>
<p><strong>define-foreign-library</strong></p>
<p><strong>Syntax</strong></p>
define-foreign-library
Macro
:
define-foreign-library
name-and-options
{
load-clause
}
*
⇒
name
<p>name-and-options ::= name | (name &amp;key canary convention search-path) load-clause ::= (feature library &amp;key convention search-path)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>A symbol.</p>
</dd>
<dt>feature</dt>
<dd><p>A feature expression.</p>
</dd>
<dt>library</dt>
<dd><p>A library designator.</p>
</dd>
<dt>canary</dt>
<dd><p>A string denoting a foreign symbol that will be searched in core before attempting to load the library. If that symbol is found, the library is assumed to be statically linked and <code>load-foreign-library</code> only marks the library as loaded.</p>
<p>Some implementations (Clisp, ECL, SBCL) natively support static linking, sometimes referred to as a <em>link kit</em>.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code></p>
</dd>
<dt>search-path</dt>
<dd><p>A path or list of paths where the library will be searched if not found in system-global directories. Paths specified in a load clause take priority over paths specified as library option, with *foreign-library-directories* having lowest priority.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Creates a new library designator called name. The load-clauses describe how to load that designator when passed to <code>load-foreign-library</code> or <code>use-foreign-library</code>.</p>
<p>When trying to load the library name, the relevant function searches the load-clauses in order for the first one where feature evaluates to true. That happens for any of the following situations:</p>
<ol type="1">
<li><p>If feature is a symbol present in <code>common-lisp:*features*</code>.</p></li>
<li><p>If feature is a list, depending on <code>(first feature)</code>, a keyword:</p>
<dl>
<dt><code>:and</code></dt>
<dd><p>All of the feature expressions in <code>(rest feature)</code> are true.</p>
</dd>
<dt><code>:or</code></dt>
<dd><p>At least one of the feature expressions in <code>(rest feature)</code> is true.</p>
</dd>
<dt><code>:not</code></dt>
<dd><p>The feature expression <code>(second feature)</code> is not true.</p>
</dd>
</dl></li>
<li><p>Finally, if feature is <code>t</code>, this load-clause is picked unconditionally.</p></li>
</ol>
<p>Upon finding the first true feature, the library loader then loads the library. The meaning of “library designator” is described in <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>.</p>
<p>Functions associated to a library defined by <code>define-foreign-library</code> (e.g. through <code>defcfun</code>’s <code>:library</code> option, will inherit the library’s options. The precedence is as follows:</p>
<ol type="1">
<li><p><code>defcfun</code>/<code>foreign-funcall</code> specific options;</p></li>
<li><p>load-clause options;</p></li>
<li><p>global library options (the name-and-options argument)</p></li>
</ol>
<p><strong>Examples</strong></p>
<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.</p>
<p><strong>See Also</strong></p>
<p><a href="#close_002dforeign_002dlibrary">close-foreign-library</a> <a href="#load_002dforeign_002dlibrary">load-foreign-library</a></p>
<p><strong>*foreign-library-directories*</strong></p>
<p><strong>Syntax</strong></p>
*foreign-library-directories*
Special Variable
:
*foreign-library-directories*
<p><strong>Value type</strong></p>
<p>A list, in which each element is a string, a pathname, or a simple Lisp expression.</p>
<p><strong>Initial value</strong></p>
<p>The empty list.</p>
<p><strong>Description</strong></p>
<p>You should not have to use this variable.</p>
<p>Most, if not all, Lisps supported by CFFI have a reasonable default search algorithm for foreign libraries. For example, Lisps for UNIX usually call <a href="http://www.opengroup.org/onlinepubs/009695399/functions/dlopen.html"><code>dlopen(3)</code></a>, which in turn looks in the system library directories. Only if that fails does CFFI look for the named library file in these directories, and load it from there if found.</p>
<p>Thus, this is intended to be a CFFI-only fallback to the library search configuration provided by your operating system. For example, if you distribute a foreign library with your Lisp package, you can add the library’s containing directory to this list and portably expect CFFI to find it.</p>
<p>A simple Lisp expression is intended to provide functionality commonly used in search paths such as ASDF’s<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>, and is defined recursively as follows:<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a></p>
<ol type="1">
<li><p>A list, whose ‘<code>first</code>’ is a function designator, and whose ‘<code>rest</code>’ is a list of simple Lisp expressions to be evaluated and passed to the so-designated function. The result is the result of the function call.</p></li>
<li><p>A symbol, whose result is its symbol value.</p></li>
<li><p>Anything else evaluates to itself.</p></li>
</ol>
<p>The result of evaluating the simple Lisp expression should yield a <em>designator</em> for a <em>list</em> of <em>pathname designators</em>.</p>
<p><strong>Note</strong>: in Common Lisp, <code>#p"/foo/bar"</code> designates the <em>bar</em> file within the <em>/foo</em> directory whereas <code>#p"/foo/bar/"</code> designates the <em>/foo/bar</em> directory. Keep that in mind when customising the value of <code>*foreign-library-directories*</code>.</p>
<p><strong>Examples</strong></p>
<pre><code>$ ls
⊣ liblibli.so    libli.lisp</code></pre>
<p>In <code>libli.lisp</code>:</p>
<pre><code>(pushnew #P&quot;/home/sirian/lisp/libli/&quot; *foreign-library-directories*
         :test #&#39;equal)

(load-foreign-library &#39;(:default &quot;liblibli&quot;))</code></pre>
<p>The following example would achieve the same effect:</p>
<pre><code>(pushnew &#39;(merge-pathnames #p&quot;lisp/libli/&quot; (user-homedir-pathname))
          *foreign-library-directories*
          :test #&#39;equal)
⇒ ((MERGE-PATHNAMES #P&quot;lisp/libli/&quot; (USER-HOMEDIR-PATHNAME)))

(load-foreign-library &#39;(:default &quot;liblibli&quot;))</code></pre>
<p><strong>See also</strong></p>
<p><a href="#_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a> <a href="#define_002dforeign_002dlibrary">define-foreign-library</a></p>
<p><strong>load-foreign-library</strong></p>
<p><strong>Syntax</strong></p>
load-foreign-library
Function
:
load-foreign-library
library-designator
⇒
library
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>library-designator</dt>
<dd><p>A library designator.</p>
</dd>
<dt>library-designator</dt>
<dd><p>An instance of <code>foreign-library</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Load the library indicated by library-designator. A library designator is defined as follows:</p>
<ol type="1">
<li><p>If a symbol, is considered a name previously defined with <code>define-foreign-library</code>.</p></li>
<li><p>If a string or pathname, passed as a namestring directly to the implementation’s foreign library loader. If that fails, search the directories in <code>*foreign-library-directories*</code> with <code>cl:probe-file</code>; if found, the absolute path is passed to the implementation’s loader.</p></li>
<li><p>If a list, the meaning depends on <code>(first library)</code>:</p>
<dl>
<dt><code>:framework</code></dt>
<dd><p>The second list element is taken to be a Darwin framework name, which is then searched in <code>*darwin-framework-directories*</code>, and loaded when found.</p>
</dd>
<dt><code>:or</code></dt>
<dd><p>Each remaining list element, itself a library designator, is loaded in order, until one succeeds.</p>
</dd>
<dt><code>:default</code></dt>
<dd><p>The name is transformed according to the platform’s naming convention to shared libraries, and the resultant string is loaded as a library designator. For example, on UNIX, the name is suffixed with <code>.so</code>.</p>
</dd>
</dl></li>
</ol>
<p>If the library is already loaded it will be reloaded.</p>
<p>If the load fails, signal a <code>load-foreign-library-error</code>.</p>
<p><strong>Please note:</strong> For system libraries, you should not need to specify the directory containing the library. Each operating system has its own idea of a default search path, and you should rely on it when it is reasonable.</p>
<p><strong>Implementation-specific Notes</strong></p>
<p>On ECL platforms where its dynamic FFI is not supported (ie. when <code>:dffi</code> is not present in <code>*features*</code>), <code>cffi:load-foreign-library</code> does not work and you must use ECL’s own <code>ffi:load-foreign-library</code> with a constant string argument.</p>
<p><strong>Examples</strong></p>
<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.</p>
<p><strong>See Also</strong></p>
<p><a href="#close_002dforeign_002dlibrary">close-foreign-library</a> <a href="#_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a> <a href="#define_002dforeign_002dlibrary">define-foreign-library</a> <a href="#_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a> <a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a> <a href="#use_002dforeign_002dlibrary">use-foreign-library</a></p>
<p><strong>load-foreign-library-error</strong></p>
<p><strong>Syntax</strong></p>
load-foreign-library-error
Condition Type
:
load-foreign-library-error
<p><strong>Class precedence list</strong></p>
<p><code>load-foreign-library-error</code>, <code>error</code>, <code>serious-condition</code>, <code>condition</code>, <code>t</code></p>
<p><strong>Description</strong></p>
<p>Signalled when a foreign library load completely fails. The exact meaning of this varies depending on the real conditions at work, but almost universally, the implementation’s error message is useless. However, CFFI does provide the useful restarts <code>retry</code> and <code>use-value</code>; invoke the <code>retry</code> restart to try loading the foreign library again, or the <code>use-value</code> restart to try loading a different foreign library designator.</p>
<p><strong>See also</strong></p>
<p><a href="#load_002dforeign_002dlibrary">load-foreign-library</a></p>
<p><strong>use-foreign-library</strong></p>
<p><strong>Syntax</strong></p>
use-foreign-library
Macro
:
use-foreign-library
name
<p><strong>Arguments and values</strong></p>
<dl>
<dt>name</dt>
<dd><p>A library designator; unevaluated.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>See <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>, for the meaning of “library designator”. This is intended to be the top-level form used idiomatically after a <code>define-foreign-library</code> form to go ahead and load the library. Finally, on implementations where the regular evaluation rule is insufficient for foreign library loading, it loads it at the required time.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></p>
<p><strong>Examples</strong></p>
<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.</p>
<p><strong>See also</strong></p>
<p><a href="#load_002dforeign_002dlibrary">load-foreign-library</a></p>
<h1 id="Callbacks">Callbacks</h1>
<p><strong>callback</strong></p>
<p><strong>Syntax</strong></p>
callback
Macro
:
callback
symbol
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>symbol</dt>
<dd><p>A symbol denoting a callback.</p>
</dd>
<dt>pointer; new-value</dt>
<dd><p>A pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>callback</code> macro is analogous to the standard CL special operator <code>function</code> and will return a pointer to the callback denoted by the symbol name.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defcallback sum :int ((a :int) (b :int))
        (+ a b))
⇒ SUM
CFFI&gt; (callback sum)
⇒ #&lt;A Mac Pointer #x102350&gt;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#get_002dcallback">get-callback</a> <a href="#defcallback">defcallback</a></p>
<p><strong>defcallback</strong></p>
<p><strong>Syntax</strong></p>
defcallback
Macro
:
defcallback
name-and-options
return-type
arguments
&amp;body
body
⇒
name
<p>name-and-options ::= name | (name &amp;key convention) arguments ::= ({ (arg-name arg-type) }*)</p>
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>name</dt>
<dd><p>A symbol naming the callback created.</p>
</dd>
<dt>return-type</dt>
<dd><p>The foreign type for the callback’s return value.</p>
</dd>
<dt>arg-name</dt>
<dd><p>A symbol.</p>
</dd>
<dt>arg-type</dt>
<dd><p>A foreign type.</p>
</dd>
<dt>convention</dt>
<dd><p>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>The <code>defcallback</code> macro defines a Lisp function that can be called from C. The arguments passed to this function will be converted to the appropriate Lisp representation and its return value will be converted to its C representation.</p>
<p>This Lisp function can be accessed by the <code>callback</code> macro or the <code>get-callback</code> function.</p>
<p><strong>Portability note:</strong> <code>defcallback</code> will not work correctly on some Lisps if it’s not a top-level form.</p>
<p><strong>Examples</strong></p>
<pre><code>(defcfun &quot;qsort&quot; :void
  (base :pointer)
  (nmemb :int)
  (size :int)
  (fun-compar :pointer))

(defcallback &lt; :int ((a :pointer) (b :pointer))
  (let ((x (mem-ref a :int))
        (y (mem-ref b :int)))
    (cond ((&gt; x y) 1)
          ((&lt; x y) -1)
          (t 0))))

CFFI&gt; (with-foreign-object (array :int 10)
        ;; Initialize array.
        (loop for i from 0 and n in &#39;(7 2 10 4 3 5 1 6 9 8)
              do (setf (mem-aref array :int i) n))
        ;; Sort it.
        (qsort array 10 (foreign-type-size :int) (callback &lt;))
        ;; Return it as a list.
        (loop for i from 0 below 10
              collect (mem-aref array :int i)))
⇒ (1 2 3 4 5 6 7 8 9 10)</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#callback">callback</a> <a href="#get_002dcallback">get-callback</a></p>
<p><strong>get-callback</strong></p>
<p><strong>Syntax</strong></p>
get-callback
Accessor
:
get-callback
symbol
⇒
pointer
<p><strong>Arguments and Values</strong></p>
<dl>
<dt>symbol</dt>
<dd><p>A symbol denoting a callback.</p>
</dd>
<dt>pointer</dt>
<dd><p>A pointer.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This is the functional version of the <code>callback</code> macro. It returns a pointer to the callback named by symbol suitable, for example, to pass as arguments to foreign functions.</p>
<p><strong>Examples</strong></p>
<pre><code>CFFI&gt; (defcallback sum :int ((a :int) (b :int))
        (+ a b))
⇒ SUM
CFFI&gt; (get-callback &#39;sum)
⇒ #&lt;A Mac Pointer #x102350&gt;</code></pre>
<p><strong>See Also</strong></p>
<p><a href="#callback">callback</a> <a href="#defcallback">defcallback</a></p>
<h1 id="The-Groveller">The Groveller</h1>
<p>CFFI-Grovel is a tool which makes it easier to write CFFI declarations for libraries that are implemented in C. That is, it grovels through the system headers, getting information about types and structures, so you don’t have to. This is especially important for libraries which are implemented in different ways by different vendors, such as the UNIX/POSIX functions. The CFFI declarations are usually quite different from platform to platform, but the information you give to CFFI-Grovel is the same. Hence, much less work is required!</p>
<p>If you use ASDF, CFFI-Grovel is integrated, so that it will run automatically when your system is building. This feature was inspired by SB-Grovel, a similar SBCL-specific project. CFFI-Grovel can also be used without ASDF.</p>
<h2>Building FFIs with CFFI-Grovel</h2>
<p>CFFI-Grovel uses a specification file (*.lisp) describing the features that need groveling. The C compiler is used to retrieve this data and write a Lisp file (*.cffi.lisp) which contains the necessary CFFI definitions to access the variables, structures, constants, and enums mentioned in the specification.</p>
<p>CFFI-Grovel provides an ASDF component for handling the necessary calls to the C compiler and resulting file management.</p>
<h2 id="Groveller-Syntax">Specification File Syntax</h2>
<p>The specification files are read by the normal Lisp reader, so they have syntax very similar to normal Lisp code. In particular, semicolon-comments and reader-macros will work as expected.</p>
<p>There are several forms recognized by CFFI-Grovel:</p>
progn
Grovel Form
:
progn
&amp;rest
forms
<blockquote>
<p>Processes a list of forms. Useful for conditionalizing several forms. For example:</p>
</blockquote>
<pre><code>#+freebsd
(progn
  (constant (ev-enable &quot;EV_ENABLE&quot;))
  (constant (ev-disable &quot;EV_DISABLE&quot;)))</code></pre>
include
Grovel Form
:
include
&amp;rest
files
<blockquote>
<p>Include the specified files (specified as strings) in the generated C source code.</p>
</blockquote>
in-package
Grovel Form
:
in-package
symbol
<blockquote>
<p>Set the package to be used for the final Lisp output.</p>
</blockquote>
ctype
Grovel Form
:
ctype
lisp-name
size-designator
<blockquote>
<p>Define a CFFI foreign type for the string in size-designator, e.g. <code>(ctype :pid "pid_t")</code>.</p>
</blockquote>
constant
Grovel Form
:
constant
(
lisp-name
&amp;rest
c-names
)
&amp;key
type
documentation
optional
<blockquote>
<p>Search for the constant named by the first c-name string found to be known to the C preprocessor and define it as lisp-name.</p>
<p>The type keyword argument specifies how to grovel the constant: either <code>integer</code> (the default) or <code>double-float</code>. If optional is true, no error will be raised if all the c-names are unknown. If lisp-name is a keyword, the actual constant will be a symbol of the same name interned in the current package.</p>
</blockquote>
feature
Grovel Form
:
feature
lisp-feature-name
c-name
&amp;key
feature-list
<blockquote>
<p>Adds lisp-feature-name to the list feature-list if the c-name string is known to the C preprocessor. feature-list defaults to <code>cl:*features*</code>.</p>
</blockquote>
define
Grovel Form
:
define
name
&amp;optional
value
<blockquote>
<p>Defines an additional C preprocessor symbol, which is useful for altering the behavior of included system headers.</p>
</blockquote>
cc-flags
Grovel Form
:
cc-flags
&amp;rest
flags
<blockquote>
<p>Adds cc-flags to the command line arguments used for the C compiler invocation.</p>
</blockquote>
pkg-config-cflags
Grovel Form
:
pkg-config-cflags
pkg
&amp;key
optional
<blockquote>
<p>Adds pkg to the command line arguments for the external program <code>pkg-config</code> and runs it to retrieve the relevant include flags used for the C compiler invocation. This syntax can be used instead of hard-coding paths using <code>cc-flags</code>, and ensures that include flags are added correctly on the build system. Assumes <code>pkg-config</code> is installed and working. pkg is a string that identifies an installed <code>pkg-config</code> package. See the pkg-config manual for more information. If optional is true, failure to execute <code>pkg-config</code> does <em>not</em> abort compilation.</p>
</blockquote>
cstruct
Grovel Form
:
cstruct
lisp-name
c-name
slots
<blockquote>
<p>Define a CFFI foreign struct with the slot data specfied. Slots are of the form <code>(lisp-name c-name &amp;key type count (signed t))</code>.</p>
</blockquote>
cunion
Grovel Form
:
cunion
lisp-name
c-name
slots
<blockquote>
<p>Identical to <code>cstruct</code>, but defines a CFFI foreign union.</p>
</blockquote>
cstruct-and-class
Grovel Form
:
cstruct-and-class
c-name
slots
<blockquote>
<p>Defines a CFFI foreign struct, as with <code>cstruct</code> and defines a CLOS class to be used with it. This is useful for mapping foreign structures to application-layer code that shouldn’t need to worry about memory allocation issues.</p>
</blockquote>
cvar
Grovel Form
:
cvar
namespec
type
&amp;key
read-only
<blockquote>
<p>Defines a foreign variable of the specified type, even if that variable is potentially a C preprocessor pseudo-variable. e.g. <code>(cvar ("errno" errno) errno-values)</code>, assuming that errno-values is an enum or equivalent to type <code>:int</code>.</p>
<p>The namespec is similar to the one used in <a href="#defcvar">defcvar</a>.</p>
</blockquote>
cenum
Grovel Form
:
cenum
name-and-opts
&amp;rest
elements
<blockquote>
<p>Defines a true C enum, with elements specified as <code>((lisp-name
&amp;rest c-names) &amp;key optional documentation)</code>. name-and-opts can be either a symbol as name, or a list <code>(name &amp;key base-type define-constants)</code>. If define-constants is non-null, a Lisp constant will be defined for each enum member.</p>
</blockquote>
constantenum
Grovel Form
:
constantenum
name-and-opts
&amp;rest
elements
<blockquote>
<p>Defines an enumeration of pre-processor constants, with elements specified as <code>((lisp-name &amp;rest c-names) &amp;key optional
documentation)</code>. name-and-opts can be either a symbol as name, or a list <code>(name &amp;key base-type define-constants)</code>. If define-constants is non-null, a Lisp constant will be defined for each enum member.</p>
<p>This example defines <code>:af-inet</code> to represent the value held by <code>AF_INET</code> or <code>PF_INET</code>, whichever the pre-processor finds first. Similarly for <code>:af-packet</code>, but no error will be signalled if the platform supports neither <code>AF_PACKET</code> nor <code>PF_PACKET</code>.</p>
</blockquote>
<pre><code>(constantenum address-family
  ((:af-inet &quot;AF_INET&quot; &quot;PF_INET&quot;)
   :documentation &quot;IPv4 Protocol family&quot;)
  ((:af-local &quot;AF_UNIX&quot; &quot;AF_LOCAL&quot; &quot;PF_UNIX&quot; &quot;PF_LOCAL&quot;)
   :documentation &quot;File domain sockets&quot;)
  ((:af-inet6 &quot;AF_INET6&quot; &quot;PF_INET6&quot;)
   :documentation &quot;IPv6 Protocol family&quot;)
  ((:af-packet &quot;AF_PACKET&quot; &quot;PF_PACKET&quot;)
   :documentation &quot;Raw packet access&quot;
   :optional t))</code></pre>
bitfield
Grovel Form
:
bitfield
name-and-opts
&amp;rest
elements
<blockquote>
<p>Defines a bitfield, with elements specified as <code>((lisp-name &amp;rest
c-names) &amp;key optional documentation)</code>. name-and-opts can be either a symbol as name, or a list <code>(name &amp;key base-type)</code>. For example:</p>
</blockquote>
<pre><code>(bitfield flags-ctype
  ((:flag-a &quot;FLAG_A&quot;)
    :documentation &quot;DOCU_A&quot;)
  ((:flag-b &quot;FLAG_B&quot; &quot;FLAG_B_ALT&quot;)
    :documentation &quot;DOCU_B&quot;)
  ((:flag-c &quot;FLAG_C&quot;)
    :documentation &quot;DOCU_C&quot;
    :optional t))</code></pre>
<h2 id="Groveller-ASDF-Integration">ASDF Integration</h2>
<p>An example software project might contain four files; an ASDF file, a package definition file, an implementation file, and a CFFI-Grovel specification file.</p>
<p>The ASDF file defines the system and its dependencies. Notice the use of <code>eval-when</code> to ensure CFFI-Grovel is present and the use of <code>(cffi-grovel:grovel-file name &amp;key cc-flags)</code> instead of <code>(:file name)</code>.</p>
<p>The <code>example-software.asd</code> file would look like that:</p>
<pre><code>;;; CFFI-Grovel is needed for processing grovel-file components
(defsystem &quot;example-software&quot;
  :defsystem-depends-on (&quot;cffi-grovel&quot;)
  :depends-on (&quot;cffi&quot;)
  :serial t
  :components
  ((:file &quot;package&quot;)
   (:cffi-grovel-file &quot;example-grovelling&quot;)
   (:cffi-wrapper-file &quot;example-wrappers&quot;)
   (:file &quot;example&quot;)))</code></pre>
<p>The <code>package.lisp</code> file would contain one or several <code>defpackage</code> forms, to remove circular dependencies and make building the project easier. Note that you may or may not want to <code>:use</code> your internal package.</p>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>Note that it’s a not a good idea to <code>:use</code> when names may clash with, say, CL symbols. Or you could use <code>uiop:define-package</code> and its <code>:mix</code> option.</em></p>
</blockquote>
<pre><code>(defpackage #:example-internal
  (:use)
  (:nicknames #:exampleint))

(defpackage #:example-software
  (:export ...)
  (:use #:cl #:cffi #:exampleint))</code></pre>
<p>The internal package is created by Lisp code output from the C program written by CFFI-Grovel; if your specification file is <code>exampleint.lisp</code>, the <code>exampleint.cffi.lisp</code> file will contain the CFFI definitions needed by the rest of your project. See <a href="#Groveller-Syntax">Groveller Syntax</a>.</p>
<h2 id="Groveller-Implementation-Notes">Implementation Notes</h2>
<p>CFFI-Grovel will generate many files that not only architecture-specific, but also implementation-specific, and should not be distributed. ASDF will generate these files in its output cache; if you build with multiple architectures (e.g. with NFS/AFS home directories) or implementations, it is critical for avoiding clashes to keep this cache in an implementation-dependent directory (as is the default).</p>
<p>For <code>foo-internal.lisp</code>, the resulting <code>foo-internal.c</code>, <code>foo-internal</code>, and <code>foo-internal.cffi.lisp</code> are all platform-specific, either because of possible reader-macros in foo-internal.lisp, or because of varying C environments on the host system. For this reason, it is not helpful to distribute any of those files; end users building CFFI-Grovel based software will need <code>cffi</code>-Grovel anyway.</p>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>For now, after some experimentation with CLISP having no long-long, it seems appropriate to assert that the generated <code>.c</code> files are architecture and operating-system dependent, but lisp-implementation independent. This way the same <code>.c</code> file (and so the same <code>.grovel-tmp.lisp</code> file) will be shareable between the implementations running on a given system.</em></p>
</blockquote>
<h2 id="Wrapper-for-Inline_002fStatic-Functions-and-Macros">Wrapper for Inline/Static Functions and Macros</h2>
<p>In a shared library, information in static/inlined functions and macros are already removed during the compilation. Wrapper file enables to write an uninlined function wrapping the call to them.</p>
<p>A wrapper file compilation/loading proceeds as follows: Unlike groveller which generates C code that emits lisp files containing cffi definitions, it generates C code, compiles it as a shared library, loads the library, generate the cffi definitions (as lisp code) and then loads the lisp code.</p>
<p>It has asdf integration similar to groveller.</p>
<pre><code>(defsystem &quot;example-software&quot;
  :defsystem-depends-on (&quot;cffi-grovel&quot;)
  :depends-on (&quot;cffi&quot;)
  :serial t
  :components
  ((:file &quot;package&quot;)
   (:cffi-grovel-file &quot;example-grovelling&quot;)
   (:cffi-wrapper-file &quot;example-wrappers&quot;)  ;; &lt;&lt;--- this part
   (:file &quot;example&quot;)))</code></pre>
defwrapper
Wrapper Form
:
defwrapper
name-and-options
return-type
&amp;rest
args
<pre><code>static inline int foo(int i) {
  return 1+i;
};
#define bar(i) (1+(i))</code></pre>
<pre><code>(in-package :mypackage)
(defwrapper (&quot;foo&quot; foo) :int
  (i :int))
(defwrapper (&quot;bar&quot; bar) :int
  (i :int))</code></pre>
<p>Other forms are similar to grovel files.</p>
progn
Wrapper Form
:
progn
&amp;rest
forms
<blockquote>
<p>Processes a list of forms. Useful for conditionalizing several forms. For example:</p>
</blockquote>
<pre><code>#+freebsd
(progn
  (constant (ev-enable &quot;EV_ENABLE&quot;))
  (constant (ev-disable &quot;EV_DISABLE&quot;)))</code></pre>
include
Wrapper Form
:
include
&amp;rest
files
<blockquote>
<p>Include the specified files (specified as strings) in the generated C source code.</p>
</blockquote>
in-package
Wrapper Form
:
in-package
symbol
<blockquote>
<p>Set the package to be used for the final Lisp output.</p>
</blockquote>
flags
Wrapper Form
:
flags
&amp;rest
flags
<blockquote>
<p>Adds cc-flags to the command line arguments used for the C compiler invocation.</p>
</blockquote>
proclaim
Wrapper Form
:
proclaim
&amp;rest
proclaimations
declaim
Wrapper Form
:
declaim
&amp;rest
declaimations
<h1 id="Static-Linking">Static Linking</h1>
<p>On recent enough versions of supported implementations (currently, GNU CLISP 2.49 or later, CMUCL 2015-11 or later, and SBCL 1.2.17 or later, except SBCL 2.0.4), and with a recent enough ASDF (3.1.2 or later), you can create a statically linked Lisp executable image (or a standalone application executable) that includes all the C extensions defined via <a href="#The-Groveller">The Groveller</a>’s <code>:cffi-wrapper-file</code> ASDF components (and any other such objects output by <code>asdf:compile-op</code>), as well as those defined by <code>:c-file</code> or <code>:o-file</code> ASDF components, and your Lisp code. This makes it easier to deliver your code as a single file.</p>
<p>Note that the resulting binary will typically still depend on any shared libraries loaded via See <a href="#load_002dforeign_002dlibrary">load-foreign-library</a> or See <a href="#use_002dforeign_002dlibrary">use-foreign-library</a> as well as core libraries such as <code>libc</code>.</p>
<p>To dump a statically linked executable image, use:</p>
<pre><code>(asdf:load-system :cffi-grovel)
(asdf:operate :static-image-op :example-software)</code></pre>
<p>To dump a statically linked executable standalone application, use:</p>
<pre><code>(asdf:load-system :cffi-grovel)
(asdf:operate :static-program-op :example-software)</code></pre>
<p>See <a href="https://common-lisp.net/project/asdf/">the ASDF manual</a> for documentation about <code>image-op</code> and <code>program-op</code> which are the parent operation classes that behave similarly except they don’t statically link C code.</p>
<blockquote>
<p><strong>Implementor’s note:</strong> <em>There is also an operation <code>:static-runtime-op</code> to create the statically linked runtime alone, but it’s admittedly not very useful except as an intermediate step dependency towards building <code>:static-image-op</code> or <code>:static-program-op</code>.</em></p>
</blockquote>
<h1 id="Limitations">Limitations</h1>
<p>These are CFFI’s limitations across all platforms; for information on the warts on particular Lisp implementations, see <a href="#Implementation-Support">Implementation Support</a>.</p>
<ul>
<li><p>The tutorial includes a treatment of the primary, intractable limitation of CFFI, or any FFI: that the abstractions commonly used by C are insufficiently expressive. See <a href="#Tutorial_002dAbstraction">Breaking the abstraction</a>, for more details.</p></li>
</ul>
<h1 id="Platform_002dspecific-features">Platform-specific features</h1>
<p>Whenever a backend doesn’t support one of CFFI’s features, a specific symbol is pushed onto <code>common-lisp:*features*</code>. The meanings of these symbols follow.</p>
<dl>
<dt>cffi-sys::flat-namespace</dt>
<dd><p>This Lisp has a flat namespace for foreign symbols meaning that you won’t be able to load two different libraries with homograph functions and successfully differentiate them through the <code>:library</code> option to <code>defcfun</code>, <code>defcvar</code>, etc…</p>
</dd>
<dt>cffi-sys::no-foreign-funcall</dt>
<dd><p>The macro <code>foreign-funcall</code> is <strong>not</strong> available. On such platforms, the only way to call a foreign function is through <code>defcfun</code>. See <a href="#foreign_002dfuncall">foreign-funcall</a>, and <a href="#defcfun">defcfun</a>.</p>
</dd>
<dt>cffi-sys::no-long-long</dt>
<dd><p>The C <code>long long</code> type is <strong>not</strong> available as a foreign type.</p>
<p>However, on such platforms CFFI provides its own implementation of the <code>long long</code> type for all of operations in chapters <a href="#Foreign-Types">Foreign Types</a>, <a href="#Pointers">Pointers</a> and <a href="#Variables">Variables</a>. The functionality described in <a href="#Functions">Functions</a> and <a href="#Callbacks">Callbacks</a> will not be available.</p>
<p>32-bit Lispworks 5.0+ is an exception. In addition to the CFFI implementation described above, Lispworks itself implements the <code>long long</code> type for <a href="#Functions">Functions</a>. <a href="#Callbacks">Callbacks</a> are still missing <code>long long</code> support, though.</p>
</dd>
<dt>cffi-sys::no-stdcall</dt>
<dd><p>This Lisp doesn’t support the <code>stdcall</code> calling convention. Note that it only makes sense to support <code>stdcall</code> on (32-bit) x86 platforms.</p>
</dd>
</dl>
<h1 id="Glossary">Glossary</h1>
<dl>
<dt>aggregate type</dt>
<dd><p>A CFFI type for C data defined as an organization of data of simple type; in structures and unions, which are themselves aggregate types, they are represented by value.</p>
</dd>
<dt>foreign value</dt>
<dd><p>This has two meanings; in any context, only one makes sense.</p>
<p>When using type translators, the foreign value is the lower-level Lisp value derived from the object passed to <code>translate-to-foreign</code> (see <a href="#translate_002dto_002dforeign">translate-to-foreign</a>). This value should be a Lisp number or a pointer (satisfies <code>pointerp</code>), and it can be treated like any general Lisp object; it only completes the transformation to a true foreign value when passed through low-level code in the Lisp implementation, such as the foreign function caller or indirect memory addressing combined with a data move.</p>
<p>In other contexts, this refers to a value accessible by C, but which may only be accessed through CFFI functions. The closest you can get to such a foreign value is through a pointer Lisp object, which itself counts as a foreign value in only the previous sense.</p>
</dd>
<dt>simple type</dt>
<dd><p>A CFFI type that is ultimately represented as a builtin type; CFFI only provides extra semantics for Lisp that are invisible to C code or data.</p>
</dd>
</dl>
<h1 id="Comprehensive-Index">Index</h1>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Admittedly, this is an advanced issue, and we encourage you to leave this text until you are more familiar with how CFFI works.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>This does not apply to structs whose contents are intended to be part of the public library interface. In those cases, a pure Lisp struct definition is always preferred. In fact, many prefer to stay in Lisp and break the encapsulation anyway, placing the burden of correct library interface definition on the library.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Specifically, UFFI, an older FFI that takes a somewhat different approach compared to CFFI. I believe that these days (December 2005) CFFI is more portable and actively developed, though not as mature yet. Consensus in the free UNIX Common Lisp community seems to be that CFFI is preferred for new development, though UFFI will likely go on for quite some time as many projects already use it. CFFI includes the <code>UFFI-COMPAT</code> package for complete compatibility with UFFI.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>This isn’t entirely true; some Lisps don’t support <code>foreign-funcall</code>, so <code>defcfun</code> is implemented without it. <code>defcfun</code> may also perform optimizations that <code>foreign-funcall</code> cannot.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Another possibility is to allow the caller to specify the desired C type of the third argument. This is essentially what happens in a call to the function written in C.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>See section “Other Kinds of Streams” in GNU C Library Reference, for a GNU-only way to extend the <code>FILE*</code> type. You could use this to convert Lisp streams to the needed C data. This would be quite involved and far outside the scope of this tutorial.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>“<em>But I thought Lisp was supposed to protect me from all that buggy C crap!</em>” Before asking a question like that, remember that you are a stranger in a foreign land, whose residents have a completely different set of values.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>There are advantages and disadvantages to each approach; I chose to <code>(setf
symbol-function)</code> earlier because it entailed generating fewer magic function names.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Unfortunately, we can’t protect against <em>all</em> non-local exits, such as <code>return</code>s and <code>throw</code>s, because <code>unwind-protect</code> cannot be used to “short-circuit” a non-local exit in Common Lisp, due to proposal <code>minimal</code> in <a href="http://www.lisp.org/HyperSpec/Issues/iss152-writeup.html">ANSI issue EXIT-EXTENT</a>. Furthermore, binding an <code>error</code> handler prevents higher-up code from invoking restarts that may be provided under the callback’s dynamic context. Such is the way of compromise.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>It might be better to return <code>(values)</code> than <code>:curle-ok</code> in real code, but this is good for illustration.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>The definition of memory includes the CPU registers.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>Windows programmers may chafe at adding a UNIX-specific clause to <code>define-foreign-library</code>. Instead, ask why the Windows solution to library incompatibility is “include your own version of every library you use with every program”.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>See section “Using asdf to load systems” in asdf: another system definition facility, for information on <code>asdf:*central-registry*</code>.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>See <code>mini-eval</code> in <code>libraries.lisp</code> for the source of this definition. As is always the case with a Lisp <code>eval</code>, it’s easier to understand the Lisp definition than the english.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>Namely, CMUCL. See <code>use-foreign-library</code> in <code>libraries.lisp</code> for details.<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div></div></div></div><h2 id="doc/cffi-sys-spec.texinfo"><span class="file">cffi-sys-spec</span><span class="extension">texinfo</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/cffi-sys-spec.texinfo">[source]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><p>Copyright © 2005-2006, James Bielman &lt;jamesjb at jamesjb.com&gt;</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<h1 id="Top">cffi-sys</h1>
<p>Copyright © 2005-2006, James Bielman &lt;jamesjb at jamesjb.com&gt;</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
</blockquote>
<h1 id="Introduction">Introduction</h1>
<p>CFFI, the Common Foreign Function Interface, purports to be a portable foreign function interface for Common Lisp.</p>
<p>This specification defines a set of low-level primitives that must be defined for each Lisp implementation supported by CFFI. These operators are defined in the <code>CFFI-SYS</code> package.</p>
<p>The <code>CFFI</code> package uses the <code>CFFI-SYS</code> interface to implement an extensible foreign type system with support for typedefs, structures, and unions, a declarative interface for defining foreign function calls, and automatic conversion of foreign function arguments to/from Lisp types.</p>
<p>Please note the following conventions that apply to everything in <code>CFFI-SYS</code>:</p>
<ul>
<li><p>Functions in <code>CFFI-SYS</code> that are low-level versions of functions exported from the <code>CFFI</code> package begin with a leading percent-sign (eg. <code>%mem-ref</code>).</p></li>
<li><p>Where “foreign type” is mentioned as the kind of an argument, the meaning is restricted to that subset of all foreign types defined in <a href="#Built_002dIn-Foreign-Types">Built-In Foreign Types</a>. Support for higher-level types is always defined in terms of those lower-level types in <code>CFFI</code> proper.</p></li>
</ul>
<h1 id="Built_002dIn-Foreign-Types">Built-In Foreign Types</h1>
:char
Foreign Type
:
:char
:unsigned-char
Foreign Type
:
:unsigned-char
:short
Foreign Type
:
:short
:unsigned-short
Foreign Type
:
:unsigned-short
:int
Foreign Type
:
:int
:unsigned-int
Foreign Type
:
:unsigned-int
:long
Foreign Type
:
:long
:unsigned-long
Foreign Type
:
:unsigned-long
:long-long
Foreign Type
:
:long-long
:unsigned-long-long
Foreign Type
:
:unsigned-long-long
<blockquote>
<p>These types correspond to the native C integer types according to the ABI of the system the Lisp implementation is compiled against.</p>
</blockquote>
:int8
Foreign Type
:
:int8
:uint8
Foreign Type
:
:uint8
:int16
Foreign Type
:
:int16
:uint16
Foreign Type
:
:uint16
:int32
Foreign Type
:
:int32
:uint32
Foreign Type
:
:uint32
:int64
Foreign Type
:
:int64
:uint64
Foreign Type
:
:uint64
<blockquote>
<p>Foreign integer types of specific sizes, corresponding to the C types defined in <code>stdint.h</code>.</p>
</blockquote>
:size
Foreign Type
:
:size
:ssize
Foreign Type
:
:ssize
:ptrdiff
Foreign Type
:
:ptrdiff
:time
Foreign Type
:
:time
<blockquote>
<p>Foreign integer types corresponding to the standard C types (without the <code>_t</code> suffix).</p>
</blockquote>
<p><em>Implementor’s note: I’m sure there are more of these that could be useful, let’s add any types that can’t be defined portably to this list as necessary.</em></p>
:float
Foreign Type
:
:float
:double
Foreign Type
:
:double
<blockquote>
<p>The <code>:float</code> type represents a C <code>float</code> and a Lisp <code>single-float</code>. <code>:double</code> represents a C <code>double</code> and a Lisp <code>double-float</code>.</p>
</blockquote>
:pointer
Foreign Type
:
:pointer
<blockquote>
<p>A foreign pointer to an object of any type, corresponding to <code>void *</code>.</p>
</blockquote>
:void
Foreign Type
:
:void
<blockquote>
<p>No type at all. Only valid as the return type of a function.</p>
</blockquote>
<h1 id="Operations-on-Foreign-Types">Operations on Built-in Foreign Types</h1>
%foreign-type-size
Function
:
%foreign-type-size
type
⇒
size
<blockquote>
<p>Return the size, in bytes, of objects having foreign type type. An error is signalled if type is not a known built-in foreign type.</p>
</blockquote>
%foreign-type-alignment
Function
:
%foreign-type-alignment
type
⇒
alignment
<blockquote>
<p>Return the default alignment in bytes for structure members of foreign type type. An error is signalled if type is not a known built-in foreign type.</p>
<p><em>Implementor’s note: Maybe this should take an optional keyword argument specifying an alternate alignment system, eg. :mac68k for 68000-compatible alignment on Darwin.</em></p>
</blockquote>
<h1 id="Basic-Pointer-Operations">Basic Pointer Operations</h1>
pointerp
Function
:
pointerp
ptr
⇒
boolean
<blockquote>
<p>Return true if ptr is a foreign pointer.</p>
</blockquote>
null-pointer
Function
:
null-pointer
⇒
pointer
<blockquote>
<p>Return a null foreign pointer.</p>
</blockquote>
null-pointer-p
Function
:
null-pointer-p
ptr
⇒
boolean
<blockquote>
<p>Return true if ptr is a null foreign pointer.</p>
</blockquote>
make-pointer
Function
:
make-pointer
address
⇒
pointer
<blockquote>
<p>Return a pointer corresponding to the numeric integer address.</p>
</blockquote>
inc-pointer
Function
:
inc-pointer
ptr
offset
⇒
pointer
<blockquote>
<p>Return the result of numerically incrementing ptr by offset.</p>
</blockquote>
<h1 id="Foreign-Memory-Allocation">Foreign Memory Allocation</h1>
foreign-alloc
Function
:
foreign-alloc
size
⇒
pointer
<blockquote>
<p>Allocate size bytes of foreign-addressable memory and return a pointer to the allocated block. An implementation-specific error is signalled if the memory cannot be allocated.</p>
</blockquote>
foreign-free
Function
:
foreign-free
ptr
⇒
unspecified
<blockquote>
<p>Free a pointer ptr allocated by <code>foreign-alloc</code>. The results are undefined if ptr is used after being freed.</p>
</blockquote>
with-foreign-pointer
Macro
:
with-foreign-pointer
(
var
size
&amp;optional
size-var
)
&amp;body
body
<blockquote>
<p>Bind var to a pointer to size bytes of foreign-accessible memory during body. Both ptr and the memory block it points to have dynamic extent and may be stack allocated if supported by the implementation. If size-var is supplied, it will be bound to size during body.</p>
</blockquote>
<h1 id="Memory-Access">Memory Access</h1>
%mem-ref
Accessor
:
%mem-ref
ptr
type
&amp;optional
offset
<blockquote>
<p>Dereference a pointer offset bytes from ptr to an object for reading (or writing when used with <code>setf</code>) of built-in type type.</p>
</blockquote>
<p><strong>Example</strong></p>
<pre><code>;; An impractical example, since time returns the time as well,
;; but it demonstrates %MEM-REF. Better (simple) examples wanted!
(with-foreign-pointer (p (foreign-type-size :time))
  (foreign-funcall &quot;time&quot; :pointer p :time)
  (%mem-ref p :time))</code></pre>
<h1 id="Foreign-Function-Calling">Foreign Function Calling</h1>
%foreign-funcall
Macro
:
%foreign-funcall
name
{
arg-type
arg
}
*
&amp;optional
result-type
⇒
object
%foreign-funcall-pointer
Macro
:
%foreign-funcall-pointer
ptr
{
arg-type
arg
}
*
&amp;optional
result-type
⇒
object
<blockquote>
<p>Invoke a foreign function called name in the foreign source code.</p>
<p>Each arg-type is a foreign type specifier, followed by arg, Lisp data to be converted to foreign data of type arg-type. result-type is the foreign type of the function’s return value, and is assumed to be <code>:void</code> if not supplied.</p>
<p><code>%foreign-funcall-pointer</code> takes a pointer ptr to the function, as returned by <code>foreign-symbol-pointer</code>, rather than a string name.</p>
</blockquote>
%foreign-funcall-varargs
Macro
:
%foreign-funcall-varargs
name
(
{
fixed-type
arg
}
*
)
{
vararg-type
arg
}
*
&amp;optional
result-type
⇒
object
%foreign-funcall-varargs-pointer
Macro
:
%foreign-funcall-varargs-pointer
ptr
(
{
fixed-type
arg
}
*
)
{
vararg-type
arg
}
*
&amp;optional
result-type
⇒
object
<blockquote>
<p>Invoke a foreign variadic function called name in the foreign source code.</p>
<p>Each fixed-type and vararg-type is a foreign type specifier, followed by arg, Lisp data to be converted to foreign data of type arg-type. result-type is the foreign type of the function’s return value, and is assumed to be <code>:void</code> if not supplied.</p>
<p><code>%foreign-funcall-pointer-varargs</code> takes a pointer ptr to the variadic function, as returned by <code>foreign-symbol-pointer</code>, rather than a string name.</p>
<p>Both functions have default implementation which call <code>%foreign-funcall</code> and <code>%foreign-funcall-pointer</code> approprietly.</p>
</blockquote>
<p><strong>Examples</strong></p>
<pre><code>;; Calling a standard C library function:
(%foreign-funcall &quot;sqrtf&quot; :float 16.0 :float) ⇒ 4.0</code></pre>
<pre><code>;; Dynamic allocation of a buffer and passing to a function:
(with-foreign-ptr (buf 255 buf-size)
  (%foreign-funcall &quot;gethostname&quot; :pointer buf :size buf-size :int)
  ;; Convert buf to a Lisp string using MAKE-STRING and %MEM-REF or
  ;; a portable CFFI function such as CFFI:FOREIGN-STRING-TO-LISP.
  )</code></pre>
<h1 id="Loading-Foreign-Libraries">Loading Foreign Libraries</h1>
%load-foreign-library
Function
:
%load-foreign-library
name
⇒
unspecified
<blockquote>
<p>Load the foreign shared library name.</p>
<p><em>Implementor’s note: There is a lot of behavior to decide here. Currently I lean toward not requiring NAME to be a full path to the library so we can search the system library directories (maybe even get LD_LIBRARY_PATH from the environment) as necessary.</em></p>
</blockquote>
<h1 id="Foreign-Globals">Foreign Globals</h1>
foreign-symbol-pointer
Function
:
foreign-symbol-pointer
name
⇒
pointer
<blockquote>
<p>Return a pointer to a foreign symbol name.</p>
</blockquote>
<h1 id="Symbol-Index">Symbol Index</h1>
</div></div></div></div><h2 id="doc/mem-vector.txt"><span class="file">mem-vector</span><span class="extension">txt</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/mem-vector.txt">[source]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><h1 id="block-memory-operations">Block Memory Operations</h1>
<p>Function: mem-fill ptr type count value &amp;optional (offset 0)</p>
<p>Fill COUNT objects of TYPE, starting at PTR plus offset, with VALUE.</p>
<p>;; Equivalent to (but possibly more efficient than): (loop for i below count for off from offset by (%foreign-type-size type) do (setf (%mem-ref ptr type off) value))</p>
<p>Function: mem-read-vector vector ptr type count &amp;optional (offset 0)</p>
<p>Copy COUNT objects of TYPE from foreign memory at PTR plus OFFSET into VECTOR. If VECTOR is not large enough to contain COUNT objects, it will copy as many objects as necessary to fill the vector. The results are undefined if the foreign memory block is not large enough to supply the data to copy.</p>
<p>TYPE must be a built-in foreign type (integer, float, double, or pointer).</p>
<p>Returns the number of objects copied.</p>
<p>;; Equivalent to (but possibly more efficient than): (loop for i below (min count (length vector)) for off from offset by (%foreign-type-size type) do (setf (aref vector i) (%mem-ref ptr type off)) finally (return i))</p>
<p>Function: mem-read-c-string string ptr &amp;optional (offset 0)</p>
<p>Copy a null-terminated C string from PTR plus OFFSET into STRING, a Lisp string. If STRING is not large enough to contain the data at PTR it will be truncated.</p>
<p>Returns the number of characters copied into STRING.</p>
<p>;; Equivalent to (but possibly more efficient than): (loop for i below (length string) for off from offset for char = (%mem-ref ptr :char off) until (zerop char) do (setf (char string i) char) finally (return i))</p>
<p>Function: mem-write-vector vector ptr type &amp;optional (count (length vector)) (offset 0)</p>
<p>Copy COUNT objects from VECTOR into objects of TYPE in foreign memory, starting at PTR plus OFFSET. The results are undefined if PTR does not point to a memory block large enough to hold the data copied.</p>
<p>TYPE must be a built-in type (integer, float, double, or pointer).</p>
<p>Returns the number of objects copied from VECTOR to PTR.</p>
<p>;; Equivalent to (but possibly more efficient than): (loop for i below count for off from offset by (%foreign-type-size type) do (setf (%mem-ref ptr type off) (aref vector i)) finally (return i))</p>
<p>Function: mem-write-c-string string ptr &amp;optional (offset 0)</p>
<p>Copy the characters from a Lisp STRING to PTR plus OFFSET, adding a final null terminator at the end. The results are undefined if the memory at PTR is not large enough to accomodate the data.</p>
<p>This interface is currently equivalent to MEM-WRITE-VECTOR with a TYPE of :CHAR, but will be useful when proper support for Unicode strings is implemented.</p>
</div></div></div></div><h2 id="doc/shareable-vectors.txt"><span class="file">shareable-vectors</span><span class="extension">txt</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/doc/shareable-vectors.txt">[source]</a></h2><div class="doc-entry"><div class="entry"><div class="static-file"><div class="docstring"><h1 id="shareable-byte-vectors">Shareable Byte Vectors</h1>
<p>Function: make-shareable-byte-vector size</p>
<p>Create a vector of element type (UNSIGNED-BYTE 8) suitable for passing to WITH-POINTER-TO-VECTOR-DATA.</p>
<p>;; Minimal implementation: (defun make-shareable-byte-vector (size) (make-array size :element-type ’(unsigned-byte 8)))</p>
<p>Macro: with-pointer-to-vector-data (ptr-var vector) &amp;body body</p>
<p>Bind PTR-VAR to a pointer to the data contained in a shareable byte vector.</p>
<p>VECTOR must be a shareable vector created by MAKE-SHAREABLE-BYTE-VECTOR.</p>
<p>PTR-VAR may point directly into the Lisp vector data, or it may point to a temporary block of foreign memory which will be copied to and from VECTOR.</p>
<p>Both the pointer object in PTR-VAR and the memory it points to have dynamic extent. The results are undefined if foreign code attempts to access this memory outside this dynamic contour.</p>
<p>The implementation must guarantee the memory pointed to by PTR-VAR will not be moved during the dynamic contour of this operator, either by creating the vector in a static area or temporarily disabling the garbage collector.</p>
<p>;; Minimal (copying) implementation: (defmacro with-pointer-to-vector-data ((ptr-var vector) &amp;body body) (let ((vector-var (gensym)) (size-var (gensym))) `(let* ((,vector-var ,vector) (,size-var (length ,vector-var))) (with-foreign-ptr (,ptr-var ,size-var) (mem-write-vector ,vector-var ,ptr :uint8) (prog1 (progn ,<span class="citation" data-cites="body">@body</span>) (mem-read-vector ,vector-var ,ptr-var :uint8 ,size-var))))))</p>
</div></div></div></div><h1 id=""><span class="directory"></span></h1><h2 id="cffi.asd"><span class="file">cffi</span><span class="extension">asd</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/cffi.asd">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defsystem-cffi"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">defsystem</span></div><div class="span"><span class="name" id="KEYWORD:CFFI">cffi</span></div></div></h3><div class="docstring"><p>The Common Foreign Function Interface</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-version-satisfies-(c-(eql-(find-system-cffi)))-version"><div class="pkg-ASDF/COMPONENT EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="ASDF/COMPONENT:VERSION-SATISFIES">version-satisfies</span></div><span class="args lisp">(c (eql (find-system cffi))) version</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defsystem-cffi-c2ffi"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">defsystem</span></div><div class="span"><span class="name" id="KEYWORD:CFFI/C2FFI">cffi/c2ffi</span></div></div></h3><div class="docstring"><p>CFFI definition generator from the FFI spec generated by c2ffi. This system can be used through ASDF's :DEFSYSTEM-DEPENDS-ON.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defsystem-cffi-c2ffi-generator"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">defsystem</span></div><div class="span"><span class="name" id="KEYWORD:CFFI/C2FFI-GENERATOR">cffi/c2ffi-generator</span></div></div></h3><div class="docstring"><p>This system gets loaded lazily when the CFFI bindings need to be regenerated. This only happens if the developer chose not to include the generated binding files, or the spec file generated by c2ffi has been modified.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-perform-(o-test-op)-(c-(eql-#<system-\"cffi\">))"><div class="pkg-ASDF/ACTION EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="ASDF/ACTION:PERFORM">perform</span></div><span class="args lisp">(o test-op) (c (eql #&lt;system &quot;cffi&quot;&gt;))</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><h1 id="src"><span class="directory">src</span></h1><h2 id="src/cffi-sbcl.lisp"><span class="file">cffi-sbcl</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/cffi-sbcl.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun-canonicalize-symbol-name-case-name"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:CANONICALIZE-SYMBOL-NAME-CASE">canonicalize-symbol-name-case</span></div><span class="args lisp">name</span></div></h3></div><div class="entry"><h3 id="deftype-foreign-pointer-"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">deftype</span></div><div class="span"><span class="name" id="CFFI-SYS:FOREIGN-POINTER">foreign-pointer</span></div><span class="args lisp"></span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-pointerp-ptr"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:POINTERP">pointerp</span></div><span class="args lisp">ptr</span></div></h3><div class="docstring"><p>Return true if PTR is a foreign pointer.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-pointer-eq-ptr1-ptr2"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:POINTER-EQ">pointer-eq</span></div><span class="args lisp">ptr1 ptr2</span></div></h3><div class="docstring"><p>Return true if PTR1 and PTR2 point to the same address.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-null-pointer-"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:NULL-POINTER">null-pointer</span></div><span class="args lisp"></span></div></h3><div class="docstring"><p>Construct and return a null pointer.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-null-pointer-p-ptr"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:NULL-POINTER-P">null-pointer-p</span></div><span class="args lisp">ptr</span></div></h3><div class="docstring"><p>Return true if PTR is a null pointer.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-inc-pointer-ptr-offset"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:INC-POINTER">inc-pointer</span></div><span class="args lisp">ptr offset</span></div></h3><div class="docstring"><p>Return a pointer pointing OFFSET bytes past PTR.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-make-pointer-address"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:MAKE-POINTER">make-pointer</span></div><span class="args lisp">address</span></div></h3><div class="docstring"><p>Return a pointer pointing to ADDRESS.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-pointer-address-ptr"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:POINTER-ADDRESS">pointer-address</span></div><span class="args lisp">ptr</span></div></h3><div class="docstring"><p>Return the address pointed to by PTR.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-%foreign-alloc-size"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%FOREIGN-ALLOC">%foreign-alloc</span></div><span class="args lisp">size</span></div></h3><div class="docstring"><p>Allocate SIZE bytes on the heap and return a pointer.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-free-ptr"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:FOREIGN-FREE">foreign-free</span></div><span class="args lisp">ptr</span></div></h3><div class="docstring"><p>Free a PTR allocated by FOREIGN-ALLOC.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-pointer-(var-size-&optional-size-var)-&body-body"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI-SYS:WITH-FOREIGN-POINTER">with-foreign-pointer</span></div><span class="args lisp">(var size &amp;optional size-var) &amp;body body</span></div></h3><div class="docstring"><p>Bind VAR to SIZE bytes of foreign memory during BODY. The pointer in VAR is invalid beyond the dynamic extent of BODY, and may be stack-allocated if supported by the implementation. If SIZE-VAR is supplied, it will be bound to SIZE during BODY.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-make-shareable-byte-vector-size"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:MAKE-SHAREABLE-BYTE-VECTOR">make-shareable-byte-vector</span></div><span class="args lisp">size</span></div></h3><div class="docstring"><p>Create a Lisp vector of SIZE bytes that can be passed to WITH-POINTER-TO-VECTOR-DATA.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-pointer-to-vector-data-(ptr-var-vector)-&body-body"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI-SYS:WITH-POINTER-TO-VECTOR-DATA">with-pointer-to-vector-data</span></div><span class="args lisp">(ptr-var vector) &amp;body body</span></div></h3><div class="docstring"><p>Bind PTR-VAR to a foreign pointer to the data in VECTOR.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-mem-accessors-char"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-mem-accessors</span></div><div class="span"><span class="name" id="KEYWORD:CHAR">char</span></div></div></h3></div><div class="entry"><h3 id="defun-%mem-ref-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%MEM-REF">%mem-ref</span></div><span class="args lisp">ptr type &amp;optional (offset 0)</span></div></h3></div><div class="entry"><h3 id="defun-%mem-set-value-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%MEM-SET">%mem-set</span></div><span class="args lisp">value ptr type &amp;optional (offset 0)</span></div></h3></div><div class="entry"><h3 id="define-compiler-macro-%mem-ref-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI-SYS:%MEM-REF">%mem-ref</span></div><span class="args lisp">ptr type &amp;optional (offset 0)</span></div></h3></div><div class="entry"><h3 id="define-compiler-macro-%mem-set-value-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI-SYS:%MEM-SET">%mem-set</span></div><span class="args lisp">value ptr type &amp;optional (offset 0)</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-%foreign-type-size-type-keyword"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%FOREIGN-TYPE-SIZE">%foreign-type-size</span></div><span class="args lisp">type-keyword</span></div></h3><div class="docstring"><p>Return the size in bytes of a foreign type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-%foreign-type-alignment-type-keyword"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%FOREIGN-TYPE-ALIGNMENT">%foreign-type-alignment</span></div><span class="args lisp">type-keyword</span></div></h3><div class="docstring"><p>Return the alignment in bytes of a foreign type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-%foreign-funcall-name-args-&key-library-convention"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI-SYS:%FOREIGN-FUNCALL">%foreign-funcall</span></div><span class="args lisp">name args &amp;key library convention</span></div></h3><div class="docstring"><p>Perform a foreign function call, document it more later.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-%foreign-funcall-pointer-ptr-args-&key-convention"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI-SYS:%FOREIGN-FUNCALL-POINTER">%foreign-funcall-pointer</span></div><span class="args lisp">ptr args &amp;key convention</span></div></h3><div class="docstring"><p>Funcall a pointer to a foreign function.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-%defcallback-name-rettype-arg-names-arg-types-body-&key-convention"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI-SYS:%DEFCALLBACK">%defcallback</span></div><span class="args lisp">name rettype arg-names arg-types body &amp;key convention</span></div></h3></div><div class="entry"><h3 id="defun-%callback-name"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%CALLBACK">%callback</span></div><span class="args lisp">name</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-%load-foreign-library-name-path"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%LOAD-FOREIGN-LIBRARY">%load-foreign-library</span></div><span class="args lisp">name path</span></div></h3><div class="docstring"><p>Load a foreign library.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-%close-foreign-library-handle"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%CLOSE-FOREIGN-LIBRARY">%close-foreign-library</span></div><span class="args lisp">handle</span></div></h3><div class="docstring"><p>Closes a foreign library.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-native-namestring-pathname"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:NATIVE-NAMESTRING">native-namestring</span></div><span class="args lisp">pathname</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-%foreign-symbol-pointer-name-library"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-SYS:%FOREIGN-SYMBOL-POINTER">%foreign-symbol-pointer</span></div><span class="args lisp">name library</span></div></h3><div class="docstring"><p>Returns a pointer to a foreign symbol NAME.</p>
</div></div></div><h2 id="src/libraries.lisp"><span class="file">libraries</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/libraries.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defvar-*foreign-library-directories*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defvar</span></div><div class="span"><span class="name" id="CFFI:*FOREIGN-LIBRARY-DIRECTORIES*">*foreign-library-directories*</span></div></div></h3><div class="docstring"><p>List onto which user-defined library paths can be pushed.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defvar-*darwin-framework-directories*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defvar</span></div><div class="span"><span class="name" id="CFFI:*DARWIN-FRAMEWORK-DIRECTORIES*">*darwin-framework-directories*</span></div></div></h3><div class="docstring"><p>List of directories where Frameworks are searched for.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defclass-foreign-library"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defclass</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-LIBRARY">foreign-library</span></div></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-print-object-(library-foreign-library)-stream"><div class="pkg-COMMON-LISP EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="COMMON-LISP:PRINT-OBJECT">print-object</span></div><span class="args lisp">(library foreign-library) stream</span></div></h3><div class="docstring"><p>Print a FOREIGN-TYPEDEF instance to STREAM unreadably.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-library-type-foreign-library-pathname-foreign-library-loaded-p-cffi-lib"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name EXTERNAL" id="CFFI:FOREIGN-LIBRARY-TYPE">foreign-library-type</span><span class="name EXTERNAL" id="CFFI:FOREIGN-LIBRARY-PATHNAME">foreign-library-pathname</span><span class="name EXTERNAL" id="CFFI:FOREIGN-LIBRARY-LOADED-P">foreign-library-loaded-p</span></div><span class="package">cffi</span><span class="args lisp">lib</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-list-foreign-libraries-&key-(loaded-only-t)-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:LIST-FOREIGN-LIBRARIES">list-foreign-libraries</span></div><span class="args lisp">&amp;key (loaded-only t) type</span></div></h3><div class="docstring"><p>Return a list of defined foreign libraries. If LOADED-ONLY is non-null only loaded libraries are returned. TYPE restricts the output to a specific library type: if NIL all libraries are returned.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-initialize-instance"><div class="pkg-COMMON-LISP EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="COMMON-LISP:INITIALIZE-INSTANCE">initialize-instance</span></div></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-define-foreign-library-name-and-options-&body-pairs"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFINE-FOREIGN-LIBRARY">define-foreign-library</span></div><span class="args lisp">name-and-options &amp;body pairs</span></div></h3><div class="docstring"><p>Defines a foreign library NAME that can be posteriorly used with the USE-FOREIGN-LIBRARY macro.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-condition-load-foreign-library-error"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-condition</span></div><div class="span"><span class="name" id="CFFI:LOAD-FOREIGN-LIBRARY-ERROR">load-foreign-library-error</span></div></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-load-foreign-library-library-&key-search-path"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:LOAD-FOREIGN-LIBRARY">load-foreign-library</span></div><span class="args lisp">library &amp;key search-path</span></div></h3><div class="docstring"><p>Loads a foreign LIBRARY which can be a symbol denoting a library defined through DEFINE-FOREIGN-LIBRARY; a pathname or string in which case we try to load it directly first then search for it in <em>FOREIGN-LIBRARY-DIRECTORIES</em>; or finally list: either (:or lib1 lib2) or (:framework <framework-name>). The option :CANARY can specify a symbol that will be searched to detect if the library is already loaded, in which case DEFINE-FOREIGN-LIBRARY will mark the library as loaded and return.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-use-foreign-library-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:USE-FOREIGN-LIBRARY">use-foreign-library</span></div><span class="args lisp">name</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-close-foreign-library-library"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:CLOSE-FOREIGN-LIBRARY">close-foreign-library</span></div><span class="args lisp">library</span></div></h3><div class="docstring"><p>Closes a foreign library.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-reload-foreign-libraries-&key-(test-#'foreign-library-loaded-p)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:RELOAD-FOREIGN-LIBRARIES">reload-foreign-libraries</span></div><span class="args lisp">&amp;key (test #'foreign-library-loaded-p)</span></div></h3><div class="docstring"><p>(Re)load all currently loaded foreign libraries.</p>
</div></div></div><h2 id="src/early-types.lisp"><span class="file">early-types</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/early-types.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defmacro-define-parse-method-name-lambda-list-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFINE-PARSE-METHOD">define-parse-method</span></div><span class="args lisp">name lambda-list &amp;body body</span></div></h3><div class="docstring"><p>Define a type parser on NAME and lists whose CAR is NAME.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-foreign-type-alignment-foreign-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-TYPE-ALIGNMENT">foreign-type-alignment</span></div><span class="args lisp">foreign-type</span></div></h3><div class="docstring"><p>Return the structure alignment in bytes of a foreign type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-foreign-type-size-foreign-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-TYPE-SIZE">foreign-type-size</span></div><span class="args lisp">foreign-type</span></div></h3><div class="docstring"><p>Return the size in bytes of a foreign type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-make-load-form-(type-foreign-type)-&optional-env"><div class="pkg-COMMON-LISP EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="COMMON-LISP:MAKE-LOAD-FORM">make-load-form</span></div><span class="args lisp">(type foreign-type) &amp;optional env</span></div></h3><div class="docstring"><p>Return the form used to dump types to a FASL file.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-foreign-type-size-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-TYPE-SIZE">foreign-type-size</span></div><span class="args lisp">type</span></div></h3><div class="docstring"><p>Return the size in bytes of a foreign type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-foreign-type-alignment-(type-foreign-built-in-type)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-TYPE-ALIGNMENT">foreign-type-alignment</span></div><span class="args lisp">(type foreign-built-in-type)</span></div></h3><div class="docstring"><p>Return the alignment of a built-in type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defvar-*built-in-foreign-types*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defvar</span></div><div class="span"><span class="name" id="CFFI:*BUILT-IN-FOREIGN-TYPES*">*built-in-foreign-types*</span></div></div></h3></div><div class="entry"><h3 id="define-parse-method-pointer-&optional-type"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name" id="KEYWORD:POINTER">pointer</span></div><span class="args lisp">&amp;optional type</span></div></h3></div><div class="entry"><h3 id="defgeneric-defmethod-translate-to-foreign-cffi-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-TO-FOREIGN">translate-to-foreign</span></div><span class="package">cffi</span><span class="args lisp">value type</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-translate-into-foreign-memory-value-type-pointer"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-INTO-FOREIGN-MEMORY">translate-into-foreign-memory</span></div><span class="args lisp">value type pointer</span></div></h3><div class="docstring"><p>Translate the Lisp value into the foreign memory location given by pointer. Return value is not used.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-defmethod-translate-from-foreign-cffi-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-FROM-FOREIGN">translate-from-foreign</span></div><span class="package">cffi</span><span class="args lisp">value type</span></div></h3></div><div class="entry"><h3 id="defgeneric-defmethod-free-translated-object-cffi-value-type-param"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:FREE-TRANSLATED-OBJECT">free-translated-object</span></div><span class="package">cffi</span><span class="args lisp">value type param</span></div></h3></div><div class="entry"><h3 id="defgeneric-expand-from-foreign-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:EXPAND-FROM-FOREIGN">expand-from-foreign</span></div><span class="args lisp">value type</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-expand-from-foreign-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:EXPAND-FROM-FOREIGN">expand-from-foreign</span></div><span class="args lisp">value type</span></div></h3><div class="docstring"><p>Optimization for the :boolean type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-expand-to-foreign-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:EXPAND-TO-FOREIGN">expand-to-foreign</span></div><span class="args lisp">value type</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmethod-expand-to-foreign-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:EXPAND-TO-FOREIGN">expand-to-foreign</span></div><span class="args lisp">value type</span></div></h3><div class="docstring"><p>Optimization for the :boolean type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-defmethod-expand-into-foreign-memory-cffi-value-type-ptr"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:EXPAND-INTO-FOREIGN-MEMORY">expand-into-foreign-memory</span></div><span class="package">cffi</span><span class="args lisp">value type ptr</span></div></h3></div><div class="entry"><h3 id="defgeneric-defmethod-expand-to-foreign-dyn-cffi-value-var-body-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:EXPAND-TO-FOREIGN-DYN">expand-to-foreign-dyn</span></div><span class="package">cffi</span><span class="args lisp">value var body type</span></div></h3></div><div class="entry"><h3 id="defun-define-compiler-macro-convert-to-foreign-cffi-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:CONVERT-TO-FOREIGN">convert-to-foreign</span></div><span class="package">cffi</span><span class="args lisp">value type</span></div></h3></div><div class="entry"><h3 id="defun-define-compiler-macro-convert-from-foreign-cffi-value-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:CONVERT-FROM-FOREIGN">convert-from-foreign</span></div><span class="package">cffi</span><span class="args lisp">value type</span></div></h3></div><div class="entry"><h3 id="defun-define-compiler-macro-convert-into-foreign-memory-cffi-value-type-ptr"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:CONVERT-INTO-FOREIGN-MEMORY">convert-into-foreign-memory</span></div><span class="package">cffi</span><span class="args lisp">value type ptr</span></div></h3></div><div class="entry"><h3 id="defun-free-converted-object-value-type-param"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FREE-CONVERTED-OBJECT">free-converted-object</span></div><span class="args lisp">value type param</span></div></h3></div><div class="entry"><h3 id="defmethod-translate-into-foreign-memory-value-(type-enhanced-typedef)-pointer"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-INTO-FOREIGN-MEMORY">translate-into-foreign-memory</span></div><span class="args lisp">value (type enhanced-typedef) pointer</span></div></h3></div><div class="entry"><h3 id="defmacro-define-foreign-type-name-supers-slots-&rest-options"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFINE-FOREIGN-TYPE">define-foreign-type</span></div><span class="args lisp">name supers slots &amp;rest options</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defctype-name-base-type-&optional-documentation"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCTYPE">defctype</span></div><span class="args lisp">name base-type &amp;optional documentation</span></div></h3><div class="docstring"><p>Utility macro for simple C-like typedefs.</p>
</div></div></div><h2 id="src/types.lisp"><span class="file">types</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/types.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="define-built-in-foreign-type-char-unsigned-char-short-unsigned-short-int-unsigned-int-long-unsigned-long-float-double-void-long-long-unsigned-long-long-keyword"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-built-in-foreign-type</span></div><div class="span"><span class="name EXTERNAL" id="KEYWORD:CHAR">char</span><span class="name EXTERNAL" id="KEYWORD:UNSIGNED-CHAR">unsigned-char</span><span class="name EXTERNAL" id="KEYWORD:SHORT">short</span><span class="name EXTERNAL" id="KEYWORD:UNSIGNED-SHORT">unsigned-short</span><span class="name EXTERNAL" id="KEYWORD:INT">int</span><span class="name EXTERNAL" id="KEYWORD:UNSIGNED-INT">unsigned-int</span><span class="name EXTERNAL" id="KEYWORD:LONG">long</span><span class="name EXTERNAL" id="KEYWORD:UNSIGNED-LONG">unsigned-long</span><span class="name EXTERNAL" id="KEYWORD:FLOAT">float</span><span class="name EXTERNAL" id="KEYWORD:DOUBLE">double</span><span class="name EXTERNAL" id="KEYWORD:VOID">void</span><span class="name EXTERNAL" id="KEYWORD:LONG-LONG">long-long</span><span class="name EXTERNAL" id="KEYWORD:UNSIGNED-LONG-LONG">unsigned-long-long</span></div><span class="package">keyword</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defparameter-*other-builtin-types*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defparameter</span></div><div class="span"><span class="name" id="CFFI:*OTHER-BUILTIN-TYPES*">*other-builtin-types*</span></div></div></h3><div class="docstring"><p>List of types other than integer or float built in to CFFI.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defparameter-*built-in-integer-types*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defparameter</span></div><div class="span"><span class="name" id="CFFI:*BUILT-IN-INTEGER-TYPES*">*built-in-integer-types*</span></div></div></h3><div class="docstring"><p>List of integer types supported by CFFI.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defparameter-*built-in-float-types*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defparameter</span></div><div class="span"><span class="name" id="CFFI:*BUILT-IN-FLOAT-TYPES*">*built-in-float-types*</span></div></div></h3><div class="docstring"><p>List of real float types supported by CFFI.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-inc-pointer-pointer-offset"><div class="pkg-CFFI-SYS EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI-SYS:INC-POINTER">inc-pointer</span></div><span class="args lisp">pointer offset</span></div></h3></div><div class="entry"><h3 id="define-modify-macro-incf-pointer-&optional-(offset-1)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-modify-macro</span></div><div class="span"><span class="name" id="CFFI:INCF-POINTER">incf-pointer</span></div><span class="args lisp">&amp;optional (offset 1)</span></div></h3></div><div class="entry"><h3 id="defmacro-incf-pointer-place-&optional-(offset-1)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:INCF-POINTER">incf-pointer</span></div><span class="args lisp">place &amp;optional (offset 1)</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-mem-ref-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:MEM-REF">mem-ref</span></div><span class="args lisp">ptr type &amp;optional (offset 0)</span></div></h3><div class="docstring"><p>Return the value of TYPE at OFFSET bytes from PTR. If TYPE is aggregate, we don't return its 'value' but a pointer to it, which is PTR itself.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-mem-ref-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:MEM-REF">mem-ref</span></div><span class="args lisp">ptr type &amp;optional (offset 0)</span></div></h3><div class="docstring"><p>Compiler macro to open-code MEM-REF when TYPE is constant.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-setf-expander-mem-ref-ptr-type-&optional-(offset-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-setf-expander</span></div><div class="span"><span class="name" id="CFFI:MEM-REF">mem-ref</span></div><span class="args lisp">ptr type &amp;optional (offset 0)</span></div></h3><div class="docstring"><p>SETF expander for MEM-REF that doesn't rebind TYPE. This is necessary for the compiler macro on MEM-SET to be able to open-code (SETF MEM-REF) forms.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-mem-aref-ptr-type-&optional-(index-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:MEM-AREF">mem-aref</span></div><span class="args lisp">ptr type &amp;optional (index 0)</span></div></h3><div class="docstring"><p>Like MEM-REF except for accessing 1d arrays.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-mem-aref-ptr-type-&optional-(index-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:MEM-AREF">mem-aref</span></div><span class="args lisp">ptr type &amp;optional (index 0)</span></div></h3><div class="docstring"><p>Compiler macro to open-code MEM-AREF when TYPE (and eventually INDEX).</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-setf-expander-mem-aref-ptr-type-&optional-(index-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-setf-expander</span></div><div class="span"><span class="name" id="CFFI:MEM-AREF">mem-aref</span></div><span class="args lisp">ptr type &amp;optional (index 0)</span></div></h3><div class="docstring"><p>SETF expander for MEM-AREF.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-define-compiler-macro-mem-aptr-cffi-ptr-type-&optional-(index-0)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:MEM-APTR">mem-aptr</span></div><span class="package">cffi</span><span class="args lisp">ptr type &amp;optional (index 0)</span></div></h3><div class="docstring"><p>The pointer to the element.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-parse-method-array-element-type-&rest-dimensions"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name" id="KEYWORD:ARRAY">array</span></div><span class="args lisp">element-type &amp;rest dimensions</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-alloc-type-&key-(initial-element-nil-initial-element-p)-(initial-contents-nil-initial-contents-p)-(count-1-count-p)-null-terminated-p"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ALLOC">foreign-alloc</span></div><span class="args lisp">type &amp;key (initial-element nil initial-element-p) (initial-contents nil initial-contents-p) (count 1 count-p) null-terminated-p</span></div></h3><div class="docstring"><p>Allocate enough memory to hold COUNT objects of type TYPE. If INITIAL-ELEMENT is supplied, each element of the newly allocated memory is initialized with its value. If INITIAL-CONTENTS is supplied, each of its elements will be used to initialize the contents of the newly allocated memory.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-foreign-alloc-type-&rest-args-&key-(count-1-count-p)-&allow-other-keys"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ALLOC">foreign-alloc</span></div><span class="args lisp">type &amp;rest args &amp;key (count 1 count-p) &amp;allow-other-keys</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-lisp-array-to-foreign-array-pointer-array-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:LISP-ARRAY-TO-FOREIGN">lisp-array-to-foreign</span></div><span class="args lisp">array pointer array-type</span></div></h3><div class="docstring"><p>Copy elements from a Lisp array to POINTER. ARRAY-TYPE must be a CFFI array type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-array-to-lisp-pointer-array-type-&rest-make-array-args"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ARRAY-TO-LISP">foreign-array-to-lisp</span></div><span class="args lisp">pointer array-type &amp;rest make-array-args</span></div></h3><div class="docstring"><p>Copy elements from pointer into a Lisp array. ARRAY-TYPE must be a CFFI array type; the type of the resulting Lisp array can be defined in MAKE-ARRAY-ARGS that are then passed to MAKE-ARRAY. If POINTER is a null pointer, returns NIL.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-array-alloc-array-array-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ARRAY-ALLOC">foreign-array-alloc</span></div><span class="args lisp">array array-type</span></div></h3><div class="docstring"><p>Allocate a foreign array containing the elements of lisp array. The foreign array must be freed with foreign-array-free.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-array-free-ptr"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ARRAY-FREE">foreign-array-free</span></div><span class="args lisp">ptr</span></div></h3><div class="docstring"><p>Free a foreign array allocated by foreign-array-alloc.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-array-(var-lisp-array-array-type)-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-ARRAY">with-foreign-array</span></div><span class="args lisp">(var lisp-array array-type) &amp;body body</span></div></h3><div class="docstring"><p>Bind var to a foreign array containing lisp-array elements in body.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-aref-ptr-array-type-&rest-indexes"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-AREF">foreign-aref</span></div><span class="args lisp">ptr array-type &amp;rest indexes</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-slot-names-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-NAMES">foreign-slot-names</span></div><span class="args lisp">type</span></div></h3><div class="docstring"><p>Returns a list of TYPE's slot names in no particular order.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-parse-method-struct-name"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name" id="KEYWORD:STRUCT">struct</span></div><span class="args lisp">name</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defcstruct-name-and-options-&body-fields"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCSTRUCT">defcstruct</span></div><span class="args lisp">name-and-options &amp;body fields</span></div></h3><div class="docstring"><p>Define the layout of a foreign structure.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-slot-pointer-ptr-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-POINTER">foreign-slot-pointer</span></div><span class="args lisp">ptr type slot-name</span></div></h3><div class="docstring"><p>Return the address of SLOT-NAME in the structure at PTR.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-foreign-slot-pointer-ptr-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-POINTER">foreign-slot-pointer</span></div><span class="args lisp">ptr type slot-name</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-slot-type-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-TYPE">foreign-slot-type</span></div><span class="args lisp">type slot-name</span></div></h3><div class="docstring"><p>Return the type of SLOT in a struct TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-slot-offset-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-OFFSET">foreign-slot-offset</span></div><span class="args lisp">type slot-name</span></div></h3><div class="docstring"><p>Return the offset of SLOT in a struct TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-slot-count-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-COUNT">foreign-slot-count</span></div><span class="args lisp">type slot-name</span></div></h3><div class="docstring"><p>Return the number of items in SLOT in a struct TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-slot-value-ptr-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-VALUE">foreign-slot-value</span></div><span class="args lisp">ptr type slot-name</span></div></h3><div class="docstring"><p>Return the value of SLOT-NAME in the foreign structure at PTR.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-foreign-slot-value-ptr-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-VALUE">foreign-slot-value</span></div><span class="args lisp">ptr type slot-name</span></div></h3><div class="docstring"><p>Optimizer for FOREIGN-SLOT-VALUE when TYPE is constant.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-setf-expander-foreign-slot-value-ptr-type-slot-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-setf-expander</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SLOT-VALUE">foreign-slot-value</span></div><span class="args lisp">ptr type slot-name</span></div></h3><div class="docstring"><p>SETF expander for FOREIGN-SLOT-VALUE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-slots-(vars-ptr-type)-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-SLOTS">with-foreign-slots</span></div><span class="args lisp">(vars ptr type) &amp;body body</span></div></h3><div class="docstring"><p>Create local symbol macros for each var in VARS to reference foreign slots in PTR of TYPE. Similar to WITH-SLOTS. Each var can be of the form: slot-name - in which case slot-name will be bound to the value of the slot or: (:pointer slot-name) - in which case slot-name will be bound to the pointer to that slot.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-define-c-struct-wrapper-class-and-type-supers-&optional-slots"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFINE-C-STRUCT-WRAPPER">define-c-struct-wrapper</span></div><span class="args lisp">class-and-type supers &amp;optional slots</span></div></h3><div class="docstring"><p>Define a new class with CLOS slots matching those of a foreign struct type. An INITIALIZE-INSTANCE method is defined which takes a :POINTER initarg that is used to store the slots of a foreign object. This pointer is only used for initialization and it is not retained.</p>
<p>CLASS-AND-TYPE is either a list of the form (class-name struct-type) or a single symbol naming both. The class will inherit SUPERS. If a list of SLOTS is specified, only those slots will be defined and stored.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-parse-method-union-name"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name" id="KEYWORD:UNION">union</span></div><span class="args lisp">name</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defcunion-name-and-options-&body-fields"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCUNION">defcunion</span></div><span class="args lisp">name-and-options &amp;body fields</span></div></h3><div class="docstring"><p>Define the layout of a foreign union.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-object-(var-type-&optional-(count-1))-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-OBJECT">with-foreign-object</span></div><span class="args lisp">(var type &amp;optional (count 1)) &amp;body body</span></div></h3><div class="docstring"><p>Bind VAR to a pointer to COUNT objects of TYPE during BODY. The buffer has dynamic extent and may be stack allocated.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-objects-bindings-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-OBJECTS">with-foreign-objects</span></div><span class="args lisp">bindings &amp;body body</span></div></h3></div><div class="entry"><h3 id="define-parse-method-wrapper-base-type-&key-to-c-from-c"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name" id="KEYWORD:WRAPPER">wrapper</span></div><span class="args lisp">base-type &amp;key to-c from-c</span></div></h3></div><div class="entry"><h3 id="define-parse-method-boolean-&optional-(base-type-int)"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name" id="KEYWORD:BOOLEAN">boolean</span></div><span class="args lisp">&amp;optional (base-type int)</span></div></h3></div><div class="entry"><h3 id="defctype-bool-uchar-ushort-uint-ulong-llong-ullong-int8-int16-int32-int64-intptr-uint8-uint16-uint32-uint64-uintptr-keyword"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">defctype</span></div><div class="span"><span class="name EXTERNAL" id="KEYWORD:BOOL">bool</span><span class="name EXTERNAL" id="KEYWORD:UCHAR">uchar</span><span class="name EXTERNAL" id="KEYWORD:USHORT">ushort</span><span class="name EXTERNAL" id="KEYWORD:UINT">uint</span><span class="name EXTERNAL" id="KEYWORD:ULONG">ulong</span><span class="name EXTERNAL" id="KEYWORD:LLONG">llong</span><span class="name EXTERNAL" id="KEYWORD:ULLONG">ullong</span><span class="name EXTERNAL" id="KEYWORD:INT8">int8</span><span class="name EXTERNAL" id="KEYWORD:INT16">int16</span><span class="name EXTERNAL" id="KEYWORD:INT32">int32</span><span class="name EXTERNAL" id="KEYWORD:INT64">int64</span><span class="name EXTERNAL" id="KEYWORD:INTPTR">intptr</span><span class="name EXTERNAL" id="KEYWORD:UINT8">uint8</span><span class="name EXTERNAL" id="KEYWORD:UINT16">uint16</span><span class="name EXTERNAL" id="KEYWORD:UINT32">uint32</span><span class="name EXTERNAL" id="KEYWORD:UINT64">uint64</span><span class="name EXTERNAL" id="KEYWORD:UINTPTR">uintptr</span></div><span class="package">keyword</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><h2 id="src/enum.lisp"><span class="file">enum</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/enum.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defmacro-defcenum-name-and-options-&body-enum-list"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCENUM">defcenum</span></div><span class="args lisp">name-and-options &amp;body enum-list</span></div></h3><div class="docstring"><p>Define an foreign enumerated type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-enum-keyword-list-enum-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ENUM-KEYWORD-LIST">foreign-enum-keyword-list</span></div><span class="args lisp">enum-type</span></div></h3><div class="docstring"><p>Return a list of KEYWORDS defined in ENUM-TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-enum-value-type-keyword-&key-(errorp-t)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ENUM-VALUE">foreign-enum-value</span></div><span class="args lisp">type keyword &amp;key (errorp t)</span></div></h3><div class="docstring"><p>Convert a KEYWORD into an integer according to the enum TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-enum-keyword-type-value-&key-(errorp-t)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-ENUM-KEYWORD">foreign-enum-keyword</span></div><span class="args lisp">type value &amp;key (errorp t)</span></div></h3><div class="docstring"><p>Convert an integer VALUE into a keyword according to the enum TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defbitfield-name-and-options-&body-masks"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFBITFIELD">defbitfield</span></div><span class="args lisp">name-and-options &amp;body masks</span></div></h3><div class="docstring"><p>Define an foreign enumerated type.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-bitfield-symbol-list-bitfield-type"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-BITFIELD-SYMBOL-LIST">foreign-bitfield-symbol-list</span></div><span class="args lisp">bitfield-type</span></div></h3><div class="docstring"><p>Return a list of SYMBOLS defined in BITFIELD-TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-bitfield-value-type-symbols"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-BITFIELD-VALUE">foreign-bitfield-value</span></div><span class="args lisp">type symbols</span></div></h3><div class="docstring"><p>Convert a list of symbols into an integer according to the TYPE bitfield.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-foreign-bitfield-value-type-symbols"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-BITFIELD-VALUE">foreign-bitfield-value</span></div><span class="args lisp">type symbols</span></div></h3><div class="docstring"><p>Optimize for when TYPE and SYMBOLS are constant.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-bitfield-symbols-type-value"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-BITFIELD-SYMBOLS">foreign-bitfield-symbols</span></div><span class="args lisp">type value</span></div></h3><div class="docstring"><p>Convert an integer VALUE into a list of matching symbols according to the bitfield TYPE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-compiler-macro-foreign-bitfield-symbols-type-value"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">define-compiler-macro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-BITFIELD-SYMBOLS">foreign-bitfield-symbols</span></div><span class="args lisp">type value</span></div></h3><div class="docstring"><p>Optimize for when TYPE and SYMBOLS are constant.</p>
</div></div></div><h2 id="src/strings.lisp"><span class="file">strings</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/strings.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defvar-*default-foreign-encoding*"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defvar</span></div><div class="span"><span class="name" id="CFFI:*DEFAULT-FOREIGN-ENCODING*">*default-foreign-encoding*</span></div></div></h3></div><div class="entry"><h3 id="defun-lisp-string-to-foreign-string-buffer-bufsize-&key-(start-0)-end-offset-(encoding-*default-foreign-encoding*)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:LISP-STRING-TO-FOREIGN">lisp-string-to-foreign</span></div><span class="args lisp">string buffer bufsize &amp;key (start 0) end offset (encoding *default-foreign-encoding*)</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-string-to-lisp-pointer-&key-(offset-0)-count-(max-chars-(1--array-total-size-limit))-(encoding-*default-foreign-encoding*)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-STRING-TO-LISP">foreign-string-to-lisp</span></div><span class="args lisp">pointer &amp;key (offset 0) count (max-chars (1- array-total-size-limit)) (encoding *default-foreign-encoding*)</span></div></h3><div class="docstring"><p>Copy at most COUNT bytes from POINTER plus OFFSET encoded in ENCODING into a Lisp string and return it. If POINTER is a null pointer, NIL is returned.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-string-alloc-string-&key-(encoding-*default-foreign-encoding*)-(null-terminated-p-t)-(start-0)-end"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-STRING-ALLOC">foreign-string-alloc</span></div><span class="args lisp">string &amp;key (encoding *default-foreign-encoding*) (null-terminated-p t) (start 0) end</span></div></h3><div class="docstring"><p>Allocate a foreign string containing Lisp string STRING. The string must be freed with FOREIGN-STRING-FREE.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-string-free-ptr"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-STRING-FREE">foreign-string-free</span></div><span class="args lisp">ptr</span></div></h3><div class="docstring"><p>Free a foreign string allocated by FOREIGN-STRING-ALLOC.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-string-(var-or-vars-lisp-string-&rest-args)-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-STRING">with-foreign-string</span></div><span class="args lisp">(var-or-vars lisp-string &amp;rest args) &amp;body body</span></div></h3><div class="docstring"><p>VAR-OR-VARS is not evaluated and should be a list of the form (VAR &amp;OPTIONAL BYTE-SIZE-VAR) or just a VAR symbol. VAR is bound to a foreign string containing LISP-STRING in BODY. When BYTE-SIZE-VAR is specified then bind the C buffer size (including the possible null terminator(s)) to this variable.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-strings-bindings-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-STRINGS">with-foreign-strings</span></div><span class="args lisp">bindings &amp;body body</span></div></h3><div class="docstring"><p>See WITH-FOREIGN-STRING's documentation.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-with-foreign-pointer-as-string-(var-or-vars-size-&rest-args)-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:WITH-FOREIGN-POINTER-AS-STRING">with-foreign-pointer-as-string</span></div><span class="args lisp">(var-or-vars size &amp;rest args) &amp;body body</span></div></h3><div class="docstring"><p>VAR-OR-VARS is not evaluated and should be a list of the form (VAR &amp;OPTIONAL SIZE-VAR) or just a VAR symbol. VAR is bound to a foreign buffer of size SIZE within BODY. The return value is constructed by calling FOREIGN-STRING-TO-LISP on the foreign buffer along with ARGS.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="define-parse-method-string-string+ptr-keyword-&rest-args"><div class="pkg-KEYWORD EXTERNAL"><div class="span"><span class="doctype">define-parse-method</span></div><div class="span"><span class="name EXTERNAL" id="KEYWORD:STRING">string</span><span class="name EXTERNAL" id="KEYWORD:STRING+PTR">string+ptr</span></div><span class="package">keyword</span><span class="args lisp">&amp;rest args</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><h2 id="src/structures.lisp"><span class="file">structures</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/structures.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defmacro-define-translation-method-(object-type-method)-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFINE-TRANSLATION-METHOD">define-translation-method</span></div><span class="args lisp">(object type method) &amp;body body</span></div></h3><div class="docstring"><p>Define a translation method for the foreign structure type; 'method is one of :into, :from, or :to, meaning relation to foreign memory. If :into, the variable 'pointer is the foreign pointer. Note: type must be defined and loaded before this macro is expanded, and just the bare name (without :struct) should be specified.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-translation-forms-for-class-class-type-class"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:TRANSLATION-FORMS-FOR-CLASS">translation-forms-for-class</span></div><span class="args lisp">class type-class</span></div></h3><div class="docstring"><p>Make forms for translation of foreign structures to and from a standard class. The class slots are assumed to have the same name as the foreign structure.</p>
</div></div></div><h2 id="src/functions.lisp"><span class="file">functions</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/functions.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defmacro-foreign-funcall-name-and-options-&rest-args"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-FUNCALL">foreign-funcall</span></div><span class="args lisp">name-and-options &amp;rest args</span></div></h3><div class="docstring"><p>Wrapper around %FOREIGN-FUNCALL that translates its arguments.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-foreign-funcall-pointer-pointer-options-&rest-args"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-FUNCALL-POINTER">foreign-funcall-pointer</span></div><span class="args lisp">pointer options &amp;rest args</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-foreign-funcall-varargs-name-and-options-fixed-args-&rest-varargs"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-FUNCALL-VARARGS">foreign-funcall-varargs</span></div><span class="args lisp">name-and-options fixed-args &amp;rest varargs</span></div></h3><div class="docstring"><p>Wrapper around %FOREIGN-FUNCALL that translates its arguments and does type promotion for the variadic arguments.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-foreign-funcall-pointer-varargs-pointer-options-fixed-args-&rest-varargs"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-FUNCALL-POINTER-VARARGS">foreign-funcall-pointer-varargs</span></div><span class="args lisp">pointer options fixed-args &amp;rest varargs</span></div></h3><div class="docstring"><p>Wrapper around %FOREIGN-FUNCALL-POINTER that translates its arguments and does type promotion for the variadic arguments.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defgeneric-translate-underscore-separated-name-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-UNDERSCORE-SEPARATED-NAME">translate-underscore-separated-name</span></div><span class="args lisp">name</span></div></h3></div><div class="entry"><h3 id="defmethod-translate-underscore-separated-name-(name-symbol)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-UNDERSCORE-SEPARATED-NAME">translate-underscore-separated-name</span></div><span class="args lisp">(name symbol)</span></div></h3></div><div class="entry"><h3 id="defgeneric-translate-camelcase-name-name-&key-upper-initial-p-special-words"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-CAMELCASE-NAME">translate-camelcase-name</span></div><span class="args lisp">name &amp;key upper-initial-p special-words</span></div></h3></div><div class="entry"><h3 id="defmethod-translate-camelcase-name-(name-symbol)-&key-upper-initial-p-special-words"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-CAMELCASE-NAME">translate-camelcase-name</span></div><span class="args lisp">(name symbol) &amp;key upper-initial-p special-words</span></div></h3></div><div class="entry"><h3 id="defgeneric-defmethod-translate-name-from-foreign-cffi-foreign-name-package-&optional-varp"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-NAME-FROM-FOREIGN">translate-name-from-foreign</span></div><span class="package">cffi</span><span class="args lisp">foreign-name package &amp;optional varp</span></div></h3></div><div class="entry"><h3 id="defgeneric-defmethod-translate-name-to-foreign-cffi-lisp-name-package-&optional-varp"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defgeneric</span><span class="doctype">defmethod</span></div><div class="span"><span class="name" id="CFFI:TRANSLATE-NAME-TO-FOREIGN">translate-name-to-foreign</span></div><span class="package">cffi</span><span class="args lisp">lisp-name package &amp;optional varp</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defcfun-name-and-options-return-type-&body-args"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCFUN">defcfun</span></div><span class="args lisp">name-and-options return-type &amp;body args</span></div></h3><div class="docstring"><p>Defines a Lisp function that calls a foreign function.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defcallback-name-and-options-return-type-args-&body-body"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCALLBACK">defcallback</span></div><span class="args lisp">name-and-options return-type args &amp;body body</span></div></h3></div><div class="entry"><h3 id="defun-get-callback-symbol"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:GET-CALLBACK">get-callback</span></div><span class="args lisp">symbol</span></div></h3></div><div class="entry"><h3 id="defmacro-callback-name"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:CALLBACK">callback</span></div><span class="args lisp">name</span></div></h3><div class="docstring missing">(all documentation missing)</div></div></div><h2 id="src/foreign-vars.lisp"><span class="file">foreign-vars</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/foreign-vars.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun-get-var-pointer-symbol"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:GET-VAR-POINTER">get-var-pointer</span></div><span class="args lisp">symbol</span></div></h3><div class="docstring"><p>Return a pointer to the foreign global variable relative to SYMBOL.</p>
</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defun-foreign-symbol-pointer-name-&key-(library-default)"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI:FOREIGN-SYMBOL-POINTER">foreign-symbol-pointer</span></div><span class="args lisp">name &amp;key (library default)</span></div></h3><div class="docstring missing">(documentation missing)</div></div></div><div class="doc-entry"><div class="entry"><h3 id="defmacro-defcvar-name-and-options-type-&optional-documentation"><div class="pkg-CFFI EXTERNAL"><div class="span"><span class="doctype">defmacro</span></div><div class="span"><span class="name" id="CFFI:DEFCVAR">defcvar</span></div><span class="args lisp">name-and-options type &amp;optional documentation</span></div></h3><div class="docstring"><p>Define a foreign global variable.</p>
</div></div></div><h2 id="src/foreign-vars.lisp"><span class="file">foreign-vars</span><span class="extension">lisp</span><a class="source-link" href="file:///home/masataro/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.23.0/src/foreign-vars.lisp">[source]</a></h2><div class="doc-entry"><div class="entry"><h3 id="defun-cffi-feature-p-feature-expression"><div class="pkg-CFFI-FEATURES EXTERNAL"><div class="span"><span class="doctype">defun</span></div><div class="span"><span class="name" id="CFFI-FEATURES:CFFI-FEATURE-P">cffi-feature-p</span></div><span class="args lisp">feature-expression</span></div></h3><div class="docstring"><p>Matches a FEATURE-EXPRESSION against those symbols in <em>FEATURES</em> that belong to the CFFI-FEATURES package.</p>
</div></div></div></div><div class="footer"></div></body></html>